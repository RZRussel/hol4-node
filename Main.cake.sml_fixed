(**
 *  Structure defines a storage for exception printers and
 *  functions to get strings from exceptions
 *)
structure Exception =
struct
    type exn_printer = (exn -> string)

    (**  
     *  Exception to be raised by printer functions 
     *  if exception does is not handled by the printer
     *)
    exception Unknown

    local
        fun exn_printer_base exn = 
            case exn of
              (*    Basis primitive exceptions  *)
                Bind => "Bind"
              | Chr => "Chr"
              | Div => "Div"
              | Subscript => "Subscript"
  
              (*    TextIO type exceptions  *)
              | TextIO.BadFileName => "TextIO.BadFileName"
              | TextIO.InvalidFD => "TextIO.InvalidFD"
              | TextIO.EndOfFile => "TextIO.EndOfFile"
              | TextIO.IllegalArgument => "TextIO.IllegalArgument"
            
              (*    Raise if exception is unknown    *)
              | _ => raise Unknown
    in
        val (exn_name_printers : exn_printer list ref) = Ref [exn_printer_base]

        val (exn_message_printers : exn_printer list ref) = Ref [exn_printer_base]
    end

    fun add_exn_name_printer printer =
        exn_name_printers := (printer :: (!exn_name_printers))

    fun add_exn_message_printer printer =
        exn_message_printers := (printer :: (!exn_message_printers))

    local
        fun printer_search exn (printers_list : exn_printer list) =
                case printers_list of
                    [] => "Unknown exception"
                  | (printer::others) =>
                        printer exn handle Unknown => printer_search exn others
    in
        fun exnName exn = printer_search exn (!exn_name_printers)

        fun exnMessage exn = printer_search exn (!exn_message_printers)
    end
        
end 
datatype ('a, 'b) result = Ok 'a | Error 'b
structure ByteArray = 
struct
	fun make_empty length =
		Word8Array.array length (Word8.fromInt 0);
	
	fun empty length =
		Word8Array.array length (Word8.fromInt 0);

	fun repeat value length =
		Word8Array.array length (Word8.fromInt value);

	fun range bytes start length = 
		let
			val rbytes = Word8Array.array length (Word8.fromInt 0)
		in
			(Word8Array.copy bytes start length rbytes 0; rbytes)
		end

	fun prefix bytes len =
		range bytes 0 len

	fun suffix bytes start =
		range bytes start ((Word8Array.length bytes) - start)

	fun from_string target =
		let
			val str_size = String.size target
			val result = Word8Array.array str_size (Word8.fromInt 0)
		in
			(Word8Array.copyVec target 0 str_size result 0; result)
		end;

	fun to_string bytes =
		Word8Array.substring bytes 0 (Word8Array.length bytes);

	fun subarray (src : byte_array) (offset : int) (length : int) =
		from_string (Word8Array.substring src offset length)

	fun concat array1 array2 =
		let
			val size1 = Word8Array.length array1 
			val size2 = Word8Array.length array2
		  	val result = Word8Array.array (size1 + size2) (Word8.fromInt 0)
		in
		  	Word8Array.copy array1 0 size1 result 0;
			Word8Array.copy array2 0 size2 result size1;
			result
		end

	fun compareFromIndex index array1 array2 length =
		if index >= length then Equal
		else
			let
				val value1 = Word8.toInt (Word8Array.sub array1 index)
				val value2 = Word8.toInt (Word8Array.sub array2 index)
			in
				if value1 > value2 then Greater
				else
					if value1 < value2 then Less
					else
						compareFromIndex (index + 1) array1 array2 length
			end;


	fun compare array1 array2 =
		let
			val length1 = Word8Array.length array1
			val length2 = Word8Array.length array2
		in
			if length1 > length2 then Greater
			else
				if length1 < length2 then Less
				else
					compareFromIndex 0 array1 array2 length1
		end;

	fun equal array1 array2 =
		case compare array1 array2 of
			Equal => True
			| Greater => False
			| Less => False;

	fun to_list aarray =
		List.map (fn ch => Word8.fromInt (Char.ord ch)) (String.explode (Word8Array.substring aarray 0 (Word8Array.length aarray)));

	fun from_list byte_list =
		let
			val length = List.length byte_list
			val buffer = Word8Array.array length (Word8.fromInt 0)
			val str = String.implode (List.map (fn byte => Char.chr (Word8.toInt byte)) byte_list)
		in
			(Word8Array.copyVec str 0 (String.size str) buffer 0; buffer)
		end

	fun rev byte_array =
		from_list (List.rev (to_list byte_array))
end;
(**This is implementation of set functionality
   @params comparator set
   @param comparator is a funnction to compare Set elements one with another
   @param set is a list of all elements in set
*)

datatype 'a set = Set ('a -> 'a -> ordering) ('a list)

structure Set = 
struct
   fun member (Set comparator set) obj  = 
        case set of 
            [] => False
          | item::items =>
            if (comparator obj item) = Equal
                then True 
            else 
                member (Set comparator items) obj
   
   fun add (Set comparator set) item = 
       if not (member (Set comparator set) item) then (Set comparator (item::set))
       else (Set comparator set)

   fun add_list set lst = 
       case lst of 
            [] => set
          | item::items => add_list (add set item) items 

   fun remove lst obj comparator = 
        case lst of 
             [] => []
           | item::items => 
            if (comparator obj item) = Equal 
                then items
            else 
                item::(remove items obj comparator)      

   fun subtract (Set comparator set) value = 
       (Set comparator (remove set value comparator))

   fun subtract_list set lst =
        case lst of
             [] => set
           | item::items => subtract_list (subtract set item) items

    
   fun empty comparator = Set comparator [];
   
   fun singleton comparator item = Set comparator [item];

   fun is_empty (Set comparator set) = 
        if (List.length set) = 0 then True
        else False;

   fun from_list comparator lst = 
      List.foldl (fn set => fn item => add set item) (empty comparator) lst;

   fun to_list (Set comparator lst) = 
      let
        fun greater_than x y comparator =
          case comparator x y of
            Greater => True
            | _ => False
      in
        List.sort (fn x => fn y => greater_than x y comparator) lst
      end

   fun get_comparator (Set comparator lst) = comparator;

   fun length (Set comparator lst) = List.length lst;

   fun any (Set comparator lst) = List.hd lst;

end;structure Serialization = 
struct
(*TODO: fix codestyle*)
    fun pow(i, n) = if n > 0 then 
                        i * pow(i, n-1) 
                    else    
                        1    

    fun decode_int_byte_array i n l = 
        if (n < Word8Array.length i) andalso (l > 0) then
            (Word8.toInt (Word8Array.sub i n)) + (256 * (decode_int_byte_array i (n+1) (l-1)))
        else 
            0          


    fun encode_int8 i =
        let
			val str_size = 1
            val hash = Word8Array.array str_size ((Word8.fromInt (Int.mod i 256)));
		in
			 (
              hash
             )
		end;

    fun decode_int8 i = (Word8.toInt (Word8Array.sub i 0),1)
             
    
    fun encode_int16 i =
        let
            val hash = ByteArray.from_list ((Word8.fromInt (Int.mod i 256)) ::
                                            (Word8.fromInt (Int.div i 256))::[]);
		in
			 (
              hash
             )
		end;

    
    fun decode_int16 i = (decode_int_byte_array i 0 2,2)

    fun encode_int32 i =
        let
            val hash = ByteArray.from_list ((Word8.fromInt (Int.mod i 256)) :: 
                                            (Word8.fromInt (Int.mod (Int.div i 256) 256)) ::
                                            (Word8.fromInt (Int.mod (Int.div i (256*256)) 256) ) ::
                                            (Word8.fromInt (Int.div i (256*256*256)))::[]);
		in
			 (
              hash
             )
		end;
        
    
    fun decode_int32 i = (decode_int_byte_array i 0 4, 4)


    fun build_int_flex_list i =
        if i < 256 then
              (Word8.fromInt i)::[]
        else
              (Word8.fromInt (Int.mod i 256))::build_int_flex_list(Int.div i 256)



    fun encode_int_flex i =
        let
            val hash = (
                       if i < 64 then
                            ByteArray.from_list (build_int_flex_list (i*4))
                       else if i < pow(2,14) then
                            ByteArray.from_list (build_int_flex_list (i*4 + 1))
                       else if i < pow(2,22) then
                            ByteArray.from_list ((build_int_flex_list (i*4 + 2))@((Word8.fromInt 0)::[]))
                       else if i < pow(2,30) then
                            ByteArray.from_list (build_int_flex_list (i*4 + 2))
                       else
                          
                            let
                                val encoded_num = build_int_flex_list (i)
                                (*Prefix is needed to describe the number of bytes,
                                 utilised to store int*)
                                val utilitary_prefix = 
                                    Word8.fromInt((((List.length encoded_num)-4)*4) + 3) :: []
                            in 
                                ByteArray.from_list (utilitary_prefix @ encoded_num)
                            end
                       )
		in
              hash
		end;
    
    fun decode_int_flex i = (
                          if ( Int.mod (Word8.toInt (Word8Array.sub i 0)) 4 ) = 0 then
                             ( Int.div (decode_int_byte_array i 0 1) 4, 1)
                          else if (Int.mod (Word8.toInt (Word8Array.sub i 0)) 4) = 1 then
                             ( Int.div (decode_int_byte_array i 0 2) 4, 2)
                          else if (Int.mod (Word8.toInt (Word8Array.sub i 0)) 4) = 2 then
                             ( Int.div (decode_int_byte_array i 0 4) 4, 4)
                          else 
                             let 
                                val len = ((Int.div (Word8.toInt (Word8Array.sub i 0)) 4) + 4)
                             in
                                ((decode_int_byte_array i 1 len), len+1)
                             end
                          )
                        
    

    fun encode_bool b =
        let
            val str_size = 1;
        in 
            if b = True then
                Word8Array.array str_size (Word8.fromInt 1)
            else
                Word8Array.array str_size (Word8.fromInt 0)
        end;

    fun decode_bool b =
        if (Word8.toInt (Word8Array.sub b 0)) = 1 then
            (True, 1)
        else
            (False,1)

    fun string_to_word8_list s j =
        if j < (String.size s) then
            (Word8.fromInt(Char.ord(String.sub s j))) :: 
                (string_to_word8_list s (j+1))
        else
            []

    fun encode_string s =
        ByteArray.from_list (
                (ByteArray.to_list(encode_int_flex (String.size s))) @ 
                    (string_to_word8_list s 0)
            )

    fun decode_string_by_chars s l r =
        if (l < r) andalso (l < (Word8Array.length(s))) then
            (Char.chr (Word8.toInt (Word8Array.sub s l)) ) :: 
                (decode_string_by_chars s (l+1) r)
        else
            []

    fun decode_string s = 
        let
            val (str_size, int_size) = decode_int_flex s
        in
            (String.implode(decode_string_by_chars s int_size (str_size + int_size)), int_size+str_size )
        end;

    fun encode_byte_array byte_arr = byte_arr

    fun decode_byte_array len byte_arr = 
        (ByteArray.from_list( List.take (ByteArray.to_list(byte_arr)) len) , len)


    fun encode_tuple2 enc_fun1 enc_fun2 (e1, e2)  =
        ByteArray.from_list( (ByteArray.to_list(enc_fun1 e1)) @ 
                             (ByteArray.to_list(enc_fun2 e2)) )


    fun decode_tuple2 dec_fun1 dec_fun2 tup =
        let
            val (e1, len1) = dec_fun1 tup
            val enc_e2 = ByteArray.from_list(List.drop (ByteArray.to_list tup) len1)
            val (e2, len2) = dec_fun2 enc_e2
        in
            ((e1, e2), (len1 + len2))
        end;

    fun encode_list_element l enc_fun = 
        case l of 
            el :: lst =>
            (
                    ( ByteArray.to_list(enc_fun(el))) @ 
                        (encode_list_element lst enc_fun)
            )
          | [] => []

    fun encode_list enc_fun l = 
        ByteArray.from_list (
            ( ByteArray.to_list(encode_int_flex (List.length l) ) ) @
                 (encode_list_element l enc_fun)
        )
    
    fun read_list l dec_fun to_drop n =
        if n > 0 then
            let
                val new_l = ByteArray.from_list(List.drop (ByteArray.to_list l) to_drop)
                val (elem, len) = dec_fun(new_l)
            in
                (elem,len) :: (read_list new_l dec_fun len (n-1))
            end
        else
            []

    fun count_len lst = 
        case lst of (_, len) :: tail =>
                len + (count_len tail)
                  | [] => 0

    fun build_lst lst = 
        case lst of (elem, _) :: tail =>
                elem :: build_lst(tail)
                  | [] => []

    fun decode_list dec_fun l = 
        let
            val (list_len, int_len) = decode_int_flex l
            val lst_temp = (read_list l dec_fun int_len list_len)
            val length = count_len lst_temp
            val final_list = build_lst lst_temp
        in
            ( final_list, (length + int_len) )
        end
        
    fun encode_option_bool option_obj =
        case option_obj of
              None => (Word8Array.array 1 (Word8.fromInt 0))
            | Some True => (Word8Array.array 1 (Word8.fromInt 1))
            | Some False => (Word8Array.array 1 (Word8.fromInt 2))

    fun decode_option_bool obj_bytes = 
        case (Word8.toInt (Word8Array.sub obj_bytes 0)) of
              0 => (None, 1)
            | 1 => (Some True, 1)
            | 2 => (Some False, 1)
        
    fun encode_option enc_fun option_obj =
        case option_obj of
              None => (Word8Array.array 1 (Word8.fromInt 0))
            | Some obj => ByteArray.from_list(
                            ByteArray.to_list(Word8Array.array 1 (Word8.fromInt 1)) @
                            ByteArray.to_list(enc_fun obj))

    fun decode_option dec_fun obj_bytes =
        case (Word8.toInt (Word8Array.sub obj_bytes 0)) of
              0 => (None, 1)
            | 1 => 
                let 
                    val (obj, encode_len) = dec_fun (ByteArray.from_list(List.drop (ByteArray.to_list obj_bytes) 1))
                in
                    (Some obj, encode_len + 1)
                end

    (* depends on realization *)
    fun encode_set enc_fun set_obj = 
        encode_list (enc_fun) (Set.to_list set_obj)

    fun decode_set dec_fun comparator set_bytes = 
        let 
            val (list_obj, decode_size) = decode_list (dec_fun) set_bytes
        in
            (Set.from_list (comparator) (list_obj), decode_size)
        end

    (* no tests yet *)
    fun encode_word8 byte =
        (encode_byte_array) ByteArray.from_list((byte) :: [])

    fun decode_word8 byte =
        let 
            val (byte_arr, byte_arr_len) = decode_byte_array 1 byte
        in
            (List.hd (ByteArray.to_list byte_arr), 1)
        end

    fun encode_byte_array_as_list byte_arr =
        let
            val word8_list = ByteArray.to_list byte_arr
        in
            (encode_list (encode_word8) word8_list)
        end

    fun decode_byte_array_as_list bytes = 
        let
            val (word8_list, word8_list_len) = decode_list (decode_word8) bytes
        in
            (ByteArray.from_list word8_list, word8_list_len)
        end
end;    


structure BigEndian = 
struct
	fun int8byte8 value = 
		let
			val serialized = Word64.fromInt value 
			val result = List.genlist (fn index => 
				(Word8.fromInt (Word64.toInt (Word64.andb (Word64.fromInt 255) (Word64.>> serialized (8 * index)))))) 8
		in
			ByteArray.from_list (List.rev result)
		end;

	fun byte8int8 bytes = 
		let
			val byte_list = ByteArray.to_list bytes
		in
			List.foldl (fn result => fn item => (256 * result + (Word8.toInt item))) 0 byte_list
		end;

	fun bytes_to_int bytes =
		let
			val byte_list = ByteArray.to_list bytes
		in
			List.foldl (fn result => fn item => (256 * result + (Word8.toInt item))) 0 byte_list
		end;		

	fun int2byte2 value = 
		let
			val result = Word8Array.array 2 (Word8.fromInt 0)
		in
			(Marshalling.n2w2 value result 0; result)
		end;

	fun byte2int2 bytes = 
		Marshalling.w22n bytes 0;

		fun w4n2 bytes off =
        	let 
			val b3 = Word8Array.sub bytes off
			val b2 = Word8Array.sub bytes (off+1)
			val b1 = Word8Array.sub bytes (off+2)
			val b0 = Word8Array.sub bytes (off+3)
		in
			Word8.toInt b3 * 256 * 256 * 256 + Word8.toInt b2 * 256 * 256 + Word8.toInt b1 * 256 + Word8.toInt b0
        end;

        fun n2w4 n bytes off =
        let
            val a = Word8Array.update bytes off     (Word8.fromInt (n div (256 * 256 * 256)))
            val a = Word8Array.update bytes (off+1) (Word8.fromInt (n div (256 * 256)))
            val a = Word8Array.update bytes (off+2) (Word8.fromInt (n div 256))
            val a = Word8Array.update bytes (off+3) (Word8.fromInt n)
        in 
            ()
        end;
end;
(* If there was an error from FFI function `random`, raise this exception with `len` which had been used for `random` function *)
exception FFIRandomFailure int;

structure Random =
struct

    (* Integer byte size *)
    fun int_size () = 4

    (* Operation byte size *)
    fun op_size () = 1

    (*
       Randomness ffi urandom function.

       INPUT:  Int32 - number of required random bytes 

       OUTPUT: byte_array - `res`
                 OR
               exception `ffiRandomFailure len` if there is an error code from FFI function
    *)
    fun random len = 
        let
            val inlen  = int_size ()
            val outlen = op_size () + len

            val inbuf  = Word8Array.array inlen  (Word8.fromInt 0)
            val outbuf = Word8Array.array outlen (Word8.fromInt 0)

            val res = Word8Array.array len (Word8.fromInt 0)
        in (
            BigEndian.n2w4 len inbuf 0;

            #(random) (Word8Array.substring inbuf 0 inlen) outbuf;

            Word8Array.copy outbuf 1 len res 0;
            
            if (Word8.toInt (Word8Array.sub outbuf 0)) > 0 then raise (FFIRandomFailure len)
            else res
        )
        end;

   fun randint lower upper = 0      

end;

(*Type to describe GUID, it is byte_array*)
type guid = byte_array;

structure Guid = 
struct
	fun size () = 16;

	fun zero () = Word8Array.array (size ()) (Word8.fromInt 0);
	
	fun isValid guid =
		if (Word8Array.length guid) = (size ()) then
			 True
	        else
	       		 False;

	fun generate () =
		Random.random (size ());

	fun next start_guid index =
		ByteArray.concat 
			(BigEndian.int8byte8 ((BigEndian.byte8int8 ((ByteArray.prefix start_guid 8))) + index))
			(ByteArray.suffix start_guid ((size ()) - 8));

	val compare = ByteArray.compare
end;
exception UndefinedHexByte Word8.word;
exception UndefinedHexChar char;
exception OddHex string;

structure Hex = 
struct
	fun nibble_to_char nibble =
		case (Word8.toInt nibble) of
			0 => #"0"
			| 1 => #"1"
			| 2 => #"2"
			| 3 => #"3"
			| 4 => #"4"
			| 5 => #"5"
			| 6 => #"6"
			| 7 => #"7"
			| 8 => #"8"
			| 9 => #"9"
			| 10 => #"a"
			| 11 => #"b"
			| 12 => #"c"
			| 13 => #"d"
			| 14 => #"e"
			| 15 => #"f"
			| _ => raise (UndefinedHexByte nibble);

	fun char_to_nibble ch =
		case ch of
			#"0" => Word8.fromInt 0
			| #"1" => Word8.fromInt 1
			| #"2" => Word8.fromInt 2
			| #"3" => Word8.fromInt 3
			| #"4" => Word8.fromInt 4
			| #"5" => Word8.fromInt 5
			| #"6" => Word8.fromInt 6
			| #"7" => Word8.fromInt 7
			| #"8" => Word8.fromInt 8
			| #"9" => Word8.fromInt 9
			| #"a" => Word8.fromInt 10
			| #"b" => Word8.fromInt 11
			| #"c" => Word8.fromInt 12
			| #"d" => Word8.fromInt 13
			| #"e" => Word8.fromInt 14
			| #"f" => Word8.fromInt 15
			| #"A" => Word8.fromInt 10
			| #"B" => Word8.fromInt 11
			| #"C" => Word8.fromInt 12
			| #"D" => Word8.fromInt 13
			| #"E" => Word8.fromInt 14
			| #"F" => Word8.fromInt 15
			| _ => raise (UndefinedHexChar ch);

	fun byte_to_hex byte =
		let
			val low_bits = Word8.andb byte (Word8.fromInt 15)
			val high_bits = Word8.>> byte 4
		in 
			(String.str (nibble_to_char high_bits)) ^ (String.str (nibble_to_char low_bits))
		end;

	fun bytes_to_hex bytes =
		"0x" ^ (List.foldl (fn hex => (fn byte => hex ^ (byte_to_hex byte))) "" (ByteArray.to_list bytes));

	fun hex_to_bytes hex =
		let
			val char_list = if String.isPrefix "0x" hex then String.explode (String.substring hex 2 ((String.size hex) - 2)) else String.explode hex
			val length = List.length char_list
		in
			if (Int.mod length 2) = 0 then
				let
					fun chars_to_byte x y =
						Word8.orb (Word8.<< (char_to_nibble x) 4) (char_to_nibble y)

					fun hex_chas_to_byte_list char_list bytes_list =
						case char_list of
							[] => bytes_list
							| (x::y::tail) => hex_chas_to_byte_list tail (bytes_list @ [(chars_to_byte x y)])
				in
					ByteArray.from_list (hex_chas_to_byte_list char_list [])
				end
			else
				raise OddHex hex
		end;
end;structure Comparison = 
struct
	fun min v1 v2 = if v1 > v2 then v2 else v1;
	fun max v1 v2 = if v1 < v2 then v2 else v1;
end;

structure Formatter =
struct
	val lib_print = print

	(* string -> ('a -> string) -> 'a option -> string *)
	fun option_to_string prefix formatter opt = 
		case opt of
			None => prefix ^ "None"
		  | Some v => prefix ^ "Some (" ^ formatter v ^ ")"

	(* string -> ('a -> string) -> 'a list -> string *)
	fun list_to_string prefix formatter list =
		let
			(* string with new line symbol at the end *)
			val s = List.foldl
				(fn res => fn l => res ^ prefix ^ "- " ^ l ^ "\n")
				""
				(List.map formatter list)
			
			val len = String.size s
		in
			if len > 0
			then String.substring s 0 (String.size s - 1) (* Removes the last new line symbol *)
			else prefix ^ "{}" (* The string is empty - no elements in the list *)
		end

	(* string -> ('a -> string) -> 'a set -> string *)
	fun set_to_string prefix formatter set = 
		list_to_string prefix formatter (Set.to_list set)

	(* string -> ('a -> string) -> ('b -> string) -> ('a * 'b) list -> string *)
	fun alist_to_string prefix formatter_1 formatter_2 alist =
		list_to_string prefix (fn (a, b) => formatter_1 a ^ " : " ^ formatter_2 b) alist

	(* string -> ('a -> string) -> ('b -> string) -> ('a, 'b) map -> string *)
	fun map_to_string prefix formatter_1 formatter_2 map =
		alist_to_string prefix formatter_1 formatter_2  (Map.toAscList map)



	(* string -> (string -> 'a -> string) -> string -> 'a option -> string *)
	fun structure_option_to_string prefix formatter formatter_prefix opt = 
		case opt of
			None => prefix ^ "None"
		  | Some v => prefix ^ "Some (" ^ "\n" ^ formatter formatter_prefix v ^ "\n" ^ prefix ^ ")"

	(* string -> (string -> 'a -> string) -> 'a list -> string *)
	fun structure_list_to_string prefix formatter list =
		let
			val prefix_size = String.size prefix

			(* string with new line symbol at the end *)
			val s = List.foldl
				(fn res => fn l => res ^ l ^ "\n")
				""
				(List.map 
					(
						fn x => 
							let 
								val fx = formatter (prefix ^ "  ") x 
							in 
								(* Set '- ' symbol in the first line of the formatted structure *)
								prefix ^ "- " ^ String.substring fx (prefix_size + 2) (String.size fx - (prefix_size +2))
							end
					) 
					list)
			
			val size = String.size s
		in
			if size > 0
			then String.substring s 0 (size - 1) (* Removes the last new line symbol *)
			else prefix ^ "{}" (* The string is empty - no elements in the list *)
		end
	
	(* string -> (string -> 'a -> string) -> 'a set -> string *)
	fun structure_set_to_string prefix formatter set =
		structure_list_to_string prefix formatter (Set.to_list set)

	(* string -> (string -> 'a -> string) -> ('b -> string) -> ('a * 'b) list -> string *)
	(* fun structure_alist_to_string prefix formatter_1 formatter_2 alist =
		structure_list_to_string prefix (fn pref => fn (a, b) => formatter_1 pref a ^ " : " ^ formatter_2 b) alist *)

	(* string -> (string -> 'a -> string) -> ('b -> string) -> ('a, 'b) map -> string *)
	(* fun structure_map_to_string prefix formatter_1 formatter_2 map =
		structure_list_to_stringÐ´ prefix formatter_1 formatter_2  (Map.toAscList map) *)

end;
structure Math =
struct
    local
	  	(**
		 *	Generic function to calculate a power function in log(N).
		 *	 Uses 'Exponentiation by squaring' algorithm
		 *
		 *	@param mul_op: ```'a -> 'a -> 'a``` Function to multiplicate two operands with the type of 'base'
		 *	@param neutral: ```'a``` The result of raising 'base' in the power of 0
		 *	@param base: ```'a``` Base
		 *	@param exp: ```int``` Exponent
		 *
		 *	@return: ```'a``` Result of exponentiation
		 *)
		fun power mul_op neutral base (exp : int) = 
			if exp = 0
			then neutral
			else
				let
				  val next_v = power mul_op neutral (mul_op base base) (exp div 2)
				in
				  if even exp then next_v else mul_op base next_v
				end
	in
		val power_int = power Int.* 1
		val power_double = power Double.* (Double.fromString "1.0")
		val power_rat = power Rat.* (Rat.fromInt 1)
	end

    fun ceil (d : Word64.word (* Double *)) =
        let 
            val arr = BigEndian.int8byte8 (Word64.toInt d)
        in
            #(math_ceil) "" arr; BigEndian.byte8int8 arr
        end

    fun floor (d : Word64.word (* Double *)) =
        let 
            val arr = BigEndian.int8byte8 (Word64.toInt d)
        in
            #(math_floor) "" arr; BigEndian.byte8int8 arr
        end

end;
type in_port = int;
datatype in_addr = InAddr Word8.word Word8.word Word8.word Word8.word;

datatype sockaddr_in = SockAddrIn in_addr in_port;

exception InAddrInvalidAddress string;

exception InAddrInvalidSerialization word8;

structure InAddr =
struct
    fun in_addr_len () = 4

    fun in_addr (b0 : Word8.word) (b1 : Word8.word) 
            (b2 : Word8.word) (b3 : Word8.word) =
        InAddr b0 b1 b2 b3

    fun from_string (addr_s : string) = 
        let
            fun string_to_word8 (token : string) =
                case Int.fromString token of
                    None => raise InAddrInvalidAddress addr_s (* Token cannot be parsed as an integer *)
                  | Some value => (
                        if value >= 0 andalso value <= 255
                        then Word8.fromInt value
                        else raise InAddrInvalidAddress addr_s
                    )

            val tokens = String.tokens (fn c => c = #".") addr_s
        in 
            if
                List.length tokens = in_addr_len ()
            then
                let
                    val b0 = string_to_word8 (List.nth tokens 0)
                    val b1 = string_to_word8 (List.nth tokens 1)
                    val b2 = string_to_word8 (List.nth tokens 2)
                    val b3 = string_to_word8 (List.nth tokens 3)
                in
                    InAddr b0 b1 b2 b3
                end
            else (* IPv4 should have a form of `0.0.0.0`  *)
                raise InAddrInvalidAddress addr_s
        end

    fun to_string (InAddr b0 b1 b2 b3) =
        let
            fun word8_to_string w = Int.toString (Word8.toInt w)
        in
            word8_to_string b0 ^ "." ^ word8_to_string b1 ^ "." ^
            word8_to_string b2 ^ "." ^ word8_to_string b3
        end

    fun compare (InAddr a0 a1 a2 a3) (InAddr b0 b1 b2 b3) = 
        let
            val v0 = Int.compare (Word8.toInt a0) (Word8.toInt b0)
            val v1 = Int.compare (Word8.toInt a1) (Word8.toInt b1)
            val v2 = Int.compare (Word8.toInt a2) (Word8.toInt b2)
            val v3 = Int.compare (Word8.toInt a3) (Word8.toInt b3)
        in
            if 
                v0 <> Equal
            then 
                v0
            else if 
                v1 <> Equal
            then 
                v1 
            else if 
                v2 <> Equal
            then 
                v2
            else 
                v3
        end

    fun serialize (InAddr b0 b1 b2 b3) = 
        Serialization.encode_byte_array (ByteArray.from_list [b0, b1, b2, b3])
    
    fun deserialize serial =
        let
            fun check_byte byte_i =
                let
                    val value = Word8.toInt byte_i
                in
                    if value >= 0 andalso value <= 255
                    then byte_i
                    else raise InAddrInvalidSerialization byte_i
                end

            val (addr, addr_len) = Serialization.decode_byte_array (in_addr_len()) serial
        in (
            InAddr (check_byte (Word8Array.sub addr 0)) (check_byte (Word8Array.sub addr 1)) (check_byte (Word8Array.sub addr 2)) (check_byte (Word8Array.sub addr 3)),
            addr_len
        )
        end
end ;

structure SockAddrIn =
struct
    fun to_string (SockAddrIn addr port) =
        InAddr.to_string addr ^ ":" ^ Int.toString port

    fun compare (SockAddrIn addr1 port1) (SockAddrIn addr2 port2) =
        case InAddr.compare addr1 addr2 of
            Less => Less
          | Greater => Greater
          | Equal => Int.compare port1 port2
end ;

(* Argument parsing module
 * datatype argp:
 * parse_opt - function for parsing concrete option
 *      "state" -> ("option", Option "argument") -> "upd_state" 
 * NOTE: currently we work only with flags and -flag=val passing
*)

datatype 'a argp = Argp (* parse_opt *) ('a -> string * (string option) -> 'a);

structure Argp = 
struct
    fun parse_argument (arg : string) =
        let 
            val cleared = if String.isPrefix "--" arg
                          then String.extract arg 2 None
                          else 
                            if String.isPrefix "-" arg
                            then String.extract arg 1 None
                            else arg
           val (res_arg, value) = String.split (fn ch => ch <> #"=") cleared
           val val_opt = if value = ""
                         then None
                         else Some (String.extract value 1 None)
        in
            (res_arg, val_opt)
        end


    fun parse_arg_list (Argp parse_opt) state (arguments : string list) =
        List.foldl (parse_opt) state (List.map (parse_argument) arguments)

    fun parse user_argp init_state =
        parse_arg_list user_argp init_state (CommandLine.arguments())
end;(*  The type represents internal representation of the buffer 
 *  @param buf `byte_array ref`: reference to the buffer's data
 *  @param rd_offset `int ref`: reference to the current buffer's read offset
 *  @param wr_offset `int ref`: reference to the current buffer's write offset
 *  @param wr_lwm `int`: the low-memory watermark that should be set to
 *      exceed the maximum expected message size to be stored
 *      in the buffer. When the buffer has less than that amount
 *      of space left, it'll call crunch() function.
 *)
datatype io_buffer = IOBuffer (byte_array ref) (int ref) (int ref) int

(*  Is raised if low watermark set exceeds the size of a buffer
 *
 *  @param size `int`: current maximal size of the buffer
 *  @param low_watermark `int`: the watermark tried to be set
 *)
exception IOBufferLowWatermarkTooHigh int int

(*  Is raised when trying to read from a buffer more 
 *   than the buffer contains.
 *
 *  @param size `int`: current number of bytes available to read
 *  @param n `int`: number of bytes tried to be read
 *)
exception IOBufferNotEnoughData int int

structure IOBufferType =
struct
    fun get_buffer_ref (IOBuffer buf _ _ _) = buf
    fun get_rd_offset_ref (IOBuffer _ rd_offset _ _) = rd_offset
    fun get_wr_offset_ref (IOBuffer _ _ wr_offset _) = wr_offset

    fun get_buffer_val iob = !(get_buffer_ref iob)
    fun get_rd_offset_val iob = !(get_rd_offset_ref iob)
    fun get_wr_offset_val iob = !(get_wr_offset_ref iob)

    fun get_wr_lwm (IOBuffer _ _ _ wr_lwm) = wr_lwm
end

structure IOBuffer =
struct
    (*  Initializes a buffer 
     *  @param initial_size `int`: initial size of an array
     *  @param wr_lwm `int`: low-memory watermark
     *)
    fun init (size : int) (wr_lwm : int) = 
        let
            val initial_array = Word8Array.array size (Word8.fromInt 0)
        in
            if wr_lwm > size then raise IOBufferLowWatermarkTooHigh size wr_lwm else ();

            IOBuffer (Ref initial_array) (Ref 0) (Ref 0) wr_lwm
        end

    (* Reset read/write pointers. Any unread content will be lost. *)
    fun reset iob = (
        (IOBufferType.get_rd_offset_ref iob) := 0;
        (IOBufferType.get_wr_offset_ref iob) := 0
    )

    (* Max number of bytes the buffer can hold *)
    fun max_size iob = Word8Array.length (IOBufferType.get_buffer_val iob)

    (* Number of bytes available to be read *)
    fun size iob = 
        (IOBufferType.get_wr_offset_val iob) - (IOBufferType.get_rd_offset_val iob)

    (* Number of bytes available to be written *)
    fun capacity iob = 
        max_size iob - (IOBufferType.get_wr_offset_val iob)

    (* Returns low-memory watermark indicating when the buffer should be
     * automatically crunched by the read() call. 
     *)
    fun wr_lwm iob = IOBufferType.get_wr_lwm iob

    (* Returns true if there's no data in the buffer *)
    fun empty iob = 
        size iob = 0

    (* Returns true when the write offset
     * passed the point of wr_lwm bytes from the end of the buffer. 
     *)
    fun is_low_space iob = 
        wr_lwm iob > capacity iob

    (* Ensure there's enough total space in the buffer to hold \a n bytes. *)
    fun reserve iob (n : int) =
        if n <= capacity iob 
        then ()
        else
            let
                val old_rd_offset = IOBufferType.get_rd_offset_val iob
                val dirty_size = size iob
                val old_buffer = IOBufferType.get_buffer_val iob

                val new_size = dirty_size + n
                val new_buffer = Word8Array.array new_size (Word8.fromInt 0)
            in
                Word8Array.copy old_buffer old_rd_offset dirty_size new_buffer 0;

                (IOBufferType.get_buffer_ref iob) := new_buffer;
                (IOBufferType.get_rd_offset_ref iob) := 0;
                (IOBufferType.get_wr_offset_ref iob) := dirty_size
            end

    (*  Read \a n bytes from the buffer.
     *
     *  @param n is the number of bytes to read.
     *
     *  @returns n bytes of data that has been read from the rd_offset.
     *  @raises IOBufferNotEnoughData if there is not enough data 
     *      in the buffer to read \a n bytes.
     *)
    fun read iob (n : int) =
        if n > size iob
        then raise IOBufferNotEnoughData (size iob) n
        else
            let
                val rd_offset = IOBufferType.get_rd_offset_val iob
                val buffer = IOBufferType.get_buffer_val iob
            in
                ByteArray.from_string (Word8Array.substring buffer rd_offset n)
            end

    (*  Move any unread data to the beginning of the buffer.
     *  This function is similar to reset(), however, no unread
     *  data gets lost. 
     *)
    fun crunch iob =
        if (IOBufferType.get_rd_offset_val iob) = 0
        then ()
        else
            let
                val old_rd_offset = IOBufferType.get_rd_offset_val iob
                val size = size iob
                val buffer = IOBufferType.get_buffer_val iob
            in
                Word8Array.copy buffer old_rd_offset size buffer 0;

                (IOBufferType.get_rd_offset_ref iob) := 0;
                (IOBufferType.get_wr_offset_ref iob) := size
            end

    (*  Consume \a n bytes from the buffer (increment the rd_offset() by \a n).
     *
     *  @param n is the number of bytes to consume.
     *
     *  @raises IOBufferNotEnoughData if there is not enough data 
     *      in the buffer to consume \a n bytes.
     *)
    fun consume iob (n : int) =
        if n > size iob
        then raise IOBufferNotEnoughData (size iob) n
        else
            let
                val rd_offset = IOBufferType.get_rd_offset_val iob
            in
                (IOBufferType.get_rd_offset_ref iob) := rd_offset + n
            end

    (*  Do the same action as consume(n), and call crunch() function
     *  when the buffer's capacity gets less than the wr_lwm() value.

     *  @param n is the number of bytes to consume.
     *  @raises IOBufferNotEnoughData if there is not enough data 
     *      in the buffer to consume \a n bytes.
     *)
    fun consume_and_crunch iob (n : int) = (
        consume iob n;
        if 
            is_low_space iob
        then 
            crunch iob
        else 
            ()
    )

    (*  Write data to a buffer from a given source \a src *)
    fun write iob (src : byte_array) =
        let
            val src_len = Word8Array.length src

            val _ = reserve iob src_len

            val buffer = IOBufferType.get_buffer_val iob
            val wr_offset = IOBufferType.get_wr_offset_val iob
        in
            Word8Array.copy src 0 src_len buffer wr_offset;
            
            (IOBufferType.get_wr_offset_ref iob) := wr_offset + src_len
        end
end

val _ = 
    Exception.add_exn_name_printer 
        (fn e => 
            case e of 
                IOBufferLowWatermarkTooHigh _ _ => "IOBufferLowWatermarkTooHigh"
              | IOBufferNotEnoughData _ _ => "IOBufferNotEnoughData"
              | _ => raise Exception.Unknown
        )
val _ = 
    Exception.add_exn_message_printer
        (fn e =>
            case e of
                IOBufferLowWatermarkTooHigh v1 v2 => 
                    "IOBufferLowWatermarkTooHigh" ^ " " ^ Int.toString v1 ^ " " ^ Int.toString v2
              | IOBufferNotEnoughData v1 v2 => 
                    "IOBufferNotEnoughData" ^ " " ^ Int.toString v1 ^ " " ^ Int.toString v2
              | _ => raise Exception.Unknown
        )
(**
 *  Structure defines different kinds of messages to be logged and 
 *  describes their relations. In a logger user decides beginning from 
 *  what types they want messages to be really logged using defined levels.
 *)
structure LoggerLevel =
struct
    datatype level = Trace | Debug | Info | Warn | Error | Critical | Off

    (* Get the integer representation of the level enum. *)
    fun to_int (lvl : level) =
        case lvl of
            Trace => 0
          | Debug => 1
          | Info => 2
          | Warn => 3
          | Error => 4
          | Critical => 5
          | Off => 6
    
    (* Get the string representation of the level *)
    fun to_string (lvl : level) =
        case lvl of
            Trace => "Trace"
          | Debug => "Debug"
          | Info => "Info"
          | Warn => "Warn"
          | Error => "Error"
          | Critical => "Critical"
          | Off => "Off"

    (* Get the level by representation *)
    fun from_string level_str =
        case level_str of
          "Trace" => Some Trace
        | "Debug" => Some Debug
        | "Info" => Some Info
        | "Warn" => Some Warn
        | "Error" => Some Error
        | "Critical" => Some Critical
        | "Off" => Some Off
        | _ => None

    
    (* Functions below define relations between defferent levels *)

    fun greater (a : level) (b : level) =
        Int.> (to_int a) (to_int b)

    fun less (a : level) (b : level) =
        Int.< (to_int a) (to_int b)

    fun geq (a : level) (b : level) =
        Int.>= (to_int a) (to_int b)

    fun leq (a : level) (b : level) =
        Int.<= (to_int a) (to_int b)

    fun equal (a : level) (b : level) =
        case (a, b) of
            (Trace, Trace) => True
          | (Debug, Debug) => True
          | (Info, Info) => True
          | (Warn, Warn) => True
          | (Error, Error) => True
          | (Critical, Critical) => True
          | (Off, Off) => True
          | _ => False
end
(**
 *  Type keeps internal logger representation.
 *  @param outstream `TextIO.outstream`: the stream where logs should be written to.
 *  @param log_lvl `LoggerLevel.level`: the minimal level of messages that should be logged.
        If a message has a lower level it will be ignored.
 *)
datatype logger = Logger TextIO.outstream LoggerLevel.level

(**
 *  Structure defines getters and setters for variables of internal logger representation.
 *  Should be used only from Logger structure and should not be used externally.
 *)
structure LoggerPrivate =
struct
    fun create (outstream : TextIO.outstream) (log_lvl : LoggerLevel.level) =
        Logger outstream log_lvl

    fun get_outstream (Logger outstream _) = outstream
    fun get_log_lvl (Logger _ log_lvl) = log_lvl
    
    fun set_outstream (Logger _ log_lvl) outstream =
        Logger outstream log_lvl
    fun set_log_lvl (Logger outstream _) log_lvl = 
        Logger outstream log_lvl
end 

(**
 *  Structure defines functions to be used with logger to save logs.
 *)
structure Logger =
struct
    fun create (outstream : TextIO.outstream) (log_lvl : LoggerLevel.level) =
        LoggerPrivate.create outstream log_lvl

    fun level logger = LoggerPrivate.get_log_lvl logger

    fun set_level logger (level : LoggerLevel.level) = 
        LoggerPrivate.set_log_lvl logger level

    fun should_log logger (msg_lvl : LoggerLevel.level) =
        LoggerLevel.geq msg_lvl (LoggerPrivate.get_log_lvl logger)

    (**
     *  Internal function that outputs given message into outstream 
     *   if level of the message greater or equal than required by the logger.
     *
     *  NOTICE: Should not be used externally as the message is not formatted properly in the function.
     *   Use functions below to log a message at certain level.
     *)
    fun log logger (lvl : LoggerLevel.level) (msg : string) =
        if 
            should_log logger lvl andalso not (LoggerLevel.equal lvl LoggerLevel.Off)
        then 
            TextIO.output (LoggerPrivate.get_outstream logger) msg
        else 
            ()

    (**
     *  Functions to log messages of specific level of importance.
     *)
    local
        fun prepare_log (lvl : LoggerLevel.level) (msg : string) = 
            LoggerLevel.to_string lvl ^ ": " ^ msg ^ "\n\n"
    in
        fun trace logger (msg : string) =
            log logger LoggerLevel.Trace (prepare_log LoggerLevel.Trace msg)

        fun debug logger (msg : string) =
            log logger LoggerLevel.Debug (prepare_log LoggerLevel.Debug msg)

        fun info logger (msg : string) =
            log logger LoggerLevel.Info (prepare_log LoggerLevel.Info msg)

        fun warn logger (msg : string) =
            log logger LoggerLevel.Warn (prepare_log LoggerLevel.Warn msg)

        fun error logger (msg : string) =
            log logger LoggerLevel.Error (prepare_log LoggerLevel.Error msg)

        fun critical logger (msg : string) =
            log logger LoggerLevel.Critical (prepare_log LoggerLevel.Critical msg)
    end
end 
(**
 *  Structure defines a logger that outputs logs into stdout.
 *)
structure StdOutLogger =
struct
    fun init (lvl : LoggerLevel.level) =
        Logger.create TextIO.stdOut lvl
end

(**
 *  Structure defines a logger that outputs logs into a file.
 *)
structure FileLogger =
struct
    (**
     *  Initializes a logger that writes logs into a file located at \a filepath.
     *
     *  In case if file at specified path already exists, the function truncates 
     *  all data and starts to write from the beginning of the file.
     *)
    fun init (filepath : string) (lvl : LoggerLevel.level) =
        let
            val outstream = TextIO.openOut filepath
        in
            Logger.create outstream lvl
        end

    (**
     *  Initializes a logger that writes logs into a file located at \a filepath.
     *  
     *  The only difference with `init` function is that in case if file at specified path already exists, 
     *  it appends the suffix '.#n' to the name of the file, where #n starts with 1 and is incrementing 
     *  until the file with specified filename and suffix does not exist.
     *)
    fun init_enum (filepath : string) (lvl : LoggerLevel.level) =
        let
            fun exists filepath =
                (**
                 *  There is no special functions to check whether file exists in CakeMl.
                 *  Thus, we just try to open the file in reading mode, and if operation
                 *  succeeds the file should exist at the given path. 
                 *)
                (TextIO.closeIn (TextIO.openIn filepath); True) 
                handle TextIO.BadFileName => False

            fun get_non_existent_filepath (filepath : string) (index : int) =
                let
                    val filepath_with_suffix = filepath ^ "." ^ Int.toString index
                in
                    if 
                        exists filepath_with_suffix
                    then 
                        get_non_existent_filepath filepath (index + 1)
                    else 
                        filepath_with_suffix
                end

            val non_existent_filepath = 
                if 
                    exists filepath 
                then 
                    get_non_existent_filepath filepath 1
                else 
                    filepath

            val outstream = TextIO.openOut non_existent_filepath
        in
            Logger.create outstream lvl
        end

    (**
     *  Closes the outstream that a logger uses.
     *
     *  Should be called when the logger is not further needed
     *  and the outstream can be freed.
     *)
    fun close logger =
        let
            val outstream = LoggerPrivate.get_outstream logger
        in
            TextIO.closeOut outstream
        end
end
type hash_value = byte_array;

exception HashCalculationError;

structure HashFunction = 
struct
        fun size () = 32;

	fun zero () = Word8Array.array (size ()) (Word8.fromInt 0);

  fun fill value = Word8Array.array (size ()) (Word8.fromInt value);

	fun calculate_from_string message =
          let
            val result = Word8Array.array (size () + 1) (Word8.fromInt 0)
          in
            (#(hash) message result; 
            if (Word8.toInt (Word8Array.sub result 0)) < 1 then raise HashCalculationError
            else (ByteArray.suffix result 1))
          end;	

    fun calculate_from_bytes message =
    	let
    		val length = Word8Array.length message
    	in
    		calculate_from_string (Word8Array.substring message 0 length)
    	end;
end;

local
    fun exn_printer e =
        case e of
            HashCalculationError => "HashCalculationError"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
datatype keypair = Keypair byte_array byte_array;
type sign = byte_array;

exception SigningError;
exception KeypairGenarateError;

structure Keypair = 
struct
  fun priv_size () = 72;
  fun pub_size () = 104;

  fun get_priv_key (Keypair priv _) = priv;

  fun get_pub_key (Keypair _ pub) = pub;

	fun generate () = 
    let
      val keypair = Word8Array.array (1 + priv_size () + pub_size ()) (Word8.fromInt 0)
      val privkey = Word8Array.array (priv_size ()) (Word8.fromInt 0)
      val pubkey = Word8Array.array (pub_size ()) (Word8.fromInt 0)
    in
      (#(key_gen) "" keypair;
        if (Word8.toInt (Word8Array.sub keypair 0)) < 1 then raise KeypairGenarateError
        else (Word8Array.copy keypair 1 (priv_size ()) privkey 0;
              Word8Array.copy keypair (1 + priv_size ()) (pub_size ()) pubkey 0;
              Keypair privkey pubkey))
    end;

    (** 
     *  Check the validity of a public key
     *  TODO: implement validation
     *
     *  @param pubkey: ```public_key``` Public key to be validated
     *
     *  @returns: ```int```
     *
     *  0 - success
     *  1 - wrong type
     *  2 - wrong curve
     *  3 - wrong type and curve
     *  4 - wrong encode format
     *  5 - engine error
     *)
    fun validate (pubkey : byte_array) = 
        let
            val outlen = 1

            val outbuf = Word8Array.array outlen (Word8.fromInt 0)
        in
            if (Word8Array.length pubkey) <> (pub_size()) then
                4
            else (
                #(validate) (Word8Array.substring pubkey 0 (pub_size())) outbuf;
                
                Word8.toInt (Word8Array.sub outbuf 0)
            )
        end;

end;

structure Signer = 
struct
  fun sig_size () = 64;

  fun sign message (Keypair privkey pubkey) =
    let
      val msg_len = Word8Array.length message
      val inlen = (Keypair.priv_size ()) + msg_len
      val inbuf = Word8Array.array inlen (Word8.fromInt 0)
      val outbuf = Word8Array.array (sig_size () + 1) (Word8.fromInt 0)
    in
      (Word8Array.copy privkey 0 (Keypair.priv_size ()) inbuf 0;
        Word8Array.copy message 0 msg_len inbuf (Keypair.priv_size ());
        #(sign) (Word8Array.substring inbuf 0 inlen) outbuf;
        if (Word8.toInt (Word8Array.sub outbuf 0)) < 1 then raise SigningError
        else (ByteArray.suffix outbuf 1))
    end;

  fun sign_zero () = Word8Array.array (sig_size ()) (Word8.fromInt 0);
end;

structure SignatureVerifier = 
struct
  fun verify signture message pubkey =
    let
      val msg_len = Word8Array.length message
      val sig_len = Word8Array.length signture
      val pub_len = Word8Array.length pubkey 
      val inlen = pub_len + sig_len + msg_len
      val inbuf = Word8Array.array inlen (Word8.fromInt 0)
      val outbuf = Word8Array.array 1 (Word8.fromInt 0)
    in
      (Word8Array.copy pubkey 0 pub_len inbuf 0;
        Word8Array.copy signture 0 sig_len inbuf pub_len;
        Word8Array.copy message 0 msg_len inbuf (pub_len + sig_len);
        #(verify) (Word8Array.substring inbuf 0 inlen) outbuf; 
        (Word8.toInt (Word8Array.sub outbuf 0)) > 0)
    end;
end;

local
    fun exn_printer e =
        case e of
            SigningError => "SigningError"
          | KeypairGenarateError => "KeypairGenarateError"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
datatype noise_keys = NoiseKeys byte_array byte_array;

datatype handshake_data = HandShakeData keypair int byte_array hash_value;

structure Noise =
struct

    (* MOCK. UPDATE WHEN CRYPTO ADDED!!! *)
    fun key_size () = 1

    fun ct_size () = 1

    fun zero () = Word8Array.array (key_size()) (Word8.fromInt 0);

    fun send_key (NoiseKeys sk rk) = sk;
    
    fun recv_key (NoiseKeys sk rk) = rk;

    (* returns option *)
    fun encrypt send_key pt = Word8Array.array 1 (Word8.fromInt 0);

    (* returns option *)
    fun decrypt recv_key ct = Word8Array.array 1 (Word8.fromInt 0);

    fun vko k1 k2 = Word8Array.array 1 (Word8.fromInt 0);

    fun hkdf ks key salt = Word8Array.array 1 (Word8.fromInt 0);

    (* fun init own_sk own_pk own_id node_pk node_id = 
        (Word8Array.array 1 (Word8.fromInt 0),
         HandShakeData (Keypair.generate()) 2 (Word8Array.array 1 (Word8.fromInt 0)) (HashFunction.zero())) *)

    (* fun process own_sk own_pk own_id node_pk node_id recv_msg = (True, NoiseKeys (zero()) (zero()), Word8Array.array 1 (Word8.fromInt 0)) *)

    (* fun finish own_sk own_pk own_id node_pk node_id (HandShakeData eph_k nonce ks h) recv_msg = Some (NoiseKeys (zero()) (zero())) *)

    (* fun serialize (NoiseKeys send_key recv_key) =
        ByteArray.from_list (
            ByteArray.to_list(Serialization.encode_byte_array send_key) @
            ByteArray.to_list(Serialization.encode_byte_array recv_key)
        ) *)

    (* fun deserialize serial =
        let
            val (send_key, send_key_len) = Serialization.decode_byte_array (key_size()) serial
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) send_key_len)

            val (recv_key, recv_key_len) = Serialization.decode_byte_array (key_size()) serial
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) recv_key_len)
        in
            (NoiseKeys send_key recv_key, send_key_len + recv_key_len)
        end; *)

end;

type public_key = byte_array;

(**
 *  Raises when invalid public key is provided or produced
 *
 *  @param pubkey: ```byte_array``` invalid byte string tried to be used as a public key
 *)
exception InvalidPublicKey byte_array;

structure PublicKey =
struct
    
    (** 
     *  Check the validity of a public key
     *  TODO: implement validation
     *
     *  @param pubkey: ```public_key``` Public key to be validated
     *
     *  @returns: ```bool```
     *)
    fun validate (pubkey : byte_array) = 
        Keypair.validate pubkey

    (**
     *  Validates provided key and initializes a new public key.
     *
     *  @param pubkey: ```byte_array``` The bytearray public key should be initialized from
     *
     *  @returns: ```public_key```
     *)
    fun init (pubkey : byte_array) = 
        if 
            validate pubkey = 0
        then 
            pubkey 
        else 
            raise InvalidPublicKey pubkey

    (**
     *  Initializes 
     *)
    fun init_from_private_key (privkey : byte_array) = 
        let
          (* TODO: implement transformation from the private key to public *)
          val pubkey = Word8Array.array 33 (Word8.fromInt 0)
        in
          if 
            validate pubkey = 0
          then 
            pubkey
          else 
            raise InvalidPublicKey pubkey
        end;

    val compare = ByteArray.compare
end;


(**
 *  The type that contains configurable information
 *
 *  @param acceptor_address `sockaddr_in`: An IPv4 address
 *      and a port number the acceptor socket should be binded to.
 *  @param backlog_size `int`: Maximum number of connections 
 *      in the awaitinig queue of the accepting socket.
 *  @param new_connection_timeout `int`: A period for the new
 *      connection timer.
 *  @param transaction_broadcast_timeout `int`: A period for the
 *      transaction broadcast timer.
 *  @param read_buffer_size `int`: A size of the read buffer
 *      readable fd_infos should have.
 *  @param read_buffer_lwm `int`: A lower watermark read buffer
 *      used in readable fd_infos should equal to.
 *  @param write_buffer_size `int`: A size of the write buffer
 *      writable fd_infos should have.
 *  @param write_buffer_lwm `int`: A lower watermark write buffer
 *      used in writable fd_infos should equal to.
 *)
datatype config = Config sockaddr_in int int int int int int int 

exception InvalidConfigInput

structure Config =
struct
    fun create acceptor_address backlog_size new_connection_timeout transaction_broadcast_timeout 
                read_buffer_size read_buffer_lwm write_buffer_size write_buffer_lwm = 
        let
            fun verify () =
                if 
                    backlog_size <= 0 orelse
                    new_connection_timeout <= 0 orelse
                    transaction_broadcast_timeout <= 0 orelse
                    read_buffer_size <= 0 orelse
                    read_buffer_size < read_buffer_lwm orelse 
                    write_buffer_size < 0 orelse
                    write_buffer_size < write_buffer_lwm
                then raise InvalidConfigInput
                else ()
        in
            verify ();
            Config acceptor_address backlog_size new_connection_timeout transaction_broadcast_timeout
                read_buffer_size read_buffer_lwm write_buffer_size write_buffer_lwm
        end

    (* fun to_string prefix (Config node_id block_size) =
        (prefix ^ "Config" ^ "\n")
            ^
        (prefix ^ "  " ^ "Node id: " ^ Hex.bytes_to_hex node_id ^ "\n")
            ^
        (prefix ^ "  " ^ "Block size: " ^ Int.toString block_size) *)

    (* fun print_config config = print (to_string "" config ^ "\n") *)

    fun get_acceptor_address (Config acceptor_address _ _ _ _ _ _ _) =
        acceptor_address

    fun get_backlog_size (Config _ backlog_size _ _ _ _ _ _) = 
        backlog_size

    fun get_new_connection_timeout (Config _ _ new_connection_timeout _ _ _ _ _) =
        new_connection_timeout
    
    fun get_transaction_broadcast_timeout (Config _ _ _ transaction_broadcast_timeout _ _ _ _) = 
        transaction_broadcast_timeout

    fun get_read_buffer_size (Config _ _ _ _ read_buffer_size _ _ _) = 
        read_buffer_size

    fun get_read_buffer_lwm (Config _ _ _ _ _ read_buffer_lwm _ _) = 
        read_buffer_lwm

    fun get_write_buffer_size (Config _ _ _ _ _ _ write_buffer_size _) = 
        write_buffer_size

    fun get_write_buffer_lwm (Config _ _ _ _ _ _ _ write_buffer_lwm) = 
        write_buffer_lwm
end

local
    fun exn_printer e =
        case e of
            InvalidConfigInput => "InvalidConfigInput"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end

(**
 *  The type representing Version of the block.
*)  
type version = int;

(**
*  The type representing complete Information about the block.
*  @params round, id, executedStateId, version, timestampUsecs
*  @param round shows block of which round it is
*  @param id unique id of the block
*  @param executedStateId hash of the state after the block approval
*  @param version vesion of the ledger
*  @param timestampUsecs timestamp in seconds of block creation
*)   
datatype block_info = BlockInfo int hash_value hash_value  version  int;

structure BlockInfo =
struct    

    fun init () = BlockInfo 0 (HashFunction.zero()) (HashFunction.zero()) 0 0;

    fun empty () = BlockInfo 0 (HashFunction.zero()) (HashFunction.zero()) 0 0;

    fun genesis () = BlockInfo 0 (HashFunction.zero()) (HashFunction.zero()) 0 0;

    fun create (round, id, executed_state_id, version, timestamp_usecs) = 
        BlockInfo round id executed_state_id version timestamp_usecs;
    
    fun to_string prefix (BlockInfo round id executed_state_id version timestamp) =
        (prefix ^ "BlockInfo" ^ "\n")
            ^
        (prefix ^ "  " ^ "Round: " ^ Int.toString round ^ "\n")
            ^
        (prefix ^ "  " ^ "ID: " ^ Hex.bytes_to_hex id ^ "\n")
            ^
        (prefix ^ "  " ^ "Executed state ID: " ^ Hex.bytes_to_hex executed_state_id ^ "\n")
            ^
        (prefix ^ "  " ^ "Version: " ^ Int.toString version ^ "\n")
            ^
        (prefix ^ "  " ^ "Timestamp: " ^ Int.toString timestamp)

    fun print block_info = Formatter.lib_print (to_string "" block_info ^ "\n")

    fun get_round (BlockInfo round _ _ _ _) = round;
    fun get_id    (BlockInfo _ id _ _ _) = id;
    fun get_executed_state_id (BlockInfo _ _ executed_state_id _ _) = executed_state_id;
    fun get_version (BlockInfo _ _ _ version _) = version;
    fun get_timestamp_usecs (BlockInfo _ _ _ _ timestamp_usecs) = timestamp_usecs;

    fun set_round (BlockInfo _ id executed_state_id version timestamp_usecs) round = 
        BlockInfo round id executed_state_id version timestamp_usecs;
    fun set_id (BlockInfo round _ executed_state_id version timestamp_usecs) id = 
        BlockInfo round id executed_state_id version timestamp_usecs;
    fun set_executed_state_id (BlockInfo round id _ version timestamp_usecs) executed_state_id = 
        BlockInfo round id executed_state_id version timestamp_usecs;
    fun set_version (BlockInfo round id executed_state_id _ timestamp_usecs) version = 
        BlockInfo round id executed_state_id version timestamp_usecs;
    fun set_timestamp_usecs (BlockInfo round id executed_state_id version _) timestamp_usecs = 
        BlockInfo round id executed_state_id version timestamp_usecs;


    fun serialize (BlockInfo round id executed_state_id version timestamp_usecs) =
        ByteArray.from_list(
            (ByteArray.to_list(Serialization.encode_int_flex round)) @  
            (ByteArray.to_list(id)) @
            (ByteArray.to_list(executed_state_id)) @
            (ByteArray.to_list(Serialization.encode_int_flex version)) @
            (ByteArray.to_list(Serialization.encode_int_flex timestamp_usecs))
        );
    
(*TODO: rewrite 32 as some constant to standardize hash length*)
    fun deserialize byte_array =
        let
            val (round, int_len1) = Serialization.decode_int_flex byte_array
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) int_len1)
            val id = ByteArray.from_list(List.take (ByteArray.to_list upd_lst) (HashFunction.size()) )        
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) (HashFunction.size()) ) 
            val executed_state_id = ByteArray.from_list(List.take (ByteArray.to_list upd_lst) (HashFunction.size()) )          
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) (HashFunction.size()) ) 
            val (version, int_len2) = Serialization.decode_int_flex upd_lst
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) int_len2)   
            val (timestamp_usecs, int_len3) = Serialization.decode_int_flex upd_lst    
        in
            (BlockInfo round id executed_state_id version timestamp_usecs, 
                (int_len1 + int_len2 + int_len3 + (HashFunction.size()) + (HashFunction.size()) ))
        end; 
        
end;


(**
     *  The type representing complete Information about the ledger.
     *  @params commit_info, consensus_data_hash
     *  @param commit_info informaton about commit
     *  @param consensus_data_hash it is hash of Consensus Data, 
     *         imported from ../crypto/HashFunction.cml
     *)    
datatype ledger_info = LedgerInfo block_info hash_value;


type signatures_mapping = (guid, sign) map;
    (**
     *  The type representing complete Information about the ledger and signatures of it.
     *  @params ledgerInfo, signatures
     *  @param ledgerInfo informaton about ledger
     *         imported from ./LedgerInfo.cml
     *  @param signatures it is Mapping of users signatures 
     *         GUID and Signature imported from ../crypto/HashFunction.cml
     *)  
datatype signed_ledger_info = SignedLedgerInfo ledger_info signatures_mapping;


structure LedgerInfo =
struct    
    fun init() = LedgerInfo (BlockInfo.init()) (HashFunction.zero());

    fun genesis () = LedgerInfo (BlockInfo.genesis ()) (HashFunction.zero());

    fun create(commit_info, consensus_data_hash) = LedgerInfo commit_info consensus_data_hash;

    fun to_string prefix (LedgerInfo commit_info consensus_data_hash) =
        (prefix ^ "LedgerInfo" ^ "\n")
            ^
        (prefix ^ "  " ^ "Commit info:" ^ "\n")
            ^
        (BlockInfo.to_string (prefix ^ "  " ^ "  ") commit_info ^ "\n")
            ^
        (prefix ^ "  " ^ "Consensus data hash: " ^ Hex.bytes_to_hex consensus_data_hash)
    
    fun print ledger_info = Formatter.lib_print (to_string "" ledger_info ^ "\n")


    fun get_commit_info (LedgerInfo commit_info _) = commit_info;
    fun get_consensus_data_hash (LedgerInfo _ consensus_data_hash) = consensus_data_hash;

    fun set_commit_info (LedgerInfo _ consensus_data_hash) commit_info = 
        LedgerInfo commit_info consensus_data_hash;
    fun set_consensus_data_hash (LedgerInfo commit_info _) consensus_data_hash = 
        LedgerInfo commit_info consensus_data_hash;

    fun serialize (LedgerInfo commit_info consensus_data_hash) =
        ByteArray.from_list((ByteArray.to_list(BlockInfo.serialize commit_info)) @ (ByteArray.to_list(consensus_data_hash)))

    fun deserialize (byte_array) = 
        let 
            val (commit_info, len_commit_info) = BlockInfo.deserialize(byte_array)
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) len_commit_info)
            val consensus_data_hash = ByteArray.from_list(List.take (ByteArray.to_list upd_lst) 32)
        in 
            ( (LedgerInfo commit_info consensus_data_hash), (len_commit_info + 32))
        end
end;


structure SignedLedgerInfo =
struct    
    fun init() = SignedLedgerInfo (LedgerInfo.init()) (Map.empty ByteArray.compare);

    fun genesis () = SignedLedgerInfo (LedgerInfo.genesis ()) (Map.empty ByteArray.compare);

    fun create(ledger_info, signatures) = SignedLedgerInfo ledger_info signatures;

    fun to_string prefix (SignedLedgerInfo ledger_info signatures) =
        (prefix ^ "SignedLedgerInfo" ^ "\n")
            ^
        (prefix ^ "  " ^ "Ledger info:" ^ "\n")
            ^
        (LedgerInfo.to_string (prefix ^ "  " ^ "  ") ledger_info ^ "\n")
            ^
        (prefix ^ "  " ^ "Signatures:" ^ "\n")
            ^
        (Formatter.map_to_string (prefix ^ "  " ^ "  ") Hex.bytes_to_hex Hex.bytes_to_hex signatures)

    fun print_signed_ledger_info signed_ledger_info = print (to_string "" signed_ledger_info)


    fun get_ledger_info (SignedLedgerInfo ledger_info _) = ledger_info;
    fun get_signatures (SignedLedgerInfo _ signatures) = signatures;
    fun set_ledger_info (SignedLedgerInfo _ signatures) ledger_info = 
        SignedLedgerInfo ledger_info signatures;
    fun set_signatures (SignedLedgerInfo ledger_info _) signatures = 
        SignedLedgerInfo ledger_info signatures;

    fun get_commit_info (SignedLedgerInfo ledger_info _) = LedgerInfo.get_commit_info ledger_info;

    fun get_commit_id (SignedLedgerInfo ledger_info _) = BlockInfo.get_id (LedgerInfo.get_commit_info ledger_info);

    fun serialize (SignedLedgerInfo ledger_info signatures) =
        let
            val map_list = Map.toAscList(signatures)
            val encoded_signatures = Serialization.encode_list ( Serialization.encode_tuple2 (Serialization.encode_byte_array) (Serialization.encode_byte_array) ) map_list
        in
            ByteArray.from_list ((ByteArray.to_list(LedgerInfo.serialize(ledger_info))) @ (ByteArray.to_list(encoded_signatures)))
        end
            

    fun deserialize (byte_array) = 
        let 
            val (ledger_info, len_ledger_info) = LedgerInfo.deserialize(byte_array)
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) len_ledger_info)
            val (signatures, len_signatures) = 
                            Serialization.decode_list 
                                ( Serialization.decode_tuple2 (Serialization.decode_byte_array 
                                                                (Guid.size()) ) 
                                                             (Serialization.decode_byte_array 
                                                                (Signer.sig_size()) )
                                )
                             upd_lst
        in 
            ( (SignedLedgerInfo ledger_info (Map.fromList (ByteArray.compare) signatures) ), (len_ledger_info + len_signatures))
        end 
 
end;
    (**
     *  This type represents data about Vote.
     *  @params proposed, parent
     *  @param proposed is a new Block which is being proposed
     *  @param parent is latest approved Block
     *) 
datatype vote_data = VoteData block_info  block_info;

structure VoteData =
struct    
    fun init () = VoteData (BlockInfo.init()) (BlockInfo.init());

    fun genesis () = VoteData (BlockInfo.genesis ()) (BlockInfo.genesis ());

    fun create (proposed, parent) = VoteData proposed parent;

    fun to_string prefix (VoteData proposed parent) =
        (prefix ^ "VoteData" ^ "\n")
            ^
        (prefix ^ "  " ^ "Proposed:" ^ "\n")
            ^
        (BlockInfo.to_string (prefix ^ "  " ^ "  ") proposed ^ "\n")
            ^
        (prefix ^ "  " ^ "Parent:" ^ "\n")
            ^
        (BlockInfo.to_string (prefix ^ "  " ^ "  ") parent)

    fun print vote_data = Formatter.lib_print (to_string "" vote_data ^ "\n")

    fun get_proposed_round(VoteData (BlockInfo round _ _ _ _ ) anything) =
        round;
    fun get_proposed_hash(VoteData (BlockInfo _ proposed_hash _ _ _ ) anything) =
        proposed_hash;
    fun get_proposed_version(VoteData (BlockInfo _ _ _ version _ ) _) =
        version;
    fun get_proposed_state_id(VoteData (BlockInfo _ _ state_id _ _ ) _) =
        state_id;

    fun get_parent_round(VoteData anything (BlockInfo round _ _ _ _ ) ) =
        round;
    fun get_parent_hash(VoteData anything (BlockInfo _  parent_hash _ _ _ ) ) =
        parent_hash;

    fun serialize (VoteData proposed parent) =
        ByteArray.from_list(
        ByteArray.to_list(BlockInfo.serialize(proposed)) @
        ByteArray.to_list(BlockInfo.serialize(parent)) )

    fun deserialize (byte_array) =
        let 
            val (proposed, len_proposed) = BlockInfo.deserialize(byte_array)
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) len_proposed)
            val (parent, len_parent) = BlockInfo.deserialize(upd_lst)
        in 
            ( (VoteData proposed parent), (len_parent + len_proposed))
        end

    fun get_proposed (VoteData proposed _) = proposed

    fun get_parent (VoteData _ parent) = parent


end;

(**
    * Type represents data required to vote for proposed block
    * 
    * @params vote_data, author, ledger_info, sign, timeout_sign
    * @param vote_data: ```vote_data``` 
    * @param author: ```guid```
    * @param ledger_info: ```ledger_info```
    * @param sign: ```sign```
    * @param timeout_sign: ```sign option```
*)
datatype vote = Vote vote_data guid ledger_info sign (sign option);

structure Vote =
struct

    fun init () = Vote (VoteData.init()) (Guid.zero()) (LedgerInfo.init()) (Signer.sign_zero()) None

    fun create (vote_data, author, ledger_info, sign, timeout_sign) =
        Vote vote_data author ledger_info sign timeout_sign

    fun to_string prefix (Vote vote_data author ledger_info sign timeout_sign) =
        (prefix ^ "Vote" ^ "\n")
            ^
        (prefix ^ "  " ^ "Vote data:" ^ "\n")
            ^
        (VoteData.to_string (prefix ^ "  " ^ "  ") vote_data ^ "\n")
            ^
        (prefix ^ "  " ^ "Author: " ^ Hex.bytes_to_hex author ^ "\n")
            ^
        (prefix ^ "  " ^ "Ledger info:" ^ "\n")
            ^
        (LedgerInfo.to_string (prefix ^ "  " ^ "  ") ledger_info ^ "\n")
            ^
        (prefix ^ "  " ^ "Signature: " ^ Hex.bytes_to_hex sign ^ "\n")
            ^
        (prefix ^ "  " ^ "Timeout signature: " ^ Formatter.option_to_string "" Hex.bytes_to_hex timeout_sign)

    fun print vote = Formatter.lib_print (to_string "" vote ^ "\n")

    (***************************************************************************)

    fun get_vote_data (Vote vote_data author ledger_info sign timeout_sign) = 
        vote_data

    fun get_author (Vote vote_data author ledger_info sign timeout_sign) = 
        author

    fun get_ledger_info (Vote vote_data author ledger_info sign timeout_sign) = 
        ledger_info

    fun get_signature (Vote vote_data author ledger_info sign timeout_sign) = 
        sign

    fun get_timeout_signature (Vote vote_data author ledger_info sign timeout_sign) = 
        timeout_sign

    (***************************************************************************)

    fun set_vote_data (Vote _ author ledger_info sign timeout_sign) vote_data =
        Vote vote_data author ledger_info sign timeout_sign

    fun set_author (Vote vote_data _ ledger_info sign timeout_sign) author =
        Vote vote_data author ledger_info sign timeout_sign

    fun set_ledger_info (Vote vote_data author _ sign timeout_sign) ledger_info =
        Vote vote_data author ledger_info sign timeout_sign

    fun set_signature (Vote vote_data author ledger_info _ timeout_sign) sign =
        Vote vote_data author ledger_info sign timeout_sign

    fun set_timeout_signature (Vote vote_data author ledger_info sign _) timeout_sign =
        Vote vote_data author ledger_info sign timeout_sign

    (***************************************************************************)

    fun serialize (Vote vote_data guid ledger_info sign timeout_signature) =
      ByteArray.from_list(
        ByteArray.to_list(VoteData.serialize(vote_data)) @
        ByteArray.to_list(guid) @
        ByteArray.to_list(LedgerInfo.serialize(ledger_info)) @
        ByteArray.to_list(sign) @
        ByteArray.to_list(Serialization.encode_option (Serialization.encode_byte_array) timeout_signature)
      );

    fun deserialize vote_bytes =
      let
        val (vote_data, vote_data_len) = VoteData.deserialize vote_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list vote_bytes) vote_data_len)
        val (guid, guid_len) = Serialization.decode_byte_array (Guid.size()) 
                                                             updated_bytes        
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) guid_len) 
        val (ledger_info, ledger_info_len) = LedgerInfo.deserialize updated_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) ledger_info_len)
        val (sign, sign_len) =  Serialization.decode_byte_array (Signer.sig_size()) updated_bytes     
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) sign_len) 
        val (timeout_signature, timeout_signature_len) = Serialization.decode_option (Serialization.decode_byte_array (Signer.sig_size())) updated_bytes  
      in
        (Vote vote_data guid ledger_info sign timeout_signature, 
           (vote_data_len + guid_len + ledger_info_len + sign_len + timeout_signature_len))
      end; 

end;


(**
     *  The type representing Timeout Certificate.
     *  @params round, signs
     *  @param round: ```uint64```
     *  @param signs: ```(guid, sign) map```
*)
datatype timeout_cert = TimeoutCert int ((guid, sign) map);
(**
     *  The type representing Quorum Certificate.
     *  @params voteData, signedLedgerInfo
     *  @param voteData informaton about vote
     *         imported from ./VoteData.sml
     *  @param signedLedgerInfo it signed information about ledger
     *         imported from ./LedgerInfo.sml
*)    
datatype quorum_cert = QuorumCert vote_data signed_ledger_info;

structure QuorumCert = 
struct

    fun init() = QuorumCert (VoteData.init()) (SignedLedgerInfo.init());

    fun genesis () = QuorumCert (VoteData.genesis ()) (SignedLedgerInfo.genesis ());

    fun create(vote_data, signed_ledger_info) = QuorumCert vote_data signed_ledger_info;

    fun get_vote_data (QuorumCert vote_data _) = vote_data;
    fun get_signed_ledger_info (QuorumCert _ signed_ledger_info) = signed_ledger_info;

    fun get_commit_info (QuorumCert _ signed_ledger_info) =
        let
            val ledger_info = SignedLedgerInfo.get_ledger_info signed_ledger_info
        in
            LedgerInfo.get_commit_info ledger_info
        end
        
    fun set_vote_data (QuorumCert _ signed_ledger_info) vote_data = 
        QuorumCert vote_data signed_ledger_info;
    fun set_signed_ledger_info (QuorumCert vote_data signed_ledger_info) signed_ledger_info = 
        QuorumCert vote_data signed_ledger_info;

    fun to_string prefix (QuorumCert vote_data signed_ledger_info) =
        (prefix ^ "QuorumCert" ^ "\n")
            ^
        (prefix ^ "  " ^ "Vote data:" ^ "\n")
            ^
        (VoteData.to_string (prefix ^ "  " ^ "  ") vote_data ^ "\n")
            ^
        (prefix ^ "  " ^ "Signed ledger info:" ^ "\n")
            ^
        (SignedLedgerInfo.to_string (prefix ^ "  " ^ "  ") signed_ledger_info)

    fun print quorum_cert = Formatter.lib_print (to_string "" quorum_cert ^ "\n")

    fun get_proposed_round (QuorumCert vote_data _) = 
        VoteData.get_proposed_round(vote_data);

    fun get_parent_round (QuorumCert vote_data _) = 
        VoteData.get_parent_round(vote_data);

    fun get_proposed_hash (QuorumCert vote_data _) = 
        VoteData.get_proposed_hash(vote_data);

    fun get_proposed_version (QuorumCert vote_data _) =
        VoteData.get_proposed_version(vote_data);

    fun get_proposed_state_id (QuorumCert vote_data _) =
        VoteData.get_proposed_state_id(vote_data);

    fun get_parent_hash (QuorumCert vote_data _) = 
        VoteData.get_parent_hash(vote_data);

    fun get_signatures (QuorumCert _ signed_ledger_info) =
        SignedLedgerInfo.get_signatures signed_ledger_info

    fun serialize (QuorumCert vote_data signed_ledger_info) = 
        ByteArray.from_list(
            (ByteArray.to_list(VoteData.serialize(vote_data))) @
            (ByteArray.to_list(SignedLedgerInfo.serialize(signed_ledger_info))) 
            )
    
    fun deserialize byte_array = 
        let
            val (vote_data, vote_data_len) = VoteData.deserialize(byte_array)
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) vote_data_len)
            val (signed_ledger_info, signed_ledger_info_len) = 
                SignedLedgerInfo.deserialize(upd_lst)
        in
            ((QuorumCert vote_data signed_ledger_info), (vote_data_len+signed_ledger_info_len))
        end
    
end;

structure TimeoutCert = 
struct
    fun init() = TimeoutCert 0 (Map.empty ByteArray.compare)

    fun create (round, signs) = TimeoutCert round signs

    fun to_string prefix (TimeoutCert round signs) =
        (prefix ^ "TimeoutCert" ^ "\n")
            ^
        (prefix ^ "  " ^ "Round: " ^ Int.toString round ^ "\n")
            ^
        (prefix ^ "  " ^ "Signatures: \n")
            ^
        (Formatter.map_to_string (prefix ^ "  " ^ "  ") Hex.bytes_to_hex Hex.bytes_to_hex signs)

    fun print_timeout_cert tc = print (to_string "" tc)

	fun get_round (TimeoutCert round _) = round

    fun get_signatures (TimeoutCert _ signs) = signs

    fun serialize (TimeoutCert round signs) =
    	let 
    		val signs_converted_map = Map.toAscList signs
    	in
	    	ByteArray.from_list(
	    		(* Warning! serialize as IntFlex *)
	            ByteArray.to_list(Serialization.encode_int_flex round) @
	            ByteArray.to_list(Serialization.encode_list 
	            	                (Serialization.encode_tuple2 
	            	                	(Serialization.encode_byte_array)
	            	                	(Serialization.encode_byte_array))
	            	                signs_converted_map)
	    	)
	    end

	fun deserialize timeout_cert_bytes = 
		let
			val (round, round_len) = Serialization.decode_int_flex timeout_cert_bytes
			val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list timeout_cert_bytes) round_len)
			val (signs_list, signs_len) = Serialization.decode_list 
				                            (Serialization.decode_tuple2
				                            	(Serialization.decode_byte_array (Guid.size()))
				                            	(Serialization.decode_byte_array (Signer.sig_size())))
				                            updated_bytes
			val signs = Map.fromList (ByteArray.compare) signs_list
		in
			(TimeoutCert round signs, round_len + signs_len)
		end
end;


(**
     *  The type representing synchronization information.
     *  @params highestCommitCert, highestQuorumCert, highestTimeoutCert, highestRound
	 *  @param highestCommitCert 
     *         imported from ./QuorumCert.sml
     *  @param highestQuorumCert 
     *         imported from ./QuorumCert.sml
	 *  @param highestTimeoutCert option 
     *         imported from ./QuorumCert.sml
*)
datatype sync_info = SyncInfo quorum_cert quorum_cert (timeout_cert option);

structure SyncInfo = 
struct
	fun init() = SyncInfo (QuorumCert.init()) (QuorumCert.init()) None
    fun create(highest_cc, highest_qc, highest_tc) = SyncInfo highest_cc highest_qc highest_tc

	fun to_string prefix (SyncInfo highest_cc highest_qc highest_tc) =
		(prefix ^ "SyncInfo" ^ "\n")
			^
		(prefix ^ "  " ^ "Highest commit cert:" ^ "\n")
			^
		(QuorumCert.to_string (prefix ^ "  " ^ "  ") highest_cc ^ "\n")
			^
		(prefix ^ "  " ^ "Highest quorum cert:" ^ "\n")
			^
		(QuorumCert.to_string (prefix ^ "  " ^ "  ") highest_qc ^ "\n")
			^
		(prefix ^ "  " ^ "Highest timeout cert:" ^ "\n")
			^
		(Formatter.structure_option_to_string (prefix ^ "  " ^ "  ") TimeoutCert.to_string (prefix ^ "  " ^ "  " ^ "  ") highest_tc)
    
    fun print sync_info = Formatter.lib_print (to_string "" sync_info ^ "\n")

	fun get_highest_commit_cert (SyncInfo highest_cc _ _) = highest_cc

	fun get_highest_quorum_cert (SyncInfo _ highest_qc _) = highest_qc

	fun get_timeout_cert (SyncInfo _ _ highest_tc) = highest_tc

	fun get_highest_round (SyncInfo _ highest_qc highest_tc) =
		Comparison.max
			(QuorumCert.get_proposed_round highest_qc)
			(Option.getOpt 
				(Option.map (fn tc => TimeoutCert.get_round tc) highest_tc)
				(QuorumCert.get_proposed_round highest_qc));

	fun set_highest_commit_cert (SyncInfo _ highest_qc highest_tc) highest_cc = 
		SyncInfo highest_cc highest_qc highest_tc

	fun set_highest_quorum_cert (SyncInfo highest_cc _ highest_tc) highest_qc = 
		SyncInfo highest_cc highest_qc highest_tc

	fun set_timeout_cert (SyncInfo highest_cc highest_qc _) highest_tc = 
		SyncInfo highest_cc highest_qc highest_tc

	fun serialize (SyncInfo highest_cc highest_qc highest_tc) =
		ByteArray.from_list(
		    ByteArray.to_list(QuorumCert.serialize highest_cc) @
		    ByteArray.to_list(QuorumCert.serialize highest_qc) @
		    ByteArray.to_list(Serialization.encode_option (TimeoutCert.serialize) highest_tc)
		)

	fun deserialize (sync_info_bytes) =
		let
			val (highest_cc, highest_cc_len) = QuorumCert.deserialize sync_info_bytes
			val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list sync_info_bytes) highest_cc_len)
			val (highest_qc, highest_qc_len) = QuorumCert.deserialize updated_bytes
			val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) highest_qc_len)
			val (highest_tc, highest_tc_len) = Serialization.decode_option (TimeoutCert.deserialize) updated_bytes
		in
			(SyncInfo highest_cc highest_qc highest_tc, highest_cc_len + highest_qc_len + highest_tc_len)
		end
end;
(**
 *  Type that represents an account in the ledger
 *
 *  @param account_id: ```guid```
 *  @param public_keys: ```public_key set```
 *  @param account_type: ```uint8```
 *  @param nonce: ```uint32```
 *  @param is_confirmed: ```bool```
 *  @param code: ```byte_array option```
 *  @param storage: ```(string * byte_array) list```
 *)
datatype account = Account guid (public_key set) int int bool (byte_array option) ((string * byte_array) list);

structure Account =
struct
    fun contract () = 0;
    fun user () = 1;
    fun master () = 2;

    fun state_key () = "state";

    fun init () = Account (Guid.zero()) (Set.empty ByteArray.compare) 0 0 False None []

    fun create (account_id, public_keys, account_type, nonce, is_confirmed, code, storage) = 
        Account account_id public_keys account_type nonce is_confirmed code storage

    fun to_string prefix (Account account_id public_keys account_type nonce is_confirmed code storage) =
        (prefix ^ "Account" ^ "\n")
            ^
        (prefix ^ "  " ^ "Account id: " ^ Hex.bytes_to_hex account_id ^ "\n")
            ^
        (prefix ^ "  " ^ "Public keys:" ^ "\n")
            ^
        (Formatter.set_to_string (prefix ^ "  " ^ "  ") Hex.bytes_to_hex public_keys ^ "\n")
            ^
        (prefix ^ "  " ^ "Type: " ^ Int.toString account_type ^ "\n")
            ^
        (prefix ^ "  " ^ "Nonce: " ^ Int.toString nonce ^ "\n")
            ^
        (prefix ^ "  " ^ "Is confirmed: " ^ Bool.toString is_confirmed ^ "\n")
            ^
        (prefix ^ "  " ^ "Code: " ^ Formatter.option_to_string "" Hex.bytes_to_hex code ^ "\n")
            ^
        (prefix ^ "  " ^ "Storage:" ^ "\n")
            ^
        (Formatter.alist_to_string (prefix ^ "  " ^ "  ") id Hex.bytes_to_hex storage)

    fun print account = Formatter.lib_print (to_string "" account ^ "\n")

    fun create_user account_id public_keys =
      create (account_id, public_keys, (user ()), 0, True, None, []);
      
    fun create_contract account_id public_keys =
      create (account_id, public_keys, (contract ()), 0, True, None, []);

    fun create_master account_id public_keys =
      create (account_id, public_keys, (master ()), 0, True, None, []);

    fun get_account_id (Account account_id _ _ _ _ _ _) = account_id
    fun get_public_keys (Account _ public_keys _ _ _ _ _) = public_keys
    fun get_type (Account _ _ account_type _ _ _ _) = account_type
    fun get_nonce (Account _ _ _  nonce _ _ _) = nonce
    fun get_is_confirmed (Account _ _ _ _ is_confirmed _ _) = is_confirmed
    fun get_code (Account _ _ _ _ _ code _) = code
    fun get_storage (Account _ _ _ _ _ _ storage) = storage

    fun is_contract (Account _ _ account_type _ _ _ _) = (account_type = 0);

    fun set_account_id (Account _ public_keys account_type nonce is_confirmed code storage) account_id = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun set_public_keys (Account account_id _ account_type nonce is_confirmed code storage) public_keys = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun set_account_type (Account account_id public_keys _ nonce is_confirmed code storage) account_type = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun set_nonce (Account account_id public_keys account_type _ is_confirmed code storage) nonce = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun set_is_confirmed (Account account_id public_keys account_type nonce _ code storage) is_confirmed = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun set_code (Account account_id public_keys account_type nonce is_confirmed _ storage) code = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun set_storage (Account account_id public_keys account_type nonce is_confirmed code _) storage = 
      Account account_id public_keys account_type nonce is_confirmed code storage;

    fun add_public_keys account public_keys_to_add =
      set_public_keys account (Set.add_list (get_public_keys account) public_keys_to_add);
      
    fun remove_public_keys account public_keys_to_remove =
      let
        val old_keys = get_public_keys account
        val new_keys = Set.subtract_list old_keys public_keys_to_remove
      in
        set_public_keys account new_keys
      end;

    fun inc_nonce account = set_nonce account ((get_nonce account) + 1);

    fun update_storage account updates =
      let
        val mapping = Map.fromList (String.compare) updates
        val storage_list = List.map 
                              (fn (key, value) => 
                                  case (Map.lookup mapping key) of
                                    Some new_value => (key, new_value)
                                    | None => (key, value)
                              )
                              (get_storage account)
        val old_mapping = Map.fromList (String.compare) storage_list
        val new_updates = List.filter (fn (key, value) => Option.isNone (Map.lookup old_mapping key)) updates
      in
        set_storage account (storage_list @ new_updates)
      end;

    fun compare a b = 
      case Guid.compare (get_account_id a) (get_account_id b) of
        Less => Less
      | Greater => Greater
      | Equal => (
          case List.compare PublicKey.compare (Set.to_list (get_public_keys a)) (Set.to_list (get_public_keys b)) of
            Less => Less
          | Greater => Greater
          | Equal => (
              case Int.compare (get_type a) (get_type b) of
                Less => Less
              | Greater => Greater
              | Equal => (
                  case Int.compare (get_nonce a) (get_nonce b) of
                    Less => Less
                  | Greater => Greater
                  | Equal => (
                      case Bool.compare (get_is_confirmed a) (get_is_confirmed b) of
                        Less => Less
                      | Greater => Greater
                      | Equal => (
                          case Option.compare ByteArray.compare (get_code a) (get_code b) of
                            Less => Less
                          | Greater => Greater
                          | Equal => (
                              List.compare 
                                (fn (x1, y1) => fn (x2, y2) => 
                                    case String.compare x1 x2 of 
                                        Less => Less 
                                      | Greater => Greater 
                                      | Equal => ByteArray.compare y1 y2)
                                (get_storage a) (get_storage b)
                          )
                      )
                  )
              )
            )
        )

    fun equal a1 a2 =
      (compare a1 a2) = Equal;

    fun serialize (Account account_id public_keys account_type nonce is_confirmed code storage) =
      ByteArray.from_list(
        ByteArray.to_list(account_id) @
        ByteArray.to_list(Serialization.encode_set (Serialization.encode_byte_array) public_keys) @ 
        ByteArray.to_list(Serialization.encode_int8 account_type) @
        ByteArray.to_list(Serialization.encode_int32 nonce) @
        ByteArray.to_list(Serialization.encode_bool is_confirmed) @
        ByteArray.to_list(Serialization.encode_option (Serialization.encode_byte_array_as_list) code) @
        ByteArray.to_list(Serialization.encode_list 
                            (Serialization.encode_tuple2 
                              (Serialization.encode_string) 
                              (Serialization.encode_byte_array_as_list)) 
                            storage)
      );

    fun deserialize account_bytes =
      let
        (* TODO: no we're not , as we are using GUID size, and it reads just GUID size of bytes
           Warning! we assume, that every key is 32 bytes *)
        val (account_id, account_id_len) = Serialization.decode_byte_array (Guid.size()) account_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list account_bytes) account_id_len)
        val (public_keys, public_keys_len) = Serialization.decode_set 
                                              (Serialization.decode_byte_array (Keypair.pub_size ())) 
                                              (PublicKey.compare)
                                              updated_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) public_keys_len)
        val (account_type, account_type_len) = Serialization.decode_int8 updated_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) account_type_len)
        val (nonce, nonce_len) = Serialization.decode_int32 updated_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) nonce_len)
        val (is_confirmed, is_confirmed_len) = Serialization.decode_bool updated_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) is_confirmed_len)
        val (code, code_len) = Serialization.decode_option (Serialization.decode_byte_array_as_list) updated_bytes
        val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list updated_bytes) code_len)
        val (storage, storage_len) = Serialization.decode_list 
                                      (Serialization.decode_tuple2 
                                        (Serialization.decode_string) 
                                        (Serialization.decode_byte_array_as_list)) 
                                      updated_bytes
      in
        (Account account_id public_keys account_type nonce is_confirmed code storage,
            account_id_len + public_keys_len + account_type_len + nonce_len + is_confirmed_len + code_len + storage_len)
      end; 
end;
(**
 *  The type representing information about the transaction
 *
 *  @param timestamp: ```uint64``` Unix-timestamp of transaction creation in microseconds
 *  @param from: ```guid``` Id of account that sent the transaction
 *  @param to: ```guid option``` Id of account which is affected by the transaction.
 *    Meaning of the field depends on the type of transaction
 *  @param type: ```uint8``` Type of the transaction
 *  @param nonce: ```uint32``` Number of transaction that were sent from the account specified in 'from' field
 *  @param data: ```byte_array option``` Payload carried with the transaction
 *)
datatype transaction_payload = TransactionPayload int guid (guid option) int int (byte_array option);

structure TransactionPayload =
struct
    fun init () = TransactionPayload 0 (Guid.zero()) None 0 0 None

    fun create (timestamp, from, to, tx_type, nonce, data) = TransactionPayload timestamp from to tx_type nonce data

    fun to_string prefix (TransactionPayload timestamp from to tx_type nonce data) =
        (prefix ^ "TransactionPayload" ^ "\n")
            ^
        (prefix ^ "  " ^ "Timestamp: " ^ Int.toString timestamp ^ "\n")
            ^
        (prefix ^ "  " ^ "From: " ^ Hex.bytes_to_hex from ^ "\n")
            ^
        (prefix ^ "  " ^ "To: " ^ Formatter.option_to_string "" Hex.bytes_to_hex to ^ "\n")
            ^
        (prefix ^ "  " ^ "Type: " ^ Int.toString tx_type ^ "\n")
            ^
        (prefix ^ "  " ^ "Nonce: " ^ Int.toString nonce ^ "\n")
            ^
        (prefix ^ "  " ^ "Data: " ^ Formatter.option_to_string "" Hex.bytes_to_hex data)

    fun print transaction_payload = Formatter.lib_print (to_string "" transaction_payload ^ "\n")

    fun get_timestamp (TransactionPayload timestamp from to tx_type nonce data) = timestamp
    fun get_from (TransactionPayload timestamp from to tx_type nonce data) = from
    fun get_to (TransactionPayload timestamp from to tx_type nonce data) = to
    fun get_type (TransactionPayload timestamp from to tx_type nonce data) = tx_type
    fun get_nonce (TransactionPayload timestamp from to tx_type nonce data) = nonce
    fun get_data (TransactionPayload timestamp from to tx_type nonce data) = data

    fun set_timestamp (TransactionPayload _ from to tx_type nonce data) timestamp = 
        TransactionPayload timestamp from to tx_type nonce data
    fun set_from (TransactionPayload timestamp _ to tx_type nonce data) from = 
        TransactionPayload timestamp from to tx_type nonce data
    fun set_to (TransactionPayload timestamp from _ tx_type nonce data) to = 
        TransactionPayload timestamp from to tx_type nonce data
    fun set_type (TransactionPayload timestamp from to _ nonce data) tx_type = 
        TransactionPayload timestamp from to tx_type nonce data
    fun set_nonce (TransactionPayload timestamp from to tx_type _ data) nonce =
        TransactionPayload timestamp from to tx_type nonce data
    fun set_data (TransactionPayload timestamp from to tx_type nonce _) data =
        TransactionPayload timestamp from to tx_type nonce data

    fun is_user_creation (TransactionPayload timestamp from to tx_type nonce data) = tx_type = 2

    fun serialize (TransactionPayload timestamp from to tx_type nonce data) =
        ByteArray.from_list(
            (ByteArray.to_list(Serialization.encode_int_flex timestamp)) @  
            (ByteArray.to_list(from)) @
            (ByteArray.to_list(Serialization.encode_option (Serialization.encode_byte_array) to)) @
            (ByteArray.to_list(Serialization.encode_int8 tx_type)) @
            (ByteArray.to_list(Serialization.encode_int32 nonce)) @
            (ByteArray.to_list(Serialization.encode_option (Serialization.encode_byte_array_as_list) data))
        );
    
(*TODO: rewrite 32 as some constant to standardize hash length*)
    fun deserialize byte_array =
        let
            val (timestamp, timestamp_len) = Serialization.decode_int_flex byte_array
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) timestamp_len)
            val from = ByteArray.from_list(List.take (ByteArray.to_list upd_lst) 
                                                     (Guid.size()) )        
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) 
                                                        (Guid.size()) ) 
            val (to, to_len) =  Serialization.decode_option 
                                    (Serialization.decode_byte_array (Guid.size()) ) 
                                    upd_lst
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) to_len)
            val (tx_type, tx_type_len) = Serialization.decode_int8 upd_lst
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) tx_type_len)   
            val (nonce, nonce_len) = Serialization.decode_int32 upd_lst
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) nonce_len)
(*TODO: dynamic byte_array or make it fixed*)
            val (data, data_len) =  Serialization.decode_option (Serialization.decode_byte_array_as_list) upd_lst
        in
            ( TransactionPayload timestamp from to tx_type nonce data, 
                (timestamp_len + to_len + tx_type_len + nonce_len + data_len + (Guid.size())))
        end; 


    fun hash transaction_payload = HashFunction.calculate_from_bytes (serialize transaction_payload)
end;
datatype transaction_info = TransactionInfo hash_value hash_value ;

structure TransactionInfo = 
struct
    fun init () = TransactionInfo (HashFunction.zero()) (HashFunction.zero())

    fun get_transaction_hash (TransactionInfo transaction_hash state_root_hash) = transaction_hash
    fun get_state_root_hash (TransactionInfo transaction_hash state_root_hash) = state_root_hash

    fun set_transaction_hash (TransactionInfo _ state_root_hash) transaction_hash =
        TransactionInfo transaction_hash state_root_hash
    fun set_state_root_hash (TransactionInfo transaction_hash _) state_root_hash =
        TransactionInfo transaction_hash state_root_hash

	fun print_transaction_info (TransactionInfo transaction_hash state_root_hash) = 
       (
         print "Transaction hash: ";
         print (Hex.bytes_to_hex transaction_hash);
		     print "\nState root hash: ";
         print (Hex.bytes_to_hex state_root_hash);
         print "\n"
       );

    fun serialize (TransactionInfo signed_transaction state_root_hash) = 
      ByteArray.from_list(
          (ByteArray.to_list(Serialization.encode_byte_array signed_transaction)) @
          (ByteArray.to_list(Serialization.encode_byte_array state_root_hash ) )
      )

    fun deserialize byte_array = 
      let
          val (transaction_hash, transaction_hash_len) = Serialization.decode_byte_array (HashFunction.size()) byte_array
          val (state_root_hash, state_root_hash_len) = Serialization.decode_byte_array (HashFunction.size()) (ByteArray.from_list (List.drop (ByteArray.to_list byte_array) (HashFunction.size())))
      in
         (TransactionInfo transaction_hash state_root_hash, transaction_hash_len + state_root_hash_len)       
      end

end;
(**
 *  The type representing a transaction signed by the user
 *
 *  @param payload: ```transaction_payload``` Payload of the transaction
 *  @param signs: ```sign set``` Signatures of the transaction using user's private keys
 *)
datatype signed_transaction = SignedTransaction transaction_payload (sign set);

structure SignedTransaction =
struct
    fun init () = SignedTransaction (TransactionPayload.init()) (Set.empty ByteArray.compare)

    fun create (payload, signs) = SignedTransaction payload signs

    fun to_string prefix (SignedTransaction payload signs) =
        (prefix ^ "SignedTransaction" ^ "\n")
            ^
        (prefix ^ "  " ^ "Payload:" ^ "\n")
            ^
        (TransactionPayload.to_string (prefix ^ "  " ^ "  ") payload ^ "\n")
            ^
        (prefix ^ "  " ^ "Signatures: \n")
            ^
        (Formatter.set_to_string (prefix ^ "  " ^ "  ") Hex.bytes_to_hex signs)

    fun print signed_transaction = Formatter.lib_print (to_string "" signed_transaction ^ "\n")

    fun get_payload (SignedTransaction payload signs) = payload
    fun get_signatures (SignedTransaction payload signs) = signs

    fun set_payload (SignedTransaction _ signs) payload =
        SignedTransaction payload signs
    fun set_signatures (SignedTransaction payload _) signs =
        SignedTransaction payload signs
    
    fun serialize (SignedTransaction payload signs) = 
        ByteArray.from_list(
            (ByteArray.to_list(TransactionPayload.serialize(payload))) @
            (ByteArray.to_list(Serialization.encode_set (Serialization.encode_byte_array) signs ) )
        )

    fun deserialize byte_array = 
        let
            val (payload, payload_len) = TransactionPayload.deserialize byte_array
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) payload_len)
            val (signatures, signatures_len) = Serialization.decode_set (Serialization.decode_byte_array (Signer.sig_size()) ) (ByteArray.compare) (upd_lst)
        in
            ( ( create (payload, signatures) ), (payload_len + signatures_len))        
        end

end;
(**
 *  Represents type of the block
 *)    
datatype block_type = Proposal guid (signed_transaction list)
                    | NilBlock
                    | Genesis (account set);
    
(**
     *  The type representing data stored in block.
     *  @params round, timestamp, quorumCert, blockType
     *  @param round informaton about round number
     *  @param timestamp it is timestamp of the block 
     *  @param quorumCert it is Quorum Certificate of the block
     *  @param blockType it is type of the block
*) 
datatype block_data = BlockData int int quorum_cert block_type

structure BlockData =
struct    
  
    fun init() = BlockData 0 0 (QuorumCert.init()) NilBlock;

    fun create(round, timestamp, quorum_cert, block_type) = 
        BlockData round timestamp quorum_cert block_type;

    fun genesis_from_accounts accounts =
        let
            val blktype = Genesis (Set.from_list (Account.compare) accounts)
        in
            BlockData 0 0 (QuorumCert.genesis ()) blktype
        end;

    local
        fun block_type_to_string prefix block_type =
            case block_type of
                NilBlock => (prefix ^ "NilBlock")
              | Proposal author txs => (
                    (prefix ^ "Proposal" ^ "\n")
                        ^
                    (prefix ^ "  " ^ "Payload:" ^ "\n")
                        ^
                    (Formatter.structure_list_to_string (prefix ^ "  " ^ "  ") (SignedTransaction.to_string) txs) ^ "\n"
                        ^
                    (prefix ^ "  " ^ "Author: " ^ Hex.bytes_to_hex author)
                )
              | Genesis a => (
                    (prefix ^ "Genesis" ^ "\n")
                        ^
                    (prefix ^ "  " ^ "Accounts:" ^ "\n")
                        ^
                    (Formatter.structure_set_to_string (prefix ^ "  " ^ "  ") (Account.to_string) a)
                )
    in
        fun to_string prefix (BlockData round timestamp quorum_cert block_type) =
            (prefix ^ "BlockData" ^ "\n")
                ^
            (prefix ^ "  " ^ "Round: " ^ Int.toString round ^ "\n")
                ^
            (prefix ^ "  " ^ "Timestamp: " ^ Int.toString timestamp ^ "\n")
                ^
            (prefix ^ "  " ^ "Quorum certificate:" ^ "\n")
                ^
            (QuorumCert.to_string (prefix ^ "  " ^ "  ") quorum_cert ^ "\n")
                ^
            (prefix ^ "  " ^ "Block type:" ^ "\n")
                ^
            (block_type_to_string (prefix ^ "  " ^ "  ") block_type)
    end

    fun print block_data = Formatter.lib_print (to_string "" block_data ^ "\n")
  
    fun get_round (BlockData round _ _ _) = round
    fun get_timestamp (BlockData _ timestamp _ _) = timestamp
    fun get_quorum_cert (BlockData _ _ quorum_cert _) = quorum_cert
    fun get_block_type (BlockData _ _ _ block_type) = block_type
    
    fun get_author (BlockData _ _ _ block_type) = case block_type of
                                                    Proposal author _ => Some author
                                                  | _ => None
    
    fun set_round (BlockData _ timestamp quorum_cert block_type) round = 
        BlockData round timestamp quorum_cert block_type
    fun set_timestamp (BlockData round _ quorum_cert block_type) timestamp = 
        BlockData round timestamp quorum_cert block_type
    fun set_quorum_cert (BlockData round timestamp _ block_type) quorum_cert = 
        BlockData round timestamp quorum_cert block_type
    fun set_block_type (BlockData round timestamp quorum_cert _) block_type = 
        BlockData round timestamp quorum_cert block_type

    (*TODO: encode BlockType*)

    fun serialize_block_type (block_type) = 
        case block_type of 
            NilBlock =>
                Hex.hex_to_bytes("0x00") 
          | Genesis (account_set) =>
                ByteArray.from_list( 
                  (ByteArray.to_list(Hex.hex_to_bytes("0x01"))) @
                  (ByteArray.to_list(Serialization.encode_set (Account.serialize) account_set))
                ) 
          | Proposal author (signed_transactions) => 
                ByteArray.from_list( 
                  (ByteArray.to_list(Hex.hex_to_bytes("0x02"))) @
                  (ByteArray.to_list(Serialization.encode_byte_array(author))) @
                  (ByteArray.to_list(
                                     Serialization.encode_list 
                                        (SignedTransaction.serialize) 
                                         signed_transactions
                                    )
                  )
                 );

    fun serialize (BlockData round timestamp quorum_cert block_type) =
        ByteArray.from_list(
            ByteArray.to_list(Serialization.encode_int_flex(round)) @
            ByteArray.to_list(Serialization.encode_int_flex(timestamp)) @
            ByteArray.to_list( QuorumCert.serialize(quorum_cert) ) @
            ByteArray.to_list(serialize_block_type(block_type))
        )


    fun deserialize_block_type byte_array = 
        let
            val typ = ByteArray.from_list(List.take (ByteArray.to_list byte_array) 1) 
            val upd_lst =  ByteArray.from_list(List.drop (ByteArray.to_list byte_array) 1)
        in
            if(Hex.bytes_to_hex(typ) = "0x00") then
                ( NilBlock, 1 )
            else if(Hex.bytes_to_hex(typ) = "0x01") then
                let
                    val (accounts, accounts_len) = 
                        Serialization.decode_set (Account.deserialize) 
                                                 (Account.compare) 
                                                 upd_lst
                in
                    ((Genesis accounts), (accounts_len + 1))
                end
            else if(Hex.bytes_to_hex(typ) = "0x02") then
                let    
                    val author = ByteArray.from_list(List.take (ByteArray.to_list upd_lst) (Guid.size())) 
                    val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) (Guid.size()))
                    val (signed_transactions, signed_transactions_len) = 
                        Serialization.decode_list (SignedTransaction.deserialize) 
                                                 upd_lst
                in
                    ( (Proposal author signed_transactions), ((Guid.size()) + signed_transactions_len + 1) )
                end
            else
                ( NilBlock, 1 )
        end

    fun deserialize byte_array = 
        let
            val (round,  round_len) = Serialization.decode_int_flex byte_array
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) round_len)
            val (timestamp, timestamp_len) = Serialization.decode_int_flex upd_lst        
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) timestamp_len) 
            val (quorum_cert, quorum_cert_len) = QuorumCert.deserialize(upd_lst)
            val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) quorum_cert_len)
            val (block_type, block_type_len) = deserialize_block_type upd_lst       
        in
            (BlockData round timestamp quorum_cert block_type, 
                (round_len + timestamp_len + quorum_cert_len + block_type_len))
        end;

    fun hash block_data = HashFunction.calculate_from_bytes (serialize block_data)
end;
(**
     *  The type representing Block.
     *  @params block_data, sign
     *  !!!!!! @param id informaton about block id - moved to Hashing.from_block
     *  @param block_data it is data of the block 
     *  @param sign it is Signature of the block
*) 
datatype block = Block block_data (sign option);

structure Block = 
struct

    fun init() = Block (BlockData.init()) None;
    fun create(block_data, sign) = Block block_data sign;

    fun genesis_from_accounts accounts =
        let
            val data = BlockData.genesis_from_accounts accounts
        in
            Block data None
        end;

    fun to_string prefix (Block block_data sign) =
        (prefix ^ "Block" ^ "\n")
            ^
        (prefix ^ "  " ^ "Block data:" ^ "\n")
            ^
        (BlockData.to_string (prefix ^ "  " ^ "  ") block_data ^ "\n")
            ^
        (prefix ^ "  " ^ "Signature: " ^ Formatter.option_to_string "" Hex.bytes_to_hex sign)

    fun print block = Formatter.lib_print (to_string "" block ^ "\n")

    (***************************************************************************)
    fun get_block_data (Block block_data _) = block_data;
    fun get_sign (Block _ sign) = sign;
    fun set_block_data (Block _ sign) block_data = 
        Block block_data sign;
    fun set_sign (Block block_data _) sign = 
        Block block_data sign;

    fun get_quorum_cert (Block block_data _) = BlockData.get_quorum_cert(block_data);
    fun get_parent_hash (Block block_data _) =  
        QuorumCert.get_proposed_hash(BlockData.get_quorum_cert(block_data));
    fun get_parent_version (Block block_data _) = 
        QuorumCert.get_proposed_version(BlockData.get_quorum_cert(block_data));
    fun get_parent_state_id (Block block_data _) = 
        QuorumCert.get_proposed_state_id(BlockData.get_quorum_cert(block_data));

    fun is_genesis (Block block_data _) =
        case (BlockData.get_block_type block_data) of
            Genesis _ => True
            | _ => False;

    fun is_proposal (Block block_data _) =
        case (BlockData.get_block_type block_data) of
          Proposal _ _ => True
        | _ => False;

    fun get_round (Block block_data _) =  BlockData.get_round(block_data);
    fun get_timestamp (Block block_data _) =  BlockData.get_timestamp(block_data);
    fun get_transactions (Block block_data _) = 
        let
            val block_type = BlockData.get_block_type block_data
        in
            case block_type of
                (Proposal author signed_transactions) => signed_transactions
              | _ => [] (* NilBlock and Genesis types have no signed transactions *)
        end;

    fun get_accounts (Block block_data _) =
        let
            val block_type = BlockData.get_block_type block_data
        in
            case block_type of
                Genesis accounts => Some accounts
              | _ => None (* NilBlock and Proposal types have no initial accounts *)
        end;

    fun serialize (Block block_data sign) =
        ByteArray.from_list(
            (ByteArray.to_list(BlockData.serialize(block_data))) @
            (ByteArray.to_list
                (Serialization.encode_option (Serialization.encode_byte_array) sign)
            )
        )

    fun deserialize bytes =
      let
            val (block_data, block_data_len) = BlockData.deserialize bytes        
            val upd_lst = 
                ByteArray.from_list(List.drop (ByteArray.to_list bytes) block_data_len) 
            val (sign, sign_len) = 
                Serialization.decode_option (Serialization.decode_byte_array (Signer.sig_size()) ) (upd_lst)      
        in
            (Block block_data sign, 
                (block_data_len + sign_len))
        end;
end;

datatype transaction_status = Success | Failure;

structure TxStatus = 
struct
	fun isSuccess status =
		case status of
			Success => True
			| Failure => False;
end;

(**
	*  This type represents the result of ... TODO: add description
	*  @params root_hash, current_version, parent_version, compute_status, transaction_info_hashes
	*  TODO description of each param
*) 
datatype state_compute_result = StateComputeResult hash_value version int (transaction_status list) (hash_value list);

structure StateComputeResult = 
struct
	fun init() = StateComputeResult (HashFunction.zero()) 0 0 [] []
	
	fun create (root_hash, current_version, parent_version, compute_status, tx_info_hashes) =
		StateComputeResult root_hash current_version parent_version compute_status tx_info_hashes
	
	fun create_from_genesis commit_id commit_version =
		create(commit_id, commit_version, 0, [], [])

	local
		fun transaction_status_to_string transaction_status =
			case transaction_status of
				Success => "Success"
			  | Failure => "Failure"
	in
		fun to_string prefix (StateComputeResult root_hash current_version parent_version compute_status tx_info_hashes) =
			(prefix ^ "StateComputeResult" ^ "\n")
				^
			(prefix ^ "  " ^ "Root hash: " ^ Hex.bytes_to_hex root_hash ^ "\n")
				^
			(prefix ^ "  " ^ "Current version: " ^ Int.toString current_version ^ "\n")
				^
			(prefix ^ "  " ^ "Parent version: " ^ Int.toString parent_version ^ "\n")
				^
			(prefix ^ "  " ^ "Compute status:" ^ "\n")
				^
			(Formatter.list_to_string (prefix ^ "  " ^ "  ") transaction_status_to_string compute_status ^ "\n")
				^
			(prefix ^ "  " ^ "Transaction info hashes:" ^ "\n")
				^
			(Formatter.list_to_string (prefix ^ "  " ^ "  ") Hex.bytes_to_hex tx_info_hashes)
	end

	fun print state_compute_result = Formatter.lib_print (to_string "" state_compute_result ^ "\n")

	fun get_hash_value (StateComputeResult root_hash _ _ _ _) =
		root_hash;

	fun get_current_version (StateComputeResult _ current_version _ _ _) =
		current_version;

	fun get_parent_version (StateComputeResult _ _ parent_version _ _) =
		parent_version;

	fun get_compute_status (StateComputeResult _ _ _ compute_status _) =
		compute_status;

	fun get_transaction_info_hashes (StateComputeResult _ _ _ _ transaction_info_hashes) =
		transaction_info_hashes;

	fun set_hash_value (StateComputeResult _ current_version parent_version status tx_info_hashes) root_hash =
		StateComputeResult root_hash current_version parent_version status tx_info_hashes;
	
	fun set_current_version (StateComputeResult root_hash _ parent_version status tx_info_hashes) current_version =
		StateComputeResult root_hash current_version parent_version status tx_info_hashes;

	fun set_parent_version (StateComputeResult root_hash current_version _ status tx_info_hashes) parent_version =
		StateComputeResult root_hash current_version parent_version status tx_info_hashes;

	fun set_compute_status (StateComputeResult root_hash current_version parent_version _ tx_info_hashes) status =
		StateComputeResult root_hash current_version parent_version status tx_info_hashes;

	fun set_transaction_info_hashes (StateComputeResult root_hash current_version parent_version status _) tx_info_hashes =
		StateComputeResult root_hash current_version parent_version status tx_info_hashes;


	(*mock section*)
	fun execute_signed_transactions signed_transactions_list = 
		case signed_transactions_list of
			[] => []
			| x::xs => (HashFunction.zero())::(execute_signed_transactions xs)

	fun get_signed_transactions_status signed_transactions_list = 
		case signed_transactions_list of
			[] => []
			| x::xs => (Success)::(get_signed_transactions_status xs)

	fun create_from_transactions_list (signed_transactions_list : signed_transaction list) = 
		let
			val compute_status = get_signed_transactions_status signed_transactions_list
			val tx_info_hashes = execute_signed_transactions signed_transactions_list
		in
			create(HashFunction.zero(), 0, 0, compute_status, tx_info_hashes)
		end;

	fun create_from_block block =
		let
			val signed_transactions_list = Block.get_transactions block
		in
			create_from_transactions_list signed_transactions_list
		end;

	fun create_from_block_and_version block version =
		let
			val signed_transactions_list = Block.get_transactions block
			val result = create_from_transactions_list signed_transactions_list
		in
			set_current_version result version
		end;
		
	fun serialize_transaction_status status =
		let
		    val str_size = 1;
		in 
		    if status = Success then
		        Word8Array.array str_size (Word8.fromInt 1)
		    else
		        Word8Array.array str_size (Word8.fromInt 0)
		end;
	
	fun deserialize_transaction_status b =
		if (Word8.toInt (Word8Array.sub b 0)) = 1 then
		    (Success, 1)
		else
		    (Failure, 1)
	
	fun serialize (StateComputeResult root_hash current_version parent_version status tx_info_hashes) = 
			ByteArray.from_list(
			    ByteArray.to_list(root_hash) @
			    ByteArray.to_list(Serialization.encode_int_flex current_version) @
			    ByteArray.to_list(Serialization.encode_int_flex parent_version) @
			    ByteArray.to_list(Serialization.encode_list serialize_transaction_status status) @
			    ByteArray.to_list(Serialization.encode_list Serialization.encode_byte_array tx_info_hashes)
			)
	
	fun deserialize bytes =
	      let
		    val (root_hash, root_hash_len) = Serialization.decode_byte_array (HashFunction.size()) bytes
		    val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list bytes) root_hash_len)
		    val (current_version, current_version_len) = Serialization.decode_int_flex upd_lst        
		    val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) current_version_len) 
		    val (parent_version, parent_version_len) = Serialization.decode_int_flex upd_lst
		    val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) parent_version_len)
		    val (status, status_len) = Serialization.decode_list deserialize_transaction_status upd_lst
		    val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list upd_lst) status_len)
		    val (tx_info_hashes, tx_info_hashes_len) = Serialization.decode_list (Serialization.decode_byte_array (HashFunction.size())) upd_lst   
		in
		    (StateComputeResult root_hash current_version parent_version status tx_info_hashes, 
		        (root_hash_len + current_version_len + parent_version_len + status_len + tx_info_hashes_len))
		end; 
end;
 (**
     *  The type representing data stored in block.
     *  @params block, computeResult
     *  @param block informaton about block
     *  @param computeResult it is changed state of the machine
     *)
datatype executed_block = ExecutedBlock block state_compute_result;

structure ExecutedBlock = 
struct
    
    fun init() = ExecutedBlock (Block.init()) (StateComputeResult.init());

    fun create(block, state_compute_result) = ExecutedBlock block state_compute_result;

    fun to_string prefix (ExecutedBlock block state_compute_result) =
        (prefix ^ "ExecutedBlock" ^ "\n")
            ^
        (prefix ^ "  " ^ "Block:" ^ "\n")
            ^
        (Block.to_string (prefix ^ "  " ^ "  ") block ^ "\n")
            ^
        (prefix ^ "  " ^ "Compute result:" ^ "\n")
            ^
        (StateComputeResult.to_string (prefix ^ "  " ^ "  ") state_compute_result)
    
    fun print executed_block = Formatter.lib_print (to_string "" executed_block ^ "\n")

	fun get_block (ExecutedBlock block _) = block;

    fun get_transactions (ExecutedBlock block _) = Block.get_transactions block;

	fun get_state_compute_result (ExecutedBlock _ state_compute_result) = state_compute_result;

    fun set_block (ExecutedBlock _ state_compute_result) block =
        ExecutedBlock block state_compute_result
    
    fun set_state_compute_result (ExecutedBlock block _) state_compute_result =
        ExecutedBlock block state_compute_result

	fun get_parent_hash (ExecutedBlock block _) = Block.get_parent_hash block;

	fun get_quorum_cert (ExecutedBlock block _) = Block.get_quorum_cert block;

	fun get_round (ExecutedBlock block _) = Block.get_round block;

    fun get_timestamp (ExecutedBlock block _) = Block.get_timestamp block;
	
	fun serialize (ExecutedBlock block state_compute_result) = 
		ByteArray.from_list(
			    ByteArray.to_list(Block.serialize block) @
			    ByteArray.to_list(StateComputeResult.serialize state_compute_result)
			)
		
	fun deserialize byte_array =
	      let
		    val (block, block_len) = Block.deserialize byte_array
		    val upd_lst = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) block_len)
		    val (state_compute_result, state_compute_result_len) = StateComputeResult.deserialize upd_lst           
		in
		    (ExecutedBlock block state_compute_result, 
		        (block_len + state_compute_result_len))
		end;
end;
(**
    * Type represents proposal message to be sent to other nodes
    * @params proposal, sync_info
    * @param proposal: ```block``` A block for new round
    * @param sync_info: ```sync_info``` Synchronization information 
    * corrsponding to the parent block of proposal
*)
datatype proposal_msg = ProposalMsg block sync_info;

structure ProposalMsg = 
struct
    fun init() = ProposalMsg (Block.init()) (SyncInfo.init())
    fun create(proposal, sync_info) = ProposalMsg proposal sync_info

    fun to_string prefix (ProposalMsg proposal sync_info) =
        (prefix ^ "ProposalMsg" ^ "\n")
            ^
        (prefix ^ "  " ^ "Proposal:" ^ "\n")
            ^
        (Block.to_string (prefix ^ "  " ^ "  ") proposal ^ "\n")
            ^
        (prefix ^ "  " ^ "Sync info:" ^ "\n")
            ^
        (SyncInfo.to_string (prefix ^ "  " ^ "  ") sync_info)

    fun print proposal_msg = Formatter.lib_print (to_string "" proposal_msg ^ "\n")

    (***************************************************************************)

    fun get_proposal (ProposalMsg proposal _) = proposal
    
    fun get_sync_info (ProposalMsg _ sync_info) = sync_info

    (***************************************************************************)

    fun set_proposal (ProposalMsg _ sync_info) proposal = 
        ProposalMsg proposal sync_info

    fun set_sync_info (ProposalMsg proposal _) sync_info = 
        ProposalMsg proposal sync_info
    
    fun serialize (ProposalMsg proposal sync_info) =
      ByteArray.from_list(
        ByteArray.to_list(Block.serialize proposal) @
        ByteArray.to_list(SyncInfo.serialize sync_info)
      )

    fun deserialize proposal_msg_bytes = 
    let
      val (proposal, proposal_len) = Block.deserialize proposal_msg_bytes
      val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list proposal_msg_bytes) proposal_len)
      val (sync_info, sync_info_len) = SyncInfo.deserialize updated_bytes
    in
      (ProposalMsg proposal sync_info, proposal_len + sync_info_len)
    end
end;
    (**
     *  This type represents data about Vote.
     *  @params vote, sync_info
     *  @param vote is a latest vote for a new block
     *  @param sync_info is synchronization information
     *) 
datatype vote_msg = VoteMsg vote sync_info;

structure VoteMsg =
struct    
    fun init () = VoteMsg (Vote.init()) (SyncInfo.init());
    fun create (vote, sync_info) = VoteMsg vote sync_info;

    fun to_string prefix (VoteMsg vote sync_info) =
        (prefix ^ "VoteMsg" ^ "\n")
            ^
        (prefix ^ "  " ^ "Vote:" ^ "\n")
            ^
        (Vote.to_string (prefix ^ "  " ^ "  ") vote ^ "\n")
            ^
        (prefix ^ "  " ^ "Sync info:" ^ "\n")
            ^
        (SyncInfo.to_string (prefix ^ "  " ^ "  ") sync_info)

    fun print vote_msg = Formatter.lib_print (to_string "" vote_msg ^ "\n")
    
    fun get_vote( VoteMsg vote _) =
        vote;
    fun get_sync_info(VoteMsg _ sync_info) =
        sync_info;

    fun set_vote( VoteMsg _ sync_info) vote =
        VoteMsg vote sync_info;
    fun set_sync_info(VoteMsg vote _) sync_info =
        VoteMsg vote sync_info;

    fun serialize (VoteMsg vote sync_info) =
      ByteArray.from_list(
        ByteArray.to_list(Vote.serialize vote) @
        ByteArray.to_list(SyncInfo.serialize sync_info)
      )

    fun deserialize vote_msg_bytes = 
        let
          val (vote, vote_len) = Vote.deserialize vote_msg_bytes
          val updated_bytes = ByteArray.from_list(List.drop (ByteArray.to_list vote_msg_bytes) vote_len)
          val (sync_info, sync_info_len) = (SyncInfo.deserialize updated_bytes)
        in
            ((VoteMsg vote sync_info), (vote_len + sync_info_len))
        end
end;
(**
     *  This type represents Safety Data.
     *  @params last_voted_round, preferred_round, last_vote
     *  @param last_voted_round is a number of the last Voting Round
     *  @param preferred_round is a number of the last Preferred Round
     *  @param last_vote is a last Vote for the Latest Block
*) 
datatype safety_data = SafetyData int  int  (vote option);

structure SafetyData =
struct    

    fun init() = SafetyData 0 0 None;
    fun create(last_voted_round, preferred_round, last_vote) = 
        SafetyData last_voted_round preferred_round last_vote;

    fun to_string prefix (SafetyData last_voted_round preferred_round last_vote) =
        (prefix ^ "SafetyData" ^ "\n")
            ^
        (prefix ^ "  " ^ "Last voted round: " ^ Int.toString last_voted_round ^ "\n")
            ^
        (prefix ^ "  " ^ "Preferred round: " ^ Int.toString preferred_round ^ "\n")
            ^
        (prefix ^ "  " ^ "Last vote:" ^ "\n")
            ^
        (Formatter.structure_option_to_string (prefix ^ "  " ^ "  ") Vote.to_string (prefix ^ "  " ^ "  " ^ "  ") last_vote)

    fun print safety_data = Formatter.lib_print (to_string "" safety_data ^ "\n")

    fun get_last_voted_round (SafetyData last_voted_round _ _) = last_voted_round;
    fun get_preferred_round (SafetyData _ preferred_round _) = preferred_round;
    fun get_last_vote (SafetyData _ _ last_vote) = last_vote;
  
    fun set_last_voted_round (SafetyData _ preferred_round last_vote) last_voted_round = 
       SafetyData last_voted_round preferred_round last_vote;

    fun set_preferred_round (SafetyData last_voted_round _ last_vote) preferred_round = 
        SafetyData last_voted_round preferred_round last_vote;

    fun set_last_vote (SafetyData last_voted_round preferred_round _) last_vote = 
        SafetyData last_voted_round preferred_round last_vote;

    fun serialize (SafetyData last_voted_round preferred_round last_vote) =
        ByteArray.from_list(
            (ByteArray.to_list (Serialization.encode_int_flex last_voted_round)) @
            (ByteArray.to_list (Serialization.encode_int_flex preferred_round)) @
            (ByteArray.to_list (Serialization.encode_option (Vote.serialize) last_vote))
        );

    fun deserialize byte_array = 
        let
            val (last_voted_round, len1) = Serialization.decode_int_flex byte_array
            val (preferred_round, len2) = Serialization.decode_int_flex (ByteArray.suffix byte_array len1)
            val (last_vote, len3) = Serialization.decode_option (Vote.deserialize) (ByteArray.suffix byte_array (len1 + len2))
        in
            (SafetyData last_voted_round preferred_round last_vote, len1 + len2 + len3)
        end
    
    fun db_key () = "consensus_safety";

end;
(* *
 *  Structure that contains comparators for primitive types
 *  Only equality tests are available now
 *
 *  TODO: test functions defined in the structure
 *)
structure Comparators =
struct
    fun eq_list eq_comp a b =
        case (a, b) of
            ([], []) => True
          | ([], _) => False
          | (_, []) => False
          | (h1::t1, h2::t2) => (eq_comp h1 h2) andalso (eq_list eq_comp t1 t2) 

    fun eq_alist eq_comp_1 eq_comp_2 a b = 
        eq_list (fn x => fn y => eq_comp_1 (fst x) (fst y) andalso eq_comp_2 (snd x) (snd y)) a b

    fun eq_map eq_val_comp a b = 
        (Map.isSubmapBy eq_val_comp a b) 
            andalso 
        (Map.isSubmapBy eq_val_comp b a)

    fun eq_option eq_comp a b =
        case (a, b) of
            (None, None) => True
          | (Some a, Some b) => eq_comp a b
          | _ => False

    fun eq_set a b = 
        ((Set.length a) = (Set.length b)) andalso
        (List.all (fn item => Set.member b item) (Set.to_list a))
        

    fun eq_hash_value a b = (ByteArray.equal a b)

    fun eq_guid a b = eq_hash_value a b

    fun eq_signature a b = eq_hash_value a b

    fun eq_string a b = (String.compare a b) = Equal

    fun eq_block_info a b =
        (BlockInfo.get_round a = BlockInfo.get_round b)
            andalso 
        (eq_hash_value (BlockInfo.get_id a) (BlockInfo.get_id b))
            andalso
        (eq_hash_value (BlockInfo.get_executed_state_id a) (BlockInfo.get_executed_state_id b))
            andalso
        (BlockInfo.get_version a = BlockInfo.get_version b)
            andalso
        (BlockInfo.get_timestamp_usecs a = BlockInfo.get_timestamp_usecs b)
    
    fun eq_vote_data a b =
        (eq_block_info (VoteData.get_proposed a) (VoteData.get_proposed b))
            andalso
        (eq_block_info (VoteData.get_parent a) (VoteData.get_parent b))

    fun eq_ledger_info a b =
        (eq_block_info (LedgerInfo.get_commit_info a) (LedgerInfo.get_commit_info b))
            andalso
        (eq_hash_value (LedgerInfo.get_consensus_data_hash a) (LedgerInfo.get_consensus_data_hash b))

    fun eq_signed_ledger_info a b =
        (eq_ledger_info (SignedLedgerInfo.get_ledger_info a) (SignedLedgerInfo.get_ledger_info b))
            andalso
        (eq_map eq_signature (SignedLedgerInfo.get_signatures a) (SignedLedgerInfo.get_signatures b))

    fun eq_vote a b =
        (eq_vote_data (Vote.get_vote_data a) (Vote.get_vote_data b))
            andalso
        (eq_guid (Vote.get_author a) (Vote.get_author b))
            andalso
        (eq_ledger_info (Vote.get_ledger_info a) (Vote.get_ledger_info b))
            andalso
        (eq_signature (Vote.get_signature a) (Vote.get_signature b))
            andalso
        (eq_option eq_signature (Vote.get_timeout_signature a) (Vote.get_timeout_signature b))

    fun eq_quorum_cert a b =
        (eq_vote_data (QuorumCert.get_vote_data a) (QuorumCert.get_vote_data b))
            andalso
        (eq_signed_ledger_info (QuorumCert.get_signed_ledger_info a) (QuorumCert.get_signed_ledger_info b))
    
    fun eq_timeout_cert a b =
        (TimeoutCert.get_round a = TimeoutCert.get_round b)
            andalso
        (eq_map eq_signature (TimeoutCert.get_signatures a) (TimeoutCert.get_signatures b))

    fun eq_sync_info a b = 
        (eq_quorum_cert (SyncInfo.get_highest_commit_cert a) (SyncInfo.get_highest_commit_cert b))
            andalso
        (eq_quorum_cert (SyncInfo.get_highest_quorum_cert a) (SyncInfo.get_highest_quorum_cert b))
            andalso
        (eq_option eq_timeout_cert (SyncInfo.get_timeout_cert a) (SyncInfo.get_timeout_cert b))

    fun eq_safety_data a b =
        (SafetyData.get_last_voted_round a = SafetyData.get_last_voted_round b)
            andalso
        (SafetyData.get_preferred_round a = SafetyData.get_preferred_round b)
            andalso
        (eq_option eq_vote (SafetyData.get_last_vote a) (SafetyData.get_last_vote b))

    (***************************************************)
                (* Has not been tested yet *)

    fun eq_transaction_payload a b =
        (TransactionPayload.get_timestamp a = TransactionPayload.get_timestamp b)
            andalso
        (eq_guid (TransactionPayload.get_from a) (TransactionPayload.get_from b))
            andalso
        (eq_option eq_guid (TransactionPayload.get_to a) (TransactionPayload.get_to b))
            andalso
        (TransactionPayload.get_type a = TransactionPayload.get_type b)
            andalso
        (TransactionPayload.get_nonce a = TransactionPayload.get_nonce b)
            andalso
        (eq_option ByteArray.equal (TransactionPayload.get_data a) (TransactionPayload.get_data b))

    fun eq_signed_transaction a b =
        (eq_transaction_payload (SignedTransaction.get_payload a) (SignedTransaction.get_payload b))
            andalso
        (eq_set (SignedTransaction.get_signatures a) (SignedTransaction.get_signatures b))

    (***************************************************)

    fun eq_block_type a b =
        case (a, b) of
            (Proposal author_a payload_a, Proposal author_b payload_b) =>
                (eq_guid author_a author_b)
                    andalso
                (eq_list eq_signed_transaction payload_a payload_b)
          | (NilBlock, NilBlock) => True
          | (Genesis accounts_a, Genesis accounts_b) =>
                (eq_set accounts_a accounts_b)
          | _ => False

    fun eq_block_data a b =
        (BlockData.get_round a = BlockData.get_round b)
            andalso
        (BlockData.get_timestamp a = BlockData.get_timestamp b)
            andalso
        (eq_quorum_cert (BlockData.get_quorum_cert a) (BlockData.get_quorum_cert b))
            andalso
        (eq_block_type (BlockData.get_block_type a) (BlockData.get_block_type b))

    fun eq_block a b =
        (eq_block_data (Block.get_block_data a) (Block.get_block_data b))
            andalso
        (eq_option eq_signature (Block.get_sign a) (Block.get_sign b))

    fun eq_proposal_msg a b =
        (eq_block (ProposalMsg.get_proposal a) (ProposalMsg.get_proposal b))
            andalso
        (eq_sync_info (ProposalMsg.get_sync_info a) (ProposalMsg.get_sync_info b))

    fun eq_vote_msg a b =
        (eq_vote (VoteMsg.get_vote a) (VoteMsg.get_vote b))
            andalso
        (eq_sync_info (VoteMsg.get_sync_info a) (VoteMsg.get_sync_info b))

    fun eq_transaction_status a b =
        case (a, b) of
            (Success, Success) => True
          | (Failure, Failure) => True
          | _ => False

    fun eq_state_compute_result a b =
        (eq_hash_value (StateComputeResult.get_hash_value a) (StateComputeResult.get_hash_value b))
            andalso
        (StateComputeResult.get_current_version a = StateComputeResult.get_current_version b)
            andalso
        (StateComputeResult.get_parent_version a = StateComputeResult.get_parent_version b)
            andalso
        (eq_list eq_transaction_status (StateComputeResult.get_compute_status a) (StateComputeResult.get_compute_status b))
            andalso
        (eq_list eq_hash_value (StateComputeResult.get_transaction_info_hashes a) (StateComputeResult.get_transaction_info_hashes b))

    fun eq_executed_block a b =
        (eq_block (ExecutedBlock.get_block a) (ExecutedBlock.get_block b))
            andalso
        (eq_state_compute_result (ExecutedBlock.get_state_compute_result a) (ExecutedBlock.get_state_compute_result b))

    
    (***************************************************)
                (* Has not been tested yet *)

    fun eq_public_key a b = ByteArray.compare a b
    
    fun eq_account a b =
        (eq_guid (Account.get_account_id a) (Account.get_account_id b))
            andalso
        (eq_set (Account.get_public_keys a) (Account.get_public_keys b))
            andalso
        (Account.get_type a = Account.get_type b)
            andalso
        (Account.get_nonce a = Account.get_nonce b)
            andalso
        (Account.get_is_confirmed a = Account.get_is_confirmed b)
            andalso
        (eq_option ByteArray.equal (Account.get_code a) (Account.get_code b))
            andalso
        (eq_alist eq_string (ByteArray.equal) (Account.get_storage a) (Account.get_storage b))
end;
structure AccountValidation = 
struct
	fun match_account_signature account message sign =
		List.find 
			(fn key => (SignatureVerifier.verify sign message key)) 
			(Set.to_list (Account.get_public_keys account));

	fun validate_signature account message sign =
		Option.isSome (match_account_signature account message sign)

	fun validate_signatures account message signs =
		let
			fun match_key set sign =
				let
					val key = match_account_signature account message sign
				in
					Option.getOpt (Option.map (fn value => Set.add set value) key) set
				end;

			val acc_keys_count = Set.length (Account.get_public_keys account)
			val matched_keys = List.foldl 
								(fn set => fn sign => match_key set sign)
								(Set.empty (ByteArray.compare))
								(Set.to_list signs)
		in
			((Set.length matched_keys) = acc_keys_count)
		end;
end;structure Hashing = 
struct
	fun from_tx tx =
		let
			val payload = TransactionPayload.serialize (SignedTransaction.get_payload tx)
		in
			HashFunction.calculate_from_bytes payload
		end;

	fun from_tx_info info =
		let
			val payload = TransactionInfo.serialize info
		in
			HashFunction.calculate_from_bytes payload
		end;

	fun from_block_data data =
		HashFunction.calculate_from_bytes (BlockData.serialize data)

	fun from_block block =
		from_block_data (Block.get_block_data block)

	fun from_executed_block block =
		from_block (ExecutedBlock.get_block block);

	fun from_vote_data vote_data =
		HashFunction.calculate_from_bytes (VoteData.serialize vote_data)

end;datatype known_node_info = KnownNodeInfo guid in_addr int public_key int

(* Structure for known and connected node sets *)
structure KnownNodeInfo = 
struct

    fun create (id : guid) (address : in_addr) (port : int) (public_key : public_key) = KnownNodeInfo id address port public_key 0

    fun get_id (KnownNodeInfo guid _ _ _ _) = guid

    fun get_address (KnownNodeInfo _ address _ _ _) = address

    fun get_port (KnownNodeInfo _ _ port _ _) = port

    fun get_pk (KnownNodeInfo _ _ _ pk _) = pk

    fun get_last_found (KnownNodeInfo _ _ _ _ lf) = lf

    fun serialize (KnownNodeInfo user address port pk lf) = 
        ByteArray.from_list (
            ByteArray.to_list(Serialization.encode_byte_array user) @
            ByteArray.to_list(InAddr.serialize address)             @
            ByteArray.to_list(Serialization.encode_int16 port)      @
            ByteArray.to_list(Serialization.encode_byte_array pk)   @
            ByteArray.to_list(Serialization.encode_int_flex lf)
        )

    fun deserialize serial = 
        let
            val (user, user_len) = Serialization.decode_byte_array (Guid.size()) serial
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) user_len)

            val (address, address_len) = InAddr.deserialize upd_ser
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) address_len)

            val (port, port_len) = Serialization.decode_int16 upd_ser
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) port_len)

            val (pk, pk_len) = Serialization.decode_byte_array (Keypair.pub_size()) upd_ser
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) pk_len)

            val (lf, lf_len) = Serialization.decode_int_flex upd_ser
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) lf_len)
        in
            (KnownNodeInfo user address port pk lf,
             user_len + address_len + port_len + pk_len + lf_len)
        end

end
type node_data_set = (guid, known_node_info) map

structure NodeDataSet =
struct
    fun init (known_node_info_list : known_node_info list) =
        Map.fromList Guid.compare (List.map (fn x => (KnownNodeInfo.get_id x, x)) known_node_info_list)

    fun size node_data_set = List.length (Map.toAscList node_data_set)

    fun search_by_address (node_data_set : node_data_set) (addr : in_addr) =
        List.find 
            (fn x => 
                InAddr.compare addr (KnownNodeInfo.get_address x) = Equal 
            )
            (List.map snd (Map.toAscList node_data_set))

    fun search (node_data_set : node_data_set) (account_id : guid) = 
        Map.lookup node_data_set account_id

    (* TODO: add assertion that the corresponding account_id exists in the 'node_data_set' 
     *  and raise exception otherwise. Or we can just combine the method with 'append' function. *)
    fun update (node_data_set : node_data_set) (account_id : guid) (info : known_node_info) =
        Map.insert node_data_set account_id info

    (* TODO: add assertion that the corresponding account_id does not already exist in the 'node_data_set' 
     *  and raise exception otherwise. Or we can just combine the method with 'update' function. *)
    fun append (node_data_set : node_data_set) (info : known_node_info) = 
        Map.insert node_data_set (KnownNodeInfo.get_id info) info

    fun pop (node_data_set : node_data_set) (account_id : guid) =
        let
            val info_opt = search node_data_set account_id
        in
            case info_opt of
                None => (node_data_set, None)
              | Some info => (Map.delete node_data_set account_id, info_opt)
        end

    fun serialize node_data_set = 
        Serialization.encode_list KnownNodeInfo.serialize (List.map snd (Map.toAscList node_data_set))

    fun deserialize serial =
        let
            val (node_data_set_list, decode_size) = Serialization.decode_list KnownNodeInfo.deserialize serial
            
            val node_data_set = 
                Map.fromList 
                    Guid.compare 
                    (List.map (fn info => (KnownNodeInfo.get_id info, info)) node_data_set_list)
        in
            (node_data_set, decode_size)
        end

    fun to_list (node_data_set: node_data_set) =
        List.map snd (Map.toAscList node_data_set)
end

datatype connected_node_info = ConnectedNodeInfo guid (int option) (noise_keys option) bool io_buffer

structure ConnectedNodeInfo = 
struct
    fun init guid = ConnectedNodeInfo guid None None False (IOBuffer.init 100 20)
    fun create guid fd_opt noise_k_opt ic =
        ConnectedNodeInfo guid fd_opt noise_k_opt ic (IOBuffer.init 100 20)

    fun get_id (ConnectedNodeInfo guid _ _ _ _) = guid

    fun get_fd_opt (ConnectedNodeInfo _ fd_opt _ _ _) = fd_opt

    (* NON-SAFE! Can raise 'Bind' exception if is called on the info without specified fd *)
    fun get_fd connected_node_info = Option.valOf (get_fd_opt connected_node_info)

    fun get_noise_keys_opt (ConnectedNodeInfo _ _ noise_k_opt _ _) = noise_k_opt

    fun send_key_opt connected_node_info = 
        case get_noise_keys_opt connected_node_info of
            Some nk => Some (Noise.send_key nk)
          | None => None

    fun recv_key_opt connected_node_info = 
        case get_noise_keys_opt connected_node_info of
            Some nk => Some (Noise.recv_key nk)
          | None => None

    fun get_is_confirmed (ConnectedNodeInfo _ _ _ ic _) = ic

    fun get_io_buff (ConnectedNodeInfo _ _ _ _ ib) = ib

    fun set_fd (ConnectedNodeInfo guid _ noise_k_opt ic ib) fd =
        ConnectedNodeInfo guid (Some fd) noise_k_opt ic ib

    fun set_noise_keys (ConnectedNodeInfo guid fd_opt _ ic ib) noise_k =
        ConnectedNodeInfo guid fd_opt (Some noise_k) ic ib

    fun set_is_confirmed (ConnectedNodeInfo guid fd_opt noise_k_opt _ ib) ic =
        ConnectedNodeInfo guid fd_opt noise_k_opt ic ib

    fun set_id (ConnectedNodeInfo _ fd_opt noise_k_opt ic ib) account_id = 
        ConnectedNodeInfo account_id fd_opt noise_k_opt ic ib
end
type connected_node_set = (guid, connected_node_info) map

structure ConnectedNodeSet =
struct
    fun init () = Map.empty Guid.compare

    fun search (connected_node_set : connected_node_set) (account_id : guid) = 
        Map.lookup connected_node_set account_id

    (* TODO: add assertion that the corresponding account_id exists in the 'connected_node_set' 
     *  and raise exception otherwise. Or we can just combine the method with 'append' function. *)
    fun update (connected_node_set : connected_node_set) (info : connected_node_info) =
        Map.insert connected_node_set (ConnectedNodeInfo.get_id info) info

    (* TODO: add assertion that the corresponding account_id does not already exist in the 'connected_node_set' 
     *  and raise exception otherwise. Or we can just combine the method with 'update' function. *)
    fun append (connected_node_set : connected_node_set) (info : connected_node_info) = 
        Map.insert connected_node_set (ConnectedNodeInfo.get_id info) info

    fun pop (connected_node_set : connected_node_set) (account_id : guid) =
        let
            val info_opt = search connected_node_set account_id
        in
            case info_opt of
                None => (connected_node_set, None)
              | Some info => (Map.delete connected_node_set account_id, info_opt)
        end

    fun remove (connected_node_set : connected_node_set) (account_id : guid) =
        Map.delete connected_node_set account_id

    fun to_list (connected_node_set : connected_node_set) =
        List.map snd (Map.toAscList connected_node_set)
end
datatype network_state = NetworkState node_data_set connected_node_set

structure NetworkState =
struct
    fun init node_data_set = NetworkState node_data_set (ConnectedNodeSet.init ())

    fun get_node_data_set (NetworkState node_data_set _) = node_data_set
    fun get_connected_node_set (NetworkState _ connected_node_set) = connected_node_set

    fun set_node_data_set (NetworkState _ connected_node_set) node_data_set =
        NetworkState node_data_set connected_node_set
    fun set_connected_node_set (NetworkState node_data_set _) connected_node_set =
        NetworkState node_data_set connected_node_set

    fun map_to_node_data_set network_state func =
        set_node_data_set network_state (func (get_node_data_set network_state))
    fun map_to_connected_node_set network_state func =
        set_connected_node_set network_state (func (get_connected_node_set network_state))
        
    (*  Apply the naive approach and returns the first unconnected node from the list.
     *  If any node is impossible to connect it may be possible, that on each request
     *  that node will be returned and, thus, all other nodes will be never connected to.
     *)
    fun new_node_connection network_state this_node_id =
        let
            val node_data_set = get_node_data_set network_state
            val connected_node_set = get_connected_node_set network_state

            fun lookup_unconnected_node (known_node_info_list : known_node_info list) =
                case known_node_info_list of
                    [] => None
                  | (x :: xs) => (
                    let
                        val node_id = KnownNodeInfo.get_id x
                    in
                        if
                            Option.isNone (ConnectedNodeSet.search connected_node_set node_id)
                                andalso
                            Guid.compare node_id this_node_id <> Equal
                        then
                            Some x
                        else
                            lookup_unconnected_node xs
                    end
                  )
        in
            lookup_unconnected_node (NodeDataSet.to_list node_data_set)
        end
end
datatype sync_commit = SyncCommit (signed_transaction list) signed_ledger_info

datatype msg_prefix = DirectMsg | RpcRequest int ;

datatype msg_type = Discovery node_data_set
                  | ConnectionInit byte_array | Connection byte_array
                  | ConsensusProposal proposal_msg | ConsensusVote vote_msg
                  | SyncRequestBlock (hash_value option) hash_value 
                  | SyncRequestTx int
                  | SyncDataBlock ((block * quorum_cert option) list) sync_info
                  | SyncDataTx (sync_commit list) sync_info
                  | Ping | Pong;

datatype received_type = RecvDiscovery
                       | RecvConnectionInit
                       | RecvConnection
                       | RecvConsensusProposal
                       | RecvConsensusVote
                       | RecvSyncRequestBlock
                       | RecvSyncRequestTx
                       | RecvSyncDataBlock
                       | RecvSyncDataTx
                       | RecvPing
                       | RecvPong;

type network_data = msg_type;

structure SyncCommit = 
struct
    fun serialize (SyncCommit tx_list signed_ledger_info) =
        ByteArray.from_list (
          ByteArray.to_list(Serialization.encode_list (SignedTransaction.serialize) tx_list) @
          ByteArray.to_list(SignedLedgerInfo.serialize(signed_ledger_info))
        )
            
    fun deserialize (byte_array) = 
        let 
            val (txs, txs_len) = Serialization.decode_list (SignedTransaction.deserialize) byte_array
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list byte_array) txs_len)
            val (ledger_info, ledger_info_len) = SignedLedgerInfo.deserialize upd_ser
        in 
            (SyncCommit txs ledger_info, (txs_len + ledger_info_len))
        end 
end;(*  *)
datatype timer_data = SetRoundTimer int;
datatype out_event = DirectMsgEvent guid network_data | BroadcastEvent network_data
                   | RpcRequestEvent guid network_data (int option)
                   | InternalTimerDataEvent timer_data
                   | CloseConnectionEvent guid

type event_request = (out_event * bool)
structure MarshallingHelp =
struct
    val w2n = Word8.toInt

    val n2w = Word8.fromInt

    fun w42n src i = 
        let
            val b3 = Word8Array.sub src i
            val b2 = Word8Array.sub src (i + 1)
            val b1 = Word8Array.sub src (i + 2)
            val b0 = Word8Array.sub src (i + 3)
        in
            256 * (256 * (256 * w2n b3 + w2n b2) + w2n b1) + w2n b0
        end

    fun n2w4 n dst i  =
        let
            val _ = Word8Array.update dst (i + 3) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 2) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 1) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst i (n2w n)
        in
            ()
        end
    
    fun n2w8 n dst i =
        let
            val _ = Word8Array.update dst (i + 7) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 6) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 5) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 4) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 3) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 2) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst (i + 1) (n2w n)
            val n = n div 256
            val _ = Word8Array.update dst i (n2w n)
        in
            ()
        end

    local
        fun w82n_internal b0 b1 b2 b3 b4 b5 b6 b7 =
            256 * (256 * (256 * (256 * (
                256 * (256 * (256 * w2n b7 + w2n b6) + w2n b5) + w2n b4
            ) + w2n b3) + w2n b2) + w2n b1) + w2n b0
    in
        fun w82n src i =
            let
                val b7 = Word8Array.sub src i
                val b6 = Word8Array.sub src (i + 1)
                val b5 = Word8Array.sub src (i + 2)
                val b4 = Word8Array.sub src (i + 3)
                val b3 = Word8Array.sub src (i + 4)
                val b2 = Word8Array.sub src (i + 5)
                val b1 = Word8Array.sub src (i + 6)
                val b0 = Word8Array.sub src (i + 7)
            in
                w82n_internal b0 b1 b2 b3 b4 b5 b6 b7  
            end

        fun w82n_little src i =
            let
                val b0 = Word8Array.sub src i
                val b1 = Word8Array.sub src (i + 1)
                val b2 = Word8Array.sub src (i + 2)
                val b3 = Word8Array.sub src (i + 3)
                val b4 = Word8Array.sub src (i + 4)
                val b5 = Word8Array.sub src (i + 5)
                val b6 = Word8Array.sub src (i + 6)
                val b7 = Word8Array.sub src (i + 7)
            in
                w82n_internal b0 b1 b2 b3 b4 b5 b6 b7
            end
    end

    (**
     *  Deserializes a byte array into the list of some elements.
     *
     *  @param f `byte_array -> int -> ('a * int)` - a function to deserialize
     *      a single element of the array. Returns an elemnts itself, and
     *      amount of bytes that has been wasted during deserialization.
     *  @param n `int`: number of elements to be deserialized.
     *  @param bytes `byte_array`: bytes to be deserialized.
     *  @param i `int`: index where bytes should be deserialized from.
     *)
    fun bytes_to_list f n bytes i =
        let
            fun internal k offset res =
                if 
                    k <= 0
                then 
                    res
                else
                    let
                        val (v, r) = f bytes offset
                    in
                        internal (k-1) (offset + r) (v::res)
                    end
        in
            List.rev (internal n i [])
        end
end

(**
 *  Is raised when FFI call returns an erroneous status code.
 *)
exception FFIFailure

(**
 *  Is raised when called by FFI syscall is interrupted by a signal.
 *)
exception FFIEintr

(**
 *  Is raised when called by FFI syscall would block 
 *  on nonblocking descriptor.
 *)
exception FFIEagain

structure FFICodes =
struct
    val success = 0
    val failure = 1
    val eintr = 2
    val eagain = 3
end

structure FFIHelper =
struct
    fun validate_status (outbuf : byte_array) =
        let
            val status = Word8.toInt (Word8Array.sub outbuf 0)
        in
            if status = FFICodes.failure
            then raise FFIFailure
            else if status = FFICodes.eintr
            then raise FFIEintr
            else if status = FFICodes.eagain
            then raise FFIEagain
            else ()
        end
end

local
    fun exn_printer e =
        case e of
            FFIFailure => "FFIFailure"
          | FFIEintr => "FFIEintr"
          | FFIEagain => "FFIEagain"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
structure Errno =
struct
    (**
     *  
     *)
    fun errno () =
        let
            val inbuf = ""
            val outbuf = Word8Array.array 4 (Word8.fromInt 0)
        in
            #(errno_errno) inbuf outbuf;
            MarshallingHelp.w42n outbuf 0
        end
end
structure Fd =
struct
    (**
     *  Closes the specified file descriptor.
     *
     *  @param fd `int`: fd to be closed.
     *
     *  @raises `FFIFailure` if `close` syscall fails. 
     *)
    fun close fd =
        let
            val inbuf = ByteArray.empty 4
            val _ = MarshallingHelp.n2w4 fd inbuf 0

            val outbuf = ByteArray.empty 1
        in
            #(fd_close) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Read from a file descriptor.
     *
     *  @param fd `int`: a descriptor to read data from.
     *  @param count `int`: maxumum number of bytes to be read.
     *
     *  @returns `byte_array` the data that was read.
     *
     *  @raises `FFIEagain` if file descriptor refers to nonblocking
     *      file and `read` syscall would block.
     *  @raises `FFIEintr` if `read` syscall was interrupted by a signal.
     *  @raises `FFIFailure` if any other error occured during the call.
     *)
    fun read fd count =  
        let
            val inbuf = ByteArray.empty 8
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = MarshallingHelp.n2w4 count inbuf 4

            val outbuf = ByteArray.empty (1 + 4 + count)

            val _ = #(fd_read) (ByteArray.to_string inbuf) outbuf
            val _ = FFIHelper.validate_status outbuf
            
            val n = MarshallingHelp.w42n outbuf 1
        in
            ByteArray.subarray outbuf 5 n
        end

    (**
     *  Write data into a file descriptor.
     *
     *  @param fd `int`: a descriptor to write data into.
     *  @param data `byte_array`: data to be written.
     *
     *  @returns `int`: actual number of bytes written.
     *
     *  @raises `FFIEagain` if file descriptor refers to nonblocking
     *      file and `write` syscall would block.
     *  @raises `FFIEintr` if `write` syscall was interrupted by a signal.
     *  @raises `FFIFailure` if any other error occured during the call.
     *)
    fun write fd (data : byte_array) =
        let
            val inbuf = ByteArray.empty (4 + Word8Array.length data)
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Word8Array.copy data 0 (Word8Array.length data) inbuf 4

            val outbuf = ByteArray.empty (1 + 4)
        in
            #(fd_write) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            MarshallingHelp.w42n outbuf 1
        end

    (**
     *  Put file descriptor into blocking/nonblocking mode.
     *
     *  @param fd `int`: a descriptor to put the mode.
     *  @param blocking `bool`: if true the descriptor will
     *      be put into blocking mode, otherwise the descriptor
     *      will be put into nonblocking mode.
     *
     *  @raises `FFIFailure` if `fcntl` syscall fails with an error.
     *)
    fun set_blocking (fd : int) (blocking : bool) =
        let
            val inbuf = ByteArray.empty 5
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Word8Array.update inbuf 4 (Word8.fromInt (if blocking then 1 else 0))
            
            val outbuf = ByteArray.empty 1
        in
            #(fd_set_blocking) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end
end
(*  The type emumerates operations that can be performed
 *  for the target file descriptor as a part of control interface
 *  for an epoll file descriptor. 
 *)
datatype epoll_op_code = EpollCtlAdd | EpollCtlMod | EpollCtlDel

(**
 *  Structure defines some helper functions to process
 *  epoll_op_code datatype.
 *)
structure EpollOpCode =
struct
    (* Number of bytes required to encode an op_code. *)
    val size = 1

    (* Returns an integer corresponding to the op_code. *)
    fun to_int code =
        case code of
            EpollCtlAdd => 0
          | EpollCtlMod => 1
          | EpollCtlDel => 2

    (* Returns a serialized op_code. *)
    fun to_bytes code = 
        Word8Array.array size (Word8.fromInt (to_int code))
end
(*  The type enumberates possible event types.
 *  Represents a single event type.
 *)
datatype epoll_event_enum = 
    Epollin | Epollout | Epollrdhup | Epollpri | Epollerr | Epollhup | Epollet | Epolloneshot

(**
 *  Structure defines functions that should be used to
 *  manipulate with epoll_event_enum type variables.
 *)
structure EpollEventEnum =
struct
    fun to_string ev =
        case ev of
            Epollin => "EPOLLIN"
          | Epollout => "EPOLLOUT"
          | Epollrdhup => "EPOLLRDHUP"
          | Epollpri => "EPOLLPRI"
          | Epollerr => "EPOLLERR"
          | Epollhup => "EPOLLHUP"
          | Epollet => "EPOLLET"
          | Epolloneshot => "EPOLLONESHOT"
    
    fun to_int ev =
        case ev of
            Epollin => 1
          | Epollout => 2
          | Epollrdhup => 4
          | Epollpri => 8
          | Epollerr => 16
          | Epollhup => 32
          | Epollet => 64
          | Epolloneshot => 128
end

(* The type represents a composition of single epoll events. *)
type epoll_events_mask = Word8.word

(**
 *  Structure defines functions that should be used to
 *  manipulate with epoll_events_mask type variables.
 *)
structure EpollEventsMask =
struct
    (* Number of bytes required to represent an epoll events mask type as a byte_array. *)
    val size = 1

    (* Initializes an empty epoll events mask. *)
    fun empty () = Word8.fromInt 0

    (**
     *  Adds a new event to the epoll events mask.
     *
     *  @param mask `epoll_events_mask`: mask an event should be added to.
     *  @param ev `epoll_event_enum`: the event that should be added.
     *
     *  @returns `epoll_events_mask`: updated mask.
     *)
    fun add (mask : epoll_events_mask) (ev : epoll_event_enum) = 
        Word8.orb mask (Word8.fromInt (EpollEventEnum.to_int ev))

    (**
     *  Removes an event from the epoll events mask. If an event is not
     *  in the mask the mask remains unchanged.
     *
     *  @param mask `epoll_events_mask`: mask an event should be removed from.
     *  @param ev `epoll_event_enum`: the event that should be removed.
     *
     *  @returns `epoll_events_mask`: updated mask.
     *)
    fun remove (mask : epoll_events_mask) (ev : epoll_event_enum) = 
        let
            val t = Word8.notb (Word8.fromInt (EpollEventEnum.to_int ev))
        in
            Word8.andb mask t
        end

    (**
     *  Check whether specified event is in the epoll events mask.
     *
     *  @param mask `epoll_events_mask`: mask presence of the event 
     *      should be checked in.
     *  @param ev `epoll_event_enum`: an event that should be checked.
     *
     *  @returns `bool`: true if the event is in the mask, or
     *      false otherwise.
     *)
    fun check (mask : epoll_events_mask) (ev : epoll_event_enum) =
        let
            val t = Word8.fromInt (EpollEventEnum.to_int ev)
        in
            Word8.toInt (Word8.andb mask t) > 0
        end

    (**
     *  Initializes a mask which consists of epoll events specified 
     *  which are in the list.
     *
     *  @param event_enums `epoll_event_enum list`: events that
     *      should be in the mask.
     *
     *  @returns `epoll_events_mask`: resultant mask.
     *)
    fun from_list (event_enums : epoll_event_enum list) =
        List.foldl add (empty ()) event_enums

    (**
     *  Represents an epoll events mask as a text value.
     *  Enumerates active events through a comma. If no event is in
     *  the maks, returns "{}".
     *)
    fun to_string (mask : epoll_events_mask) =
        let
            val event_types = [Epollin, Epollout, Epollrdhup, Epollpri, Epollerr, Epollhup, Epollet, Epolloneshot]
            val filtered_event_types = List.filter (check mask) event_types
            val str = String.concatWith ", " (List.map EpollEventEnum.to_string filtered_event_types)
        in
            "{" ^ str ^ "}"
        end

    (**
     *  Serializes an epoll events mask into a byte array.
     *
     *  @param mask `epoll_events_mask`: a mask to serialize.
     *
     *  @returns `byte_array`: serialized epoll events mask.
     *)
    fun to_bytes (mask : epoll_events_mask) =
        Word8Array.array 1 mask

    (**
     *  Deserializes a byte array into an epoll events mask.
     *
     *  @param b `byte_array`: data to be deserialized.
     *  @param i `int`: index in data which corresponds to the 
     *      beginnning of a serialized mask.
     *
     *  @returns `epoll_events_mask`: deserialized mask.
     *)
    fun from_bytes (b : byte_array) i =
        Word8Array.sub b i
end

(** 
 *  The type represents a pair consisting of a file descriptor and
 *  a corresponding epoll events mask, activated on the descriptor.
 *
 *  Is used to return events occurred for the corresponding file
 *  descriptor.
 *
 *  @param fd `int`: a file descriptor where events occurred.
 *  @param mask `epoll_events_mask`: a bit mask representing
 *      events happened on the descriptor.
 *)
datatype epoll_event = EpollEvent int epoll_events_mask

(**
 *  Structure defines functions that should be used to
 *  manipulate with epoll_event type variables.
 *)
structure EpollEvent =
struct
    val size = 4 + EpollEventsMask.size

    fun fd (EpollEvent fd _) = fd
    
    fun events (EpollEvent _ events) = events

    fun to_string (EpollEvent fd events) =
        "EpollEvent " ^ Int.toString fd ^ " " ^ EpollEventsMask.to_string events

    fun from_bytes (b : byte_array) (i : int) =
        EpollEvent (MarshallingHelp.w42n b i) (EpollEventsMask.from_bytes b (i + 4))
end
structure Epoll =
struct
    (*
     *  Initializes an epoll mechanism for further usage.
     *
     *  @returns `int` epoll file descriptor 
     * 
     *  @raises `FFIFailure` if `epoll_create` syscall fails.
     *)
    fun create () =
        let
            val inbuf = ""
            val outbuf = Word8Array.array (1 + 4) (Word8.fromInt 0)
        in
            #(epoll_create) inbuf outbuf;
            FFIHelper.validate_status outbuf;
            MarshallingHelp.w42n outbuf 1
        end

    (*
     *  Is used to add, modify, or remove entries in the
     *  interest list of the epoll instance.
     *
     *  @param op_code `epoll_op_code`: operation to be performed.
     *  @param epoll_fd `int`: the file descriptor referring to epoll
     *      instance.
     *  @param fd `int`: target file descriptor.
     *  @param events_mask `epoll_events_mask`: an epoll events mask 
     *      file descriptor should be linked with.
     *
     *  @raises `FFIFailure` if `epoll_ctl` syscall fails.
     *)
    fun ctl (op_code : epoll_op_code) (epoll_fd : int) 
            (fd : int) (events_mask : epoll_events_mask) =
        let
            val inbuf = ByteArray.empty (EpollOpCode.size + 4 + 4 + EpollEventsMask.size)
            val _ = Word8Array.copy (EpollOpCode.to_bytes op_code) 0 EpollOpCode.size inbuf 0
            val _ = MarshallingHelp.n2w4 epoll_fd inbuf EpollOpCode.size
            val _ = MarshallingHelp.n2w4 fd inbuf (EpollOpCode.size + 4)
            val _ = Word8Array.copy 
                (EpollEventsMask.to_bytes events_mask) 0 EpollEventsMask.size 
                inbuf (EpollOpCode.size + 4 + 4)

            val outbuf = ByteArray.empty 1
        in
            #(epoll_ctl) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (*
     *  Waits for events on the epoll instance.
     *
     *  @param epoll_fd `int`: file descriptor referring to 
     *      epoll instance.
     *  @param max_events `int`: the maximum number of file descriptors
     *      the function is allowed to return.
     *  @param timeout `int`: the number of milliseconds that
     *      the function will block. Specifying a timeuot of ~1
     *      causes wait to block indefinitely.
     *
     *  @returns `epoll_event list` a list with file descriptors and
     *      corresponding masks with events occurred on them.
     *
     *  @raises `FFIEintr` if the syscall was interrupted by a signal.
     *  @raises `FFIFailure` if `epoll_ctl` syscall fails.               
     *)
    fun wait (epoll_fd : int) (max_events : int) (timeout : int) = 
        let
            val inbuf = ByteArray.empty 16
            val _ =  MarshallingHelp.n2w4 epoll_fd inbuf 0
            val _ = MarshallingHelp.n2w4 max_events inbuf 4
            val _ = MarshallingHelp.n2w8 timeout inbuf 8

            val outbuf = ByteArray.empty (1 + 4 + max_events * EpollEvent.size)

            val _ = #(epoll_wait) (ByteArray.to_string inbuf) outbuf
            val _ = FFIHelper.validate_status outbuf

            val n_events = MarshallingHelp.w42n outbuf 1
        in
            MarshallingHelp.bytes_to_list
                (fn x => fn y => (EpollEvent.from_bytes x y, EpollEvent.size))
                n_events
                outbuf
                5
        end
end
structure Socket =
struct
    (**
     *  Creates an endpoint for communication and returns a file
     *  descriptor that refers to that endpoint.
     *
     *  @returns `int`: a file descriptor that refers to that endpoint.
     *
     *  @raises `FFIFailure` if `socket` syscall fails.
     *)
    fun create () =
        let
            val outbuf = ByteArray.empty (1 + 4)
        in
            #(socket_create) "" outbuf;
            FFIHelper.validate_status outbuf;
            MarshallingHelp.w42n outbuf 1
        end

    (**
     *  Initiate a connection on a socket reffered to
     *  by the file descriptor.
     *
     *  @param fd `int`: the file descriptor that refers to the socket.
     *  @param address `in_addr`: a IPv4 address where the socket 
     *      should initiate connection to.
     *  @param port `int`: a port number referring to the socket where connection 
     *      should be initiated to.
     * 
     *  @raises `FFIFailure` if connection syscalls fail.
     *  @raises `FFIEagain` if file descriptor refers to nonblocking
     *      socket and the connection cannot be completed immediately.
     *  @raises `FFIEintr` if `connect` syscall was interrupted by a signal.
     *)
    fun connect (fd : int) (address : in_addr) (port : int) =
        let
            val address_bytes = ByteArray.from_string (InAddr.to_string address)

            val inbuf = ByteArray.empty (4 + 2 + Word8Array.length address_bytes)
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Marshalling.n2w2 port inbuf 4
            val _ = Word8Array.copy address_bytes 0 (Word8Array.length address_bytes) inbuf 6
            
            val outbuf = ByteArray.empty 1
        in
            #(socket_connect) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Assigns the address to the socket referred to
     *  by the file descriptor.
     *
     *  @param fd `int`: the file descriptor that refers to the socket.
     *  @param address `in_addr`: a IPv4 address which the socket should be binded to.
     *  @param port `int`: a port number where the socket should be binded to.
     * 
     *  @raises `FFIFailure` if binding syscalls fail.
     *)
    fun bind (fd : int) (address : in_addr) (port : int) =
        let
            val address_bytes = ByteArray.from_string (InAddr.to_string address)

            val inbuf = ByteArray.empty (4 + 2 + Word8Array.length address_bytes)
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Marshalling.n2w2 port inbuf 4
            val _ = Word8Array.copy address_bytes 0 (Word8Array.length address_bytes) inbuf 6
            
            val outbuf = ByteArray.empty 1
        in
            #(socket_bind) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Mark the socket referred to the file descriptor
     *  as a listening socket.
     *
     *  @param fd `int`: the file descriptor referring to a socket
     *      to be listened.
     *  @param backlog `int`: the maximum length to which the
     *      queue of pending connections may grow.
     *
     *  @raises `FFIFailure` if `listen` syscall fails.
     *)
    fun listen (fd : int) (backlog : int) =
        let
            val inbuf = ByteArray.empty 8
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = MarshallingHelp.n2w4 backlog inbuf 4

            val outbuf = ByteArray.empty 1
        in
            #(socket_listen) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Accepts a new pending connection, creates a new connected socket,
     *  and returns a new file descriptor referring to that socket.
     *
     *  @oaram acceptor_fd `int`: a descriptor referring to listening socket.
     *
     *  @returns (int * in_addr * int): a descriptor referring to a new connected
     *      socket, IPv4 address and a port of the peer socket.
     *
     *  @raises `FFIFailure` if `accept` syscall fails.
     *  @raises `FFIEagain` if acceptor file descriptor refers to nonblocking
     *      socket and there is no more pending connections in the queue.
     *  @raises `FFIEintr` if `accept` syscall was interrupted by a signal.
     *)
    fun accept (acceptor_fd : int) = 
        let
            val inbuf = ByteArray.empty 4
            val _ = MarshallingHelp.n2w4 acceptor_fd inbuf 0

            val outbuf = ByteArray.empty 23
        in
            #(socket_accept) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            let
                val client_fd = MarshallingHelp.w42n outbuf 1
                val client_port = Marshalling.w22n outbuf 5
                val client_address_len = Word8.toInt (Word8Array.sub outbuf 7)
                val client_address = 
                    InAddr.from_string (Word8Array.substring outbuf 8 client_address_len)
            in
                (client_fd, client_address, client_port)
            end
        end

    (**
     *  Enables or disables TCP_NODELAY option for the specified socket.
     *  TCP_NODELAY option if set, disable the Nagle algorithm.
     *
     *  @param fd `int`: a file descriptor that refers to the socket.
     *  @param to_set `bool`: if True, the option is enabled; if False,
     *      the option is disabled.
     *
     *  @raises `FFIFailure` if `setsockopt` syscall fails.
     *)
    fun set_tcp_nodelay (fd : int) (to_set : bool) =
        let
            val inbuf = ByteArray.empty 5
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Word8Array.update inbuf 4 (Word8.fromInt (if to_set then 1 else 0))
            
            val outbuf = ByteArray.empty 1
        in
            #(socket_set_tcp_nodelay) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end
    
    (**
     *  Enables or disables SO_KEEPALIVE option for the specified socket.
     *  SO_KEEPALIVE option if set, enables sending of keep-alive messages,
     *  that in turn allow to detect if peer socket has been disconnected.
     *
     *  @param fd `int`: a file descriptor that refers to the socket.
     *  @param to_set `bool`: if True, the option is enabled; if False,
     *      the option is disabled.
     *
     *  @raises `FFIFailure` if `setsockopt` syscall fails.
     *)
    fun set_so_keepalive (fd : int) (to_set : bool) =
        let
            val inbuf = ByteArray.empty 5
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Word8Array.update inbuf 4 (Word8.fromInt (if to_set then 1 else 0))
            
            val outbuf = ByteArray.empty 1
        in
            #(socket_set_so_keepalive) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Sets value for TCP_KEEPIDLE option. The option sets
     *  the time (in seconds) the connection needs to remain idle
     *  before TCP starts sending keepalive probes, if the socket
     *  option SO_KEEPALIVE has been set on this socket.
     *
     *  @param fd `int`: a file descriptor that refers to the socket.
     *  @param value `int`: the time (in seconds).
     *
     *  @raises `FFIFailure` if `setsockopt` syscall fails.
     *)
    fun set_tcp_keepidle (fd : int) (value : int) =
        let
            val inbuf = ByteArray.empty 8
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = MarshallingHelp.n2w4 value inbuf 4

            val outbuf = ByteArray.empty 1
        in
            #(socket_set_tcp_keepidle) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Sets value for TCP_KEEPINTVL option. The option sets
     *  The time (in seconds) between individual keepalive probes.
     *
     *  @param fd `int`: a file descriptor that refers to the socket.
     *  @param value `int`: the time (in seconds).
     *
     *  @raises `FFIFailure` if `setsockopt` syscall fails.
     *)
    fun set_tcp_keepintvl (fd : int) (value : int) =
        let
            val inbuf = ByteArray.empty 8
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = MarshallingHelp.n2w4 value inbuf 4

            val outbuf = ByteArray.empty 1
        in
            #(socket_set_tcp_keepintvl) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Sets value for TCP_KEEPCNT option. The maximum number of 
     *  keepalive probes TCP should send before dropping the connection.
     *
     *  @param fd `int`: a file descriptor that refers to the socket.
     *  @param value `int`: the time (in seconds).
     *
     *  @raises `FFIFailure` if `setsockopt` syscall fails.
     *)
    fun set_tcp_keepcnt (fd : int) (value : int) =
        let
            val inbuf = ByteArray.empty 8
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = MarshallingHelp.n2w4 value inbuf 4

            val outbuf = ByteArray.empty 1
        in
            #(socket_set_tcp_keepcnt) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end

    (**
     *  Enables or disables SO_REUSEADDR option for the specified socket.
     *  Option if set, indicates that the rules used in validating addresses
     *  supplied in a bind(2) call should allow reuse of local addresses.
     *
     *  @param fd `int`: a file descriptor that refers to the socket.
     *  @param to_set `bool`: if True, the option is enabled; if False,
     *      the option is disabled.
     *
     *  @raises `FFIFailure` if `setsockopt` syscall fails.
     *)
    fun set_so_reuseaddr (fd : int) (to_set : bool) =
        let
            val inbuf = ByteArray.empty 5
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = Word8Array.update inbuf 4 (Word8.fromInt (if to_set then 1 else 0))
            
            val outbuf = ByteArray.empty 1
        in
            #(socket_set_so_reuseaddr) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end
end
structure Timer =
struct
    (**
     *  Creates a new timer that can be manipulated via a file descriptor.
     *
     *  @returns `int`: a file descriptor of the created timer.
     *
     *  @raises `FFIFailure` if `timerfd_create` syscall fails.
     *)
    fun create () =
        let
            val inbuf = ByteArray.empty 0
            val outbuf = ByteArray.empty (1 + 4)
        in
            #(timer_create) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            MarshallingHelp.w42n outbuf 1
        end
    
    (**
     *  Arms (starts) or disarms (stops) the timer
     *  referred to by the file descriptor \a fd.
     *
     *  @param fd `int`: a file descriptor that refers to the timer.
     *  @param initial `int`: a period of time in microseconds
     *      that the timer initially fires after.
     *  @param period `int`: a period of time in microseconds
     *      that the timer fires periodically after the first expiration.
     *
     *  @raises `FFIFailure` if `timerfd_settime` syscall fails.
     *)
    fun set_time (fd : int) (initial : int) (period : int) =
        let
            val inbuf = ByteArray.empty 20
            val _ = MarshallingHelp.n2w4 fd inbuf 0
            val _ = MarshallingHelp.n2w8 initial inbuf 4
            val _ = MarshallingHelp.n2w8 period inbuf 12

            val outbuf = ByteArray.empty 1
        in
            #(timer_set_time) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            ()
        end
end
(**
 *  Definition of a timestamp. 
 *)
type timestamp = int

(**  
 *  Structure that defines functions to work with
 *  time connected ffi calls.
 *)
structure Timestamp =
struct
    (**
     *  A function to get current timestamp.
     *
     *  @returns `int` timestamp in nanoseconds.
     *
     *  @raises `FFIFailure` if `clock_gettime` syscall fails.
     *)
    fun current () =
        let
            val outbuf = ByteArray.empty 9 (* First byte to save error status. 8 others to save the timestamp *)
        in
                #(get_timestamp) "" outbuf;
                FFIHelper.validate_status outbuf;
                MarshallingHelp.w82n outbuf 1
        end
end
(*  The type enumerates possible flags for file opening
 *  operation. Represents a single flag value.
 *)
datatype fopen_flag_enum = 
    FOpenNonblock | FOpenCloexec | FOpenRead | FOpenWrite | FOpenAppend | FOpenTrunc

(**
 *  Structure defines functions that should be used to
 *  manipulate with fopen_flag_enum type variables.
 *)
structure FOpenFlagEnum =
struct
    fun to_string flag =
        case flag of
            FOpenNonblock => "NONBLOCK"
          | FOpenCloexec => "CLOEXEC"
          | FOpenRead => "RD"
          | FOpenWrite => "WR"
          | FOpenAppend => "APPEND"
          | FOpenTrunc => "TRUNC"
    
    fun to_int flag =
        case flag of
            FOpenNonblock => 1
          | FOpenCloexec => 2
          | FOpenRead => 4
          | FOpenWrite => 8
          | FOpenAppend => 16
          | FOpenTrunc => 32
end

(* The type represents a composition of fopen flags. *)
type fopen_flags_mask = Word8.word

(**
 *  Structure defines functions that should be used to
 *  manipulate with fopen_flags_mask type variables.
 *)
structure FOpenFlagsMask =
struct
    (* Number of bytes required to represent an fopen_flags_mask type as a byte_array. *)
    val size = 1

    (* Initializes an empty mask. *)
    fun empty () = Word8.fromInt 0

    (**
     *  Adds a new flag to the mask.
     *
     *  @param mask `fopen flags_mask`: mask the flag should be added to.
     *  @param flag `fopen_flag_enum`: the flag that should be added.
     *
     *  @returns `fopen_flags_mask`: updated mask.
     *)
    fun add (mask : fopen_flags_mask) (flag : fopen_flag_enum) = 
        Word8.orb mask (Word8.fromInt (FOpenFlagEnum.to_int flag))

    (**
     *  Removes a flag from the mask. If the flag is not
     *  in the mask the mask remains unchanged.
     *
     *  @param mask `fopen_flags_mask`: mask the flag should be removed from.
     *  @param flag `fopen_flag_enum`: the flag that should be removed.
     *
     *  @returns `fopen_flags_mask`: updated mask.
     *)
    fun remove (mask : fopen_flags_mask) (flag : fopen_flag_enum) = 
        let
            val t = Word8.notb (Word8.fromInt (FOpenFlagEnum.to_int flag))
        in
            Word8.andb mask t
        end

    (**
     *  Check whether specified flag is in the mask.
     *
     *  @param mask `fopen_flags_mask`: mask presence of the flag 
     *      should be checked in.
     *  @param flag `fopen_flag_enum`: the flag that should be checked.
     *
     *  @returns `bool`: true if the flag is in the mask, or
     *      false otherwise.
     *)
    fun check (mask : fopen_flags_mask) (flag : fopen_flag_enum) =
        let
            val t = Word8.fromInt (FOpenFlagEnum.to_int flag)
        in
            Word8.toInt (Word8.andb mask t) > 0
        end

    (**
     *  Initializes a mask which consists of flags
     *  specified in the list.
     *
     *  @param enums `fopen_flag_enum list`: flags that
     *      should be in the mask.
     *
     *  @returns `fopen_flags_mask`: resultant mask.
     *)
    fun from_list (enums : fopen_flag_enum list) =
        List.foldl add (empty ()) enums

    (**
     *  Represents a mask as a text value.
     *  Enumerates active flags through a comma. If no flags are in
     *  the maks, returns "{}".
     *)
    fun to_string (mask : fopen_flags_mask) =
        let
            val flag_types = [FOpenNonblock, FOpenCloexec, FOpenRead, FOpenWrite, FOpenAppend, FOpenTrunc]
            val filtered_flag_types = List.filter (check mask) flag_types
            val str = String.concatWith ", " (List.map FOpenFlagEnum.to_string filtered_flag_types)
        in
            "{" ^ str ^ "}"
        end

    (**
     *  Serializes a mask into a byte array.
     *
     *  @param mask `fopen_flags_mask`: a mask to serialize.
     *
     *  @returns `byte_array`: serialized fopen flags mask.
     *)
    fun to_bytes (mask : fopen_flags_mask) =
        Word8Array.array 1 mask

    (**
     *  Deserializes a byte array into an fopen flags mask.
     *
     *  @param b `byte_array`: data to be deserialized.
     *  @param i `int`: index in data which corresponds to the 
     *      beginnning of a serialized mask.
     *
     *  @returns `fopen_flags_mask`: deserialized mask.
     *)
    fun from_bytes (b : byte_array) i =
        Word8Array.sub b i
end

(* Structure for handling file FFI calls *)
structure File =
struct
    (*
     *  Opens a file.
     *
     *  @param path `string`: path to the file to open
     *  @param flags_mask `fopen_flags_mask`: flags the 
     *      file should be opened with.
     *
     *  @returns `int` file descriptor referring to opened file.
     * 
     *  @raises `FFIFailure` if `open` syscall fails.
     *)
    fun fopen (path : string) (flags_mask : fopen_flags_mask) = 
        let
            val path_len = String.size path

            val inbuf = ByteArray.empty (FOpenFlagsMask.size + path_len)
            val _ = Word8Array.copy (FOpenFlagsMask.to_bytes flags_mask) 0 FOpenFlagsMask.size inbuf 0
            val _ = Word8Array.copy (ByteArray.from_string path) 0 path_len inbuf FOpenFlagsMask.size

            val outbuf = ByteArray.empty (1 + 4)
        in
            #(file_open) (ByteArray.to_string inbuf) outbuf;
            FFIHelper.validate_status outbuf;
            MarshallingHelp.w42n outbuf 1
        end
end
type timestamp = int

structure Time =
struct
    local
        (**
         *  Divide a value on (10^exp) and round the resultant
         *  value using the usual mathematical rounding rules.
         *)
        fun div_and_round value exp =
            let
                val divisor = funpow (Int.* 10) exp 1
                val rem = Int.mod value divisor
                val quot = Int.div value divisor
            in
                if rem < Int.div divisor 2
                then quot
                else quot + 1
            end
    in
        (**
         *  Returns current timestamp in nanoseconds.
         *
         *  @raises `FFIFailure` if syscall to get timestamp fails.
         *)
        fun current_nsec () = Timestamp.current ()

        (**
         *  Returns current timestamp in microseconds.
         *
         *  @raises `FFIFailure` if syscall to get timestamp fails.
         *)
        fun current_mcsec () = div_and_round (Timestamp.current ()) 3

        (**
         *  Returns current timestamp in milliseconds.
         *
         *  @raises `FFIFailure` if syscall to get timestamp fails.
         *)
        fun current_msec () = div_and_round (Timestamp.current ()) 6

        (**
         *  Returns current timestamp in seconds.
         *
         *  @raises `FFIFailure` if syscall to get timestamp fails.
         *)
        fun current_sec () = div_and_round (Timestamp.current ()) 9
    end

    fun current () = current_mcsec ()
end
(**
 *  Is raised when there is no more space left in the
 *  provided buffer, but there is still data to read 
 *  in the kernel.
 *)
exception IOBufferOverflow

(**
 *  Is raised for pipes and FIFOs when trying to read,
 *  when there is no one writing to the other side.
 *  For sockets is raised when trying to read,
 *  when the other side closed its connection.
 *)
exception IOEndOfFile

(**
 *  Structure defines functions to make input and output
 *  operations with the kernel buffer.
 *)
structure IO =
struct
    (**
     *  Reads in a data from a non-blocking FD while data are avai-
     *  lable into a provided buffer. After every return from a `read`
     *  syscall read_handler is called, and used number of bytes are
     *  consumed from the buffer.
     *
     *  @param reactor `'a reactor`: a reactor that should be passed as an
     *      argument into the read_handler.
     *  @param fd `int`: a file descriptor to read data from.
     *  @param buff `io_buffer`: a buffer where data should be read into.
     *  @param on_read `'a reactor -> int -> io_buffer -> 'a reactor * int`: 
     *      a callback function that is called when new data is read.
     *  @param has_fd_info `'a reactor -> int -> bool`: a function checking
     *      whether the file descriptor is still in the reactor.
     *
     *  @param returns `('a reactor * int, 'a reactor * int * exn) result`:
     *      if no error occurs, returns Ok consisting of a new reactor
     *      and number of bytes read. If any error occurs, returns Error consisting
     *      of reactor state and number of bytes read before the error,
     *      as well as an exception according to the error: `FFIFailure`, 
     *      `IOBufferOverflow`, or `IOEndOfFile`.
     *)
    fun read_until_eagain reactor (fd : int) (buff : io_buffer) on_read has_fd_info =
        let
            fun internal reactor (n_total : int) =
                if 
                    not (has_fd_info reactor fd)
                then
                    (* The descriptor has been removed from the reactor somewhere
                     * during read_handler processing of income data. Stop reading
                     * the data and return current reactor state. We do not cosider
                     * that as an error. *)
                    Ok (reactor, n_total)
                else
                let
                    val space = IOBuffer.capacity buff

                    val (data, status) = (Fd.read fd space, FFICodes.success)
                    handle
                        FFIEagain => (ByteArray.empty 0, FFICodes.eagain)
                      | FFIEintr => (ByteArray.empty 0, FFICodes.eintr)
                      | FFIFailure => (ByteArray.empty 0, FFICodes.failure)
                in
                    if 
                        status = FFICodes.success
                    then (
                        if 
                            space = 0 
                        then
                            (*  As space was 0, and the `read` call did not return EAGAIN,
                             *  there is still data in the buffer that may be read, but cannot
                             *  as buffer is overflowed.
                             *) 
                            Error (reactor, n_total, IOBufferOverflow)
                        else if 
                            Word8Array.length data = 0
                        then
                            (*  As the space was greater than zero, but the `read` syscall read
                             *  zero bytes, the other side of the descriptor was closed.
                             *)
                            Error (reactor, n_total, IOEndOfFile)
                        else (
                            IOBuffer.write buff data;
                            let
                                val (new_reactor, consumed) = on_read reactor fd buff
                            in
                                (* If some data has been consumed, remove it from the buffer and
                                 * crunch it if size left is less than lower watermark. *)
                                if consumed > 0
                                then IOBuffer.consume_and_crunch buff consumed
                                else ();
                                
                                (* There is still data available to be read. *)
                                internal new_reactor (n_total + Word8Array.length data)
                            end
                        )
                    ) else if
                        status = FFICodes.eagain
                    then (* No more data available - return the total amount read. *)
                        Ok (reactor, n_total)
                    else if 
                        status = FFICodes.eintr
                    then (* The syscall was interrupted. No data has been read. Try again. *)
                        internal reactor n_total
                    else (* Any other error occurred while reading. *)
                        Error (reactor, n_total, FFIFailure)
                end
        in
            internal reactor 0
        end

    fun write_until_eagain (fd : int) (data : byte_array) (buff : io_buffer) =
        let
            val chunk_size = 1024 * 1024 (* Write maximum 1Mb of data at one call. *)

            val initial_buff_size = IOBuffer.size buff
            val data_size = Word8Array.length data

            fun write_into_buffer (buff : io_buffer) (data : byte_array) = (
                (* If there is enough space inside the buffer,
                 * save data inside. If not, raise corresponding exception. *)
                if IOBuffer.size buff < Word8Array.length data
                then raise IOBufferOverflow
                else IOBuffer.write buff data
            )

            fun write_buffer (buff : io_buffer) =
                if IOBuffer.empty buff
                then Ok ()
                else
                    let
                        val data = IOBuffer.read buff (min chunk_size (IOBuffer.size buff))
                        val res = Ok (Fd.write fd data)
                        handle exn => Error exn
                    in
                        case res of
                            Ok n => (
                                IOBuffer.consume_and_crunch buff n;
                                write_buffer buff
                            )
                          | Error FFIEintr => 
                                (* The syscall was interrupted. Try writing again. *)
                                write_buffer buff
                          | Error e => Error e (* FFIEagain or FFIFailure. *)
                    end

            fun write_data (data : byte_array) n_total =
                let
                    val rem = Word8Array.length data - n_total
                in
                    if rem = 0
                    then ()
                    else
                        let
                            val to_write = ByteArray.subarray data n_total (min rem chunk_size)
                            val res = Ok (Fd.write fd to_write)
                            handle exn => Error exn
                        in
                            case res of
                                Ok n => write_data data (n_total + n)
                              | Error FFIEintr => write_data data n_total
                              | Error FFIEagain =>
                                    (* We cannot write remaining data. Save it 
                                     * into the buffer. *)
                                    write_into_buffer buff (ByteArray.subarray data n_total rem)
                              | Error FFIFailure => raise FFIFailure

                        end
                end

            val write_buffer_res = write_buffer buff
        in
            case write_buffer_res of
                Ok () => write_data data 0
              | Error FFIEagain => (
                    (* We cannot write data right now. Just 
                     * save it into the buffer *)
                    write_into_buffer buff data
                )
              | Error FFIFailure => raise FFIFailure;
            
            (* Calculate how many bytes have been written. *)
            (initial_buff_size + data_size) - (IOBuffer.size buff)
        end
end

local
    fun exn_printer e =
        case e of
            IOBufferOverflow => "IOBufferOverflow"
          | IOEndOfFile => "IOEndOfFile"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
datatype 'a reactor_function_request = 
    AddReadDataStream string 
        ('a read_handler) ('a connect_handler option)
        ('a err_handler) int int (in_addr option)
        ('a -> int -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddExistingReadDataStream string int
        ('a read_handler) ('a err_handler) int int
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddWriteDataStream string
        ('a connect_handler option) ('a err_handler)
        int int (in_addr option)
        ('a -> int -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddExistingWriteDataStream string int
        ('a err_handler) int int
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddReadWriteDataStream string
        ('a read_handler) ('a connect_handler option)
        ('a err_handler) int int int int (in_addr option)
        ('a -> int -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddExistingReadWriteDataStream string int
        ('a read_handler) ('a err_handler) int int int int
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | Connect int sockaddr_in
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddAcceptor string ('a accept_handler)
        ('a err_handler) (sockaddr_in) int
        ('a -> int -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddTimer string int int
        ('a timer_handler)
        ('a err_handler)
        ('a -> int -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | SetTimer int int int
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddReadFile string int
        ('a read_handler) ('a err_handler) int int
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | AddWriteFile string int
        ('a err_handler) int int
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | Write int byte_array
        ('a -> 'a * 'a reactor_function_request option)
        ('a -> int -> 'a * 'a reactor_function_request option)
  | Remove int
        ('a -> 'a * 'a reactor_function_request option)
  | ExitRun

(** 
 *  The file defines event handlers: function signatures which callback functions
 *  provided by client applications should correspond to. 
 *  
 *  `'a` is actually a parametric reactor type `('b reactor)` which will be defined later 
 *)

(**
 *  An event handler that is called when any readability event
 *  occurs at socket or file.
 *
 *  @param reactor `'b reactor`: current reactor state.
 *  @param fd `int`: file descriptor where event occured at.
 *  @param data `io_buffer`: a buffer with the data read from the descriptor.
 *
 *  @returns number of bytes that has been used from the incoming data.
 *)
and 'a read_handler = ReadHandler ('a -> int -> io_buffer -> 'a * int * 'a reactor_function_request option)

(**
 *  An event handler that is called when a socket is connected.
 *
 *  @param reactor `'b reactor`: current reactor state.
 *  @param fd `int`: file descriptor where event occured at.
 *)
and 'a connect_handler = ConnectHandler ('a -> int -> 'a * 'a reactor_function_request option)

(**
 *  An event handler that is called when a listening socket 
 *  accepts a new connection.
 *
 *  @param reactor `'b reactor`: current reactor state.
 *  @param acceptor_fd `int`: file descriptor where event occured at.
 *  @param client_fd `int`: file descriptor which was associated with new connection.
 *  @param clint_addr `sockaddr_in`: an address of the connected client 
 *      (IPv4 address and port number).
 *)
and 'a accept_handler = AcceptHandler ('a -> int -> int -> sockaddr_in -> 'a * 'a reactor_function_request option)

(**
 *  An event handler that is called when a timer fires.
 *
 *  @param reactor `'b reactor`: current reactor state.
 *  @param fd `int`: file descriptor where event occured at.
 *  @param count `int`: number of expirations occurred.
 *)
and 'a timer_handler = TimerHandler ('a -> int -> int -> 'a * 'a reactor_function_request option)

(**
 *  An event handler that is called if any error occured 
 *  at the descriptor or during another event processing.
 *
 *  @param reactor `'b reactor`: current reactor state.
 *  @param fd `int`: file descriptor where error occured at.
 *  @param errno `int`: error number of occuring error.
 *      If error is connected with FFI calls, the number is 
 *      positive. Is '0' if error was returned from an `epoll_wait`.
 *      Is '~1' if error raised was referred to `IOBufferOverflow`.
 *      Is `~2` if error raised was referred to `IOEndOfFile`.
 *  (* @param events_mask `int`: the last mask that was obtained from
 *      `epoll_wait`, which used in event handling. In general may be useful
 *      if errno equals zero, what means that the error was obtained as
 *      an `epoll_wait` event. *) - FROZEN FOR NOW
 *)
and 'a err_handler = ErrHandler ('a -> int -> int -> 'a * 'a reactor_function_request option)

(**
 *  An event handler that is called after each successful iteration
 *  of the poll cycle.
 *
 *  @param reactor `'a`: application state.
 *)
 datatype 'a poll_handler = PollHandler ('a -> 'a * 'a reactor_function_request option)
(**  
 *  The type enumerates all possible types of file descriptors 
 *  and defines internal representations for each of the type.
 *  
 *  As in event handlers, `'a` is actually a parametric reactor type
 *  `'b reactor` which will be defined later, and where `'b` is defined
 *  by a client application and represents its internal state.
 *
 *  ReadWriteFileFdInfo is not defined as only pipes and FIFOs may be
 *  added into the polling mechanism. Both types of files can be opened
 *  either in read or write modes, but never in both.
 *)
datatype 'a fd_info =
    (*  ReadDataStreamInfo - constructor represents data streams (sockets)
     *  which can be read, but cannot be written:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_read `'a read_handler`: a concrete event handler 
     *          to be called back when new data is read.
     *      @param on_connect_opt `'a connect_handler option`: a concrete event 
     *          handler to be called back when a connection is established.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *      @param rd_buff `io_buffer`: a buffer where arrived data is stored 
     *          from the kernel buffer.
     *      @param is_connecting `bool`: a flag indicating whether the connection
     *          is in the proccess of establishment on the underlying socket.
     *      @param is_connected `bool`: a flag indicating whether the connection
     *          has been established on the underlying socket.
     *)
    ReadDataStreamFdInfo string int 
        ('a read_handler) ('a connect_handler option) ('a err_handler) io_buffer bool bool

    (*  WriteDataStreamInfo - constructor represents data streams (sockets)
     *  which can be written, but cannot be read:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_connect_opt `'a connect_handler option`: a concrete event 
     *          handler to be called back when a connection is established.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *      @param wr_buff `io_buffer`: a buffer where not sent data is stored.
     *      @param is_connecting `bool`: a flag indicating whether the connection
     *          is in the proccess of establishment on the underlying socket.
     *      @param is_connected `bool`: a flag indicating whether the connection
     *          has been established on the underlying socket.
     *)
  | WriteDataStreamFdInfo string int
        ('a connect_handler option) ('a err_handler) io_buffer bool bool

    (*  ReadWriteDataStreamInfo - constructor represents data streams (sockets)
     *  which can be both read and written:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_read `'a read_handler`: a concrete event handler 
     *          to be called back when new data is read.
     *      @param on_connect_opt `'a connect_handler option`: a concrete event 
     *          handler to be called back when a connection is established.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *      @param rd_buff `io_buffer`: a buffer where arrived data is stored 
     *          from the kernel buffer.
     *      @param wr_buff `io_buffer`: a buffer where not sent data is stored.
     *      @param is_connecting `bool`: a flag indicating whether the connection
     *          is in the proccess of establishment on the underlying socket.
     *      @param is_connected `bool`: a flag indicating whether the connection
     *          has been established on the underlying socket.
     *)
  | ReadWriteDataStreamFdInfo string int 
        ('a read_handler) ('a connect_handler option) ('a err_handler) 
        io_buffer io_buffer bool bool

    (*  TimerFdInfo - constructor represents file descriptors that 
     *  corresponds to timers:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_timer `'a timer_handler`: a concrete event handler
     *          to be called back when the timer fires.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *      @param rd_buff `io_buffer`: a buffer where a number of expirations
     *          is read to. According to documentation, timer returns an 
     *          unsigned 8-byte integer containing the number of expirations
     *          that have occurred. If supplied buffer is less than 8 bytes 
     *          read operation fails with EINVAL. Thus, the buffer size should
     *          have at least 9 bytes to work properly.
     *)
  | TimerFdInfo string int ('a timer_handler) ('a err_handler) io_buffer

    (*  AcceptorFdInfo - constructor represents file descriptors that 
     *  corresponds to listening sockets:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_accept `'a accept_handler`: a concrete event handler
     *          to be called back when a new connection is accepted.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *)
  | AcceptorFdInfo string int ('a accept_handler) ('a err_handler)

    (*  ReadFileFdInfo - constructor represents file descriptors that 
     *  corresponds to files opened in read only mode:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_read `'a read_handler`: a concrete event handler 
     *          to be called back when new data is read.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *      @param rd_buff `io_buffer`: a buffer where read data is stored.
     *)
  | ReadFileFdInfo string int ('a read_handler) ('a err_handler) io_buffer

    (*  WriteFileFdInfo - constructor represents file descriptors that 
     *  corresponds to files opened in read only mode:
     *      @param name `string`: client defined name of the descriptor.
     *      @param fd `int`: file descriptor.
     *      @param on_err `'a err_handler`: a concrete event handler
     *          to be called back when any error occurs on the descriptor.
     *      @param wr_buff `io_buffer`: a buffer where not written data is stored.
     *)
  | WriteFileFdInfo string int ('a err_handler) io_buffer

(**
 *  Structure defines getters and setters for variables in fd_info representation.
 *)
structure FdInfoType =
struct
    (**
     *  Internal exception that is raised if the request cannot be
     *  executed on the corresponding type.
     *)
    exception InvalidType

    fun get_handler_type fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ _ _ _ _) => "ReadDataStream"
          | (WriteDataStreamFdInfo _ _ _ _ _ _ _) => "WriteDataStream"
          | (ReadWriteDataStreamFdInfo _ _ _ _ _ _ _ _ _) => "ReadWriteDataStream"
          | (TimerFdInfo _ _ _ _ _) => "Timer"
          | (AcceptorFdInfo _ _ _ _) => "Acceptor"
          | (ReadFileFdInfo _ _ _ _ _) => "ReadFile"
          | (WriteFileFdInfo _ _ _ _) => "WriteFile"


    fun get_name fd_info =  
        case fd_info of
            (ReadDataStreamFdInfo name _ _ _ _ _ _ _) => name
          | (WriteDataStreamFdInfo name _ _ _ _ _ _) => name
          | (ReadWriteDataStreamFdInfo name _ _ _ _ _ _ _ _) => name
          | (TimerFdInfo name _ _ _ _) => name
          | (AcceptorFdInfo name _ _ _) => name
          | (ReadFileFdInfo name _ _ _ _) => name
          | (WriteFileFdInfo name _ _ _) => name

    fun get_fd fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ fd _ _ _ _ _ _) => fd
          | (WriteDataStreamFdInfo _ fd _ _ _ _ _) => fd
          | (ReadWriteDataStreamFdInfo _ fd _ _ _ _ _ _ _) => fd
          | (TimerFdInfo _ fd _ _ _) => fd
          | (AcceptorFdInfo _ fd _ _) => fd
          | (ReadFileFdInfo _ fd _ _ _) => fd
          | (WriteFileFdInfo _ fd _ _) => fd

    fun get_err_handler fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ on_err _ _ _) => on_err
          | (WriteDataStreamFdInfo _ _ _ on_err _ _ _) => on_err
          | (ReadWriteDataStreamFdInfo _ _ _ _ on_err _ _ _ _) => on_err
          | (TimerFdInfo _ _ _ on_err _) => on_err
          | (AcceptorFdInfo _ _ _ on_err) => on_err
          | (ReadFileFdInfo _ _ _ on_err _) => on_err
          | (WriteFileFdInfo _ _ on_err _) => on_err

    fun get_read_handler fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ on_read _ _ _ _ _) => on_read
          | (ReadWriteDataStreamFdInfo _ _ on_read _ _ _ _ _ _) => on_read
          | (ReadFileFdInfo _ _ on_read _ _) => on_read
          | _ => raise InvalidType

    fun get_connect_handler_opt fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ on_connect_opt _ _ _ _) => on_connect_opt
          | (WriteDataStreamFdInfo _ _ on_connect_opt _ _ _ _) => on_connect_opt
          | (ReadWriteDataStreamFdInfo _ _ _ on_connect_opt _ _ _ _ _) => on_connect_opt
          | _ => raise InvalidType

    fun get_timer_handler fd_info =
        case fd_info of
            (TimerFdInfo _ _ on_timer _ _) => on_timer
          | _ => raise InvalidType

    fun get_accept_handler fd_info =
        case fd_info of
            (AcceptorFdInfo _ _ on_accept _) => on_accept
          | _ => raise InvalidType

    fun get_rd_buff fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ _ rd_buff _ _) => rd_buff
          | (ReadWriteDataStreamFdInfo _ _ _ _ _ rd_buff _ _ _) => rd_buff
          | (ReadFileFdInfo _ _ _ _ rd_buff) => rd_buff
          | (TimerFdInfo _ _ _ _ rd_buff) => rd_buff
          | _ => raise InvalidType

    fun get_wr_buff fd_info =
        case fd_info of
            (WriteDataStreamFdInfo _ _ _ _ wr_buff _ _) => wr_buff
          | (ReadWriteDataStreamFdInfo _ _ _ _ _ _ wr_buff _ _) => wr_buff
          | (WriteFileFdInfo _ _ _ wr_buff) => wr_buff
          | _ => raise InvalidType

    fun get_is_connecting_status fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ _ _ is_connecting _) => is_connecting
          | (WriteDataStreamFdInfo _ _ _ _ _ is_connecting _) => is_connecting
          | (ReadWriteDataStreamFdInfo _ _ _ _ _ _ _ is_connecting _) => is_connecting
          | _ => raise InvalidType
    fun set_is_connecting_status fd_info is_connecting =
        case fd_info of
            (ReadDataStreamFdInfo name fd on_read on_connect on_err rd_buff _ is_connected) => 
                (ReadDataStreamFdInfo name fd on_read on_connect on_err rd_buff is_connecting is_connected)
          | (WriteDataStreamFdInfo name fd on_connect on_err wr_buff _ is_connected) =>
                (WriteDataStreamFdInfo name fd on_connect on_err wr_buff is_connecting is_connected)
          | (ReadWriteDataStreamFdInfo name fd on_read on_connect on_err rd_buff wr_buff _ is_connected) => 
                (ReadWriteDataStreamFdInfo name fd on_read on_connect on_err rd_buff wr_buff is_connecting is_connected)
          | _ => raise InvalidType

    fun get_is_connected_status fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ _ _ _ is_connected) => is_connected
          | (WriteDataStreamFdInfo _ _ _ _ _ _ is_connected) => is_connected
          | (ReadWriteDataStreamFdInfo _ _ _ _ _ _ _ _ is_connected) => is_connected
          | _ => raise InvalidType
    fun set_is_connected_status fd_info is_connected =
        case fd_info of
            (ReadDataStreamFdInfo name fd on_read on_connect on_err rd_buff is_connecting _) => 
                (ReadDataStreamFdInfo name fd on_read on_connect on_err rd_buff is_connecting is_connected)
          | (WriteDataStreamFdInfo name fd on_connect on_err wr_buff is_connecting _) =>
                (WriteDataStreamFdInfo name fd on_connect on_err wr_buff is_connecting is_connected)
          | (ReadWriteDataStreamFdInfo name fd on_read on_connect on_err rd_buff wr_buff is_connecting _) => 
                (ReadWriteDataStreamFdInfo name fd on_read on_connect on_err rd_buff wr_buff is_connecting is_connected)
          | _ => raise InvalidType

    fun is_data_stream fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ _ _ _ _) => True
          | (WriteDataStreamFdInfo _ _ _ _ _ _ _) => True
          | (ReadWriteDataStreamFdInfo _ _ _ _ _ _ _ _ _) => True
          | _ => False
    
    fun is_read_data_stream fd_info =
        case fd_info of
            (ReadDataStreamFdInfo _ _ _ _ _ _ _ _) => True
          | _ => False
    
    fun is_write_data_stream fd_info =
        case fd_info of
            (WriteDataStreamFdInfo _ _ _ _ _ _ _) => True
          | _ => False
    
    fun is_read_write_data_stream fd_info =
        case fd_info of
            (ReadWriteDataStreamFdInfo _ _ _ _ _ _ _ _ _) => True
          | _ => False

    fun is_timer fd_info = 
        case fd_info of
            (TimerFdInfo _ _ _ _ _) => True
          | _ => False
    
    fun is_acceptor fd_info =
        case fd_info of
            (AcceptorFdInfo _ _ _ _) => True
          | _ => False
    
    fun is_file fd_info =
        case fd_info of
            (ReadFileFdInfo name _ _ _ _) => True
          | (WriteFileFdInfo name _ _ _) => True
          | _ => False
    
    fun is_read_file fd_info =
        case fd_info of
            (ReadFileFdInfo name _ _ _ _) => True
          | _ => False

    fun is_write_file fd_info =
        case fd_info of
            (WriteFileFdInfo name _ _ _) => True
          | _ => False
end

local
    fun exn_printer e =
        case e of
            FdInfoType.InvalidType => "FdInfoType.InvalidType"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
(**
 *  The type defines internal representation of the reactor.
 *
 *  @param state_ref `'a ref`: a parametric value that keeps a reference
 *      to a client application state.
 *  @param logger `logger`.
 *  @param poll_fd `int`: the file descriptor corresponding to the epoll mechanism.
 *  @param fds_ref `(int, ('a reactor) fd_info) map ref`: a reference to a map from 
 *      file descriptors to corresponding fd_info structures. Reference is used
 *      in order to keep the reactor consistent with epoll mechanism.
 *  @param is_closed_ref `bool ref`: indicates whether the reactor has been closed. If is true,
 *      then the reactor was fully cleared and cannot be further operated.
 *  @param on_poll `'a poll_handler`: the handler that would be called after each
 *      iteration of poll function.
 *)
datatype 'a reactor = Reactor ('a ref) logger int ((int, 'a fd_info) map ref) (bool ref) ('a poll_handler)

(**
 *  Is raised to stop the reactor and exit from the run function.
 *  There is currently no other way of exiting from the "Run" infinite loop
 *  but to throw the following exception; so this is NOT actually an error condition!
 *)
exception ReactorExitRun

(**
 *  Is raised if any FFI call returns an error.
 *
 *  @param errno `int`: error number set by syscall. 
 *)
exception ReactorSystemError int

(**
 *  Is raised if a client application call some reactor 
 *  function with improper parameters.
 *)
exception ReactorBadArgumentError

(**
 *  Structure defines getters and setters for variables in reactor representation.
 *)
structure ReactorType =
struct
    fun get_state (Reactor state_ref _ _ _ _ _) = (!state_ref)
    fun get_logger (Reactor _ logger _ _ _ _) = logger
    fun get_epoll_fd (Reactor _ _ epoll_fd _ _ _) = epoll_fd
    fun get_fds (Reactor _ _ _ fds_ref _ _) = (!fds_ref)
    fun get_is_closed (Reactor _ _ _ _ is_closed_ref _) = (!is_closed_ref)
    fun get_poll_handler (Reactor _ _ _ _ _ on_poll) = on_poll

    fun set_state (Reactor state_ref _ _ _ _ _) state = 
        state_ref := state
    fun set_logger (Reactor state_ref _ epoll_fd fds_ref is_closed_ref on_poll) logger = 
        Reactor state_ref logger epoll_fd fds_ref is_closed_ref on_poll
    fun set_epoll_fd (Reactor state_ref logger _ fds_ref is_closed_ref on_poll) epoll_fd =
        Reactor state_ref logger epoll_fd fds_ref is_closed_ref on_poll
    fun set_fds (Reactor _ _ _ fds_ref _ _) fds =
        fds_ref := fds
    fun set_is_closed (Reactor _ _ _ _ is_closed_ref _) is_closed =
        is_closed_ref := is_closed
    fun set_poll_handler (Reactor state_ref logger epoll_fd fds_ref is_closed_ref _) on_poll =
        Reactor state_ref logger epoll_fd fds_ref is_closed_ref on_poll

    (* Returns fd info if specified descriptor exists in the reactor. *)
    fun get_fd_info_opt reactor fd =
        Map.lookup (get_fds reactor) fd

    (* Returns whether specified descriptor exists in the reactor. *)
    fun has_fd_info reactor fd =
        Option.isSome (get_fd_info_opt reactor fd)

    (* Adds a new fd_info into the reactor or updates the existing one. *)
    fun add_fd_info reactor fd_info =
        let
            val fd = FdInfoType.get_fd fd_info
        in
            set_fds reactor (Map.insert (get_fds reactor) fd fd_info)
        end

    (* Removes fd_info from the reactor internal structure. *)
    fun remove_fd_info reactor fd =
        set_fds reactor (Map.delete (get_fds reactor) fd)
end

structure ReactorPrivate =
struct
    fun raise_reactor_system_error (before_f : int -> unit) (errno_opt : int option) =
        let
            val errno = case errno_opt of Some e => e | None => (Errno.errno ())
        in
            before_f errno;
            raise ReactorSystemError errno
        end

    (* Initializes the reactor. *)
    fun init state logger epoll_fd on_poll =
        Reactor (Ref state) logger epoll_fd (Ref (Map.empty Int.compare)) (Ref False) on_poll

    (* Returns whether an events returned by epoll include
     * any event corresponding to error. *)
    fun is_error (events_mask : epoll_events_mask) =
        EpollEventsMask.check events_mask Epollerr orelse 
        EpollEventsMask.check events_mask Epollhup orelse
        EpollEventsMask.check events_mask Epollrdhup

    (* Returns whether an events returned by epoll include readability event. *)
    fun is_readable (events_mask : epoll_events_mask) =
        EpollEventsMask.check events_mask Epollin

    (* Returns whether an events returned by epoll include writability event. *)
    fun is_writable (events_mask : epoll_events_mask) =
        EpollEventsMask.check events_mask Epollout

    fun fd_info_is_writable fd_info = (
        FdInfoType.is_write_data_stream fd_info
            orelse 
        FdInfoType.is_read_write_data_stream fd_info
            orelse
        FdInfoType.is_write_file fd_info
    )

    fun should_fd_info_be_closed fd_info =
        not (
            FdInfoType.is_read_file fd_info orelse FdInfoType.is_write_file fd_info
        )

    (*
     *  Closes a specified file descriptor. If closing retunrs an error,
     *  a warning is logged, but the error is ignored. 
     *  
     *  @param logger `logger`: a logger that will be used to journal errors.
     *  @param a_where `string`: a prefix that indicates the public reactor function 
     *      that initiated the closing.
     *  @param fd `int`: a file descriptor that should be closed.
     *)
    fun close_fd logger (a_where : string) (fd : int) = (
        Fd.close fd;
        Logger.info
            logger
            ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^ ". Closed.")
    ) handle FFIFailure => (
        Logger.warn
            logger
            ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
             ". Closing finished with an error: " ^
             Int.toString (Errno.errno()))
    )

    (**
     *  Internal function that removes a descriptor from the epoll
     *  mechanism and remove corresponding fd_info from reactor's 
     *  internal structure.
     *
     *  Any errros are ignored here, and only logged with a 'warn' level of logging.
     *
     *  @param reactor `'a reactor`: a reactor the file descriptor should be
     *      removed from.
     *  @param a_where `string`: a prefix that indicates the public reactor function
     *      that initiated the removal.
     *  @param fd `int`: a fd that should be removed.
     *  @param to_close `bool`: if true, the descriptor is closed after removing.
     *)
    fun remove_from_epoll reactor (a_where : string) (fd : int) (to_close : bool) =
        let
            val logger = ReactorType.get_logger reactor
            val epoll_fd = ReactorType.get_epoll_fd reactor
        in
            (* Detach file descriptor from the epoll mechanism. Ignore any error here. *)
            (
                Epoll.ctl EpollCtlDel epoll_fd fd (EpollEventsMask.empty ());
                Logger.info
                    logger
                    ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^ ". Detached.")
            )
            handle FFIFailure => (
                Logger.warn
                    logger
                    ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                     ". Detaching failed with Error=" ^ Int.toString (Errno.errno ()) ^ ".")
            );

            (* Close the file descriptor. Ignore any error here. *)
            if to_close
            then close_fd logger a_where fd
            else ();

            (* Remove file descriptor and corresponding info from the internal map *)
            ReactorType.remove_fd_info reactor fd
        end


    (**
     *  Internal function that adds a file descriptor 
     *  into the reactor's polling mechanism using FFI call to epoll_ctl
     *  and adds the descriptor's info into reactor's internal structure.
     *
     *  @param reactor `'a reactor`: a reactor where a file descriptor should be added.
     *  @param a_where `string`: a prefix that indicates the public reactor function 
     *      that initiated the addition.
     *  @param fd_info `'a reactor fd_info`: an fd_info that corresponds to the
     *      descriptor to be added.
     *  @param events_mask `epoll_events_mask`: events the reactor should listen on
     *      the descriptor to.
     *  @param close_on_error `bool`: if True, the descriptor is closed in case of errors.
     *
     *  @raises `ReactorSystemError` if call to `epoll_ctl` fails. In that case the socket
     *      will not be closed, and the caller function is responsible for the exception
     *      handling and closing the socket if required.
     *)
    fun add_to_epoll reactor (a_where : string) fd_info (events_mask : epoll_events_mask) (close_on_error : bool) =
        let
            val logger = ReactorType.get_logger reactor
            val epoll_fd = ReactorType.get_epoll_fd reactor

            val fd = FdInfoType.get_fd fd_info
        in
            Epoll.ctl EpollCtlAdd epoll_fd fd events_mask
            handle FFIFailure => (
                raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": Adding FD=" ^ Int.toString fd ^ 
                         ", Name=" ^ FdInfoType.get_name fd_info ^ 
                         ", HType=" ^ FdInfoType.get_handler_type fd_info ^ 
                         ". Failed with Error=" ^ Int.toString errno ^ ".");
                        if close_on_error then close_fd logger a_where fd else ()
                )) None
            );
            Logger.info 
                logger 
                ("Reactor." ^ a_where ^ ": Added FD=" ^ Int.toString fd ^ 
                 ", Name=" ^ FdInfoType.get_name fd_info ^ 
                 ", HType=" ^ FdInfoType.get_handler_type fd_info ^ ".");
            
            ReactorType.add_fd_info reactor fd_info
        end
    
    (**
     *  Internal implementation of the public `clear` function.
     *
     *  Any errros are ignored here, and only logged with a 'warn' level of logging.
     *
     *  @param reactor `'a reactor`: a reactor that should be cleared.
     *)
    fun clear reactor =
        let
            fun remove_all_fds fds_list =
                case fds_list of
                    [] => ()
                  | (fd_info :: others) => (
                        remove_from_epoll 
                            reactor "clear" (FdInfoType.get_fd fd_info) 
                            (should_fd_info_be_closed fd_info);
                        remove_all_fds others
                    )
            val fds_list = List.map snd (Map.toAscList (ReactorType.get_fds reactor))

            val logger = ReactorType.get_logger reactor
            val epoll_fd = ReactorType.get_epoll_fd reactor
        in
            Logger.info logger "Reactor.clear: clearing started.";
            remove_all_fds fds_list;
            close_fd logger "clear" epoll_fd;
            ReactorType.set_is_closed reactor True;
            Logger.info logger "Reactor.clear: reactor cleared"
        end

    (**
     *  Validates that the creration of the buffer with specified
     *  size and lower watermark arguments is valid.
     *
     *  @param logger `logger`: a logger that should be used to journal errors.
     *  @param a_where `string`: a name o
     *)
    fun validate_buffer_args logger (a_where : string) (name : string) 
            (bufsz : int) (lwm : int) (zero_allowed : bool) = (
        (* Check the common preconditions. *)
        if (bufsz < 0) orelse (lwm < 0) orelse (lwm > bufsz)
        then (
            Logger.error
                logger
                ("Reactor." ^ a_where ^ ": Name=" ^ name ^
                ". Invalid BuffSz or LowWaterMark." ^
                " Buffsz=" ^ Int.toString bufsz ^
                ", LowWaterMark=" ^ Int.toString lwm ^ ".");
            raise ReactorBadArgumentError
        ) else ();

        (* If buffer size should be positive, check that condition too. *)
        if (not zero_allowed) andalso (bufsz = 0)
        then (
            Logger.error
                logger
                ("Reactor." ^ a_where ^ ": Name=" ^ name ^
                ". Buffer must not be 0-size.");
            raise ReactorBadArgumentError
        ) else ()
    )
end

structure ReactorRequest = 
struct
    (**
     *  Assigns the address to the socket referred to by the file descriptor.
     *)
    fun bind logger (a_where : string) (fd : int) (address : in_addr) (port : int) = (
        Socket.bind fd address port
        handle FFIFailure => (
            ReactorPrivate.raise_reactor_system_error (fn errno => (
                Logger.error
                    logger
                    ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                     ". Binding failed with Error=" ^ Int.toString errno ^ ".");
                ReactorPrivate.close_fd logger a_where fd
            )) None
        );
        Logger.info 
            logger 
            ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
             ". Binded to Addr=\"" ^ InAddr.to_string address ^ "\"" ^ 
             ", Port=" ^ Int.toString port ^ ".")
    )

    (**
     *  Just a wrapper under the Socket.create () function,
     *  that logs occurring events.
     *)
    fun create_socket logger (a_where : string) (name : string) =
        let
            val fd = Socket.create ()
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": create_socket() failed with Error=" ^
                         Int.toString errno ^ ". Name=" ^ name ^ ".")
                )) None
            )
        in
            Logger.info
                logger
                ("Reactor." ^ a_where ^": socket created at FD=" ^ Int.toString fd ^
                 ". Name=" ^ name ^ ".");
            fd
        end

    local
        (**
         *  Set the socket up with all predefined parameters, and ensure
         *  that underlying socket is nonblocking.
         *
         *  @param logger `logger`
         *  @param a_where `string`: a public function that called us.
         *  @param name `string`: name of the socket provided by the user.
         *      Is used while logging errors and other infos.
         *  @param fd `int`: a file descriptor that refers to the socket to be setup.
         *
         *  @returns `int`: a file descriptor refferring to created socket.
         *
         *  @raises `ReactorSystemError` if any of fFFI calls fails.
         *)
        fun setup_data_stream logger (a_where : string) (name : string) (fd : int) (address_opt : in_addr option) = (
            case address_opt of
                None => ()
              | Some address => bind logger a_where fd address 0;

            (* Ensure that the socket descriptor refers to is non-blocking. *)
            Fd.set_blocking fd False
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set non-blocking mode. Failed with Error=" ^ 
                         Int.toString errno ^ ".");
                    ReactorPrivate.close_fd logger a_where fd
                )) None
            );

            (* VERY IMPORTANT: Disable the Nagle algorithm on this socket. *)
            Socket.set_tcp_nodelay fd True
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set TCP_NODELAY with Error=" ^ 
                         Int.toString errno ^ ".");
                    ReactorPrivate.close_fd logger a_where fd
                )) None
            );

            (** 
             *  Set the Keep-Alive mode on the socket, with 1-second intervals:
             *  ----------------------------------------------------------------------- *
             *  5 missed acks will indicated a disconnect. This is required in order to
             *  detect stale connections as early as possible: HeartBeats could also be
             *  used to that end, but with much longer latency (eg minutes). 
             *)
            Socket.set_so_keepalive fd True
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set SO_KEEPALIVE with Error=" ^
                         Int.toString errno ^ ".");
                    ReactorPrivate.close_fd logger a_where fd
               )) None
            );

            (* Detailed config of TCP_KEEPALIVE option. *)
            Socket.set_tcp_keepidle fd 1
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set TCP_KEEPIDLE with Error=" ^
                         Int.toString errno ^ ".");
                    ReactorPrivate.close_fd logger a_where fd
                )) None
            );
            Socket.set_tcp_keepintvl fd 1
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set TCP_KEEPINTVL with Error=" ^
                         Int.toString errno ^ ".");
                    ReactorPrivate.close_fd logger a_where fd
                )) None
            );
            Socket.set_tcp_keepcnt fd 5
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set TCP_KEEPCNT with Error=" ^
                         Int.toString errno ^ ".");
                    ReactorPrivate.close_fd logger a_where fd
                )) None
            )
        )

        (**
         *  Internal function that creates and set up a socket, generate fd_info
         *  and add it into the reactor with corresponding events_mask.
         *)
        fun add_data_stream_internal
            reactor (a_where : string) (name : string) (fd_opt : int option) (address_opt : in_addr option)
            validation fd_info_gen =
        let 
            val logger = ReactorType.get_logger reactor

            (* Validate arguments before continuing. May raise `ReactorBadArgumentError`
             * if corresponding arguments are non-valid. *)
            val _ = validation logger

            (* Create a descriptor if required and set it up. *)
            val fd = case fd_opt of Some fd => fd | None => create_socket logger a_where name
            val _ = setup_data_stream logger a_where name fd address_opt

            val fd_info = fd_info_gen fd

            (* Create the events mask *)
            val events_mask = EpollEventsMask.from_list [Epollet, Epollrdhup]
            val events_mask = 
                if not (FdInfoType.is_read_data_stream fd_info) 
                then EpollEventsMask.add events_mask Epollout 
                else events_mask
            val events_mask =
                if not (FdInfoType.is_write_data_stream fd_info)
                then EpollEventsMask.add events_mask Epollin
                else events_mask
        in
            ReactorPrivate.add_to_epoll reactor a_where fd_info events_mask True;
            fd
        end

        fun add_read_data_stream_internal 
                reactor (a_where : string) name fd_opt on_read on_connect_opt 
                on_error rd_bufsz rd_lwm address_opt =
            let
                fun validation logger = ReactorPrivate.validate_buffer_args logger a_where name rd_bufsz rd_lwm False

                fun fd_info_gen (fd : int) = (
                    (* In theory could raise `IOBufferLowWatermarkTooHigh` exception
                     * but would not, as we verified that watermark is not greater
                     * than the buffer size. *)
                    ReadDataStreamFdInfo name fd on_read on_connect_opt 
                        on_error (IOBuffer.init rd_bufsz rd_lwm) False (Option.isSome fd_opt)
                ) 
            in
                add_data_stream_internal reactor a_where name fd_opt address_opt validation fd_info_gen
            end

        fun add_write_data_stream_internal
                reactor (a_where : string) name fd_opt on_connect_opt 
                on_error wr_bufsz wr_lwm address_opt =
            let
                fun validation logger = ReactorPrivate.validate_buffer_args logger a_where name wr_bufsz wr_lwm True

                fun fd_info_gen (fd : int) = (
                    (* In theory could raise `IOBufferLowWatermarkTooHigh` exception
                     * but would not, as we verified that watermark is not greater
                     * than the buffer size. *)
                    WriteDataStreamFdInfo name fd on_connect_opt on_error 
                        (IOBuffer.init wr_bufsz wr_lwm) False (Option.isSome fd_opt)
                )
            in
                add_data_stream_internal reactor a_where name fd_opt address_opt validation fd_info_gen
            end

        fun add_read_write_data_stream_internal
                reactor (a_where : string) name fd_opt on_read on_connect_opt 
                on_error rd_bufsz rd_lwm wr_bufsz wr_lwm address_opt =
            let
                fun validation logger = (
                    ReactorPrivate.validate_buffer_args logger a_where name rd_bufsz rd_lwm False;
                    ReactorPrivate.validate_buffer_args logger a_where name wr_bufsz wr_lwm True
                )
                
                fun fd_info_gen fd = (
                    (* In theory could raise `IOBufferLowWatermarkTooHigh` exception
                     * but would not, as we verified that watermark is not greater
                     * than the buffer size. *)
                    ReadWriteDataStreamFdInfo name fd on_read on_connect_opt on_error 
                        (IOBuffer.init rd_bufsz rd_lwm) (IOBuffer.init wr_bufsz wr_lwm) False (Option.isSome fd_opt)
                )
            in
                add_data_stream_internal reactor a_where name fd_opt address_opt validation fd_info_gen
            end
    in
        fun add_existing_read_data_stream reactor name fd on_read on_error rd_bufsz rd_lwm = (
            add_read_data_stream_internal 
                reactor "add_existing_read_data_stream" name (Some fd) on_read None on_error rd_bufsz rd_lwm None;
            ()
        )

        fun add_existing_write_data_stream reactor name fd on_error wr_bufsz wr_lwm = (
            add_write_data_stream_internal
                reactor "add_existing_write_data_stream" name (Some fd) None on_error wr_bufsz wr_lwm None;
            ()
        )

        fun add_existing_read_write_data_stream reactor name fd on_read on_error rd_bufsz rd_lwm wr_bufsz wr_lwm = (
            add_read_write_data_stream_internal
                reactor "add_existing_read_write_data_stream" name (Some fd) on_read None 
                on_error rd_bufsz rd_lwm wr_bufsz wr_lwm None;
            ()   
        )

        (*
         *  Creates a new read data stream with specified parameters and adds it into the reactor.
         *
         *  @param reactor `'a reactor`.
         *  @param name `string`: a name that will be referring to the created data stream.
         *  @param on_read `'a read_handler`: a callback function called when new
         *      data are read from the data stream.
         *  @param on_connect_opt `'a connect_handler option`: if provided, the function
         *      is called when the socket descriptor reffers to is connected to another peer.
         *  @param on_error `'a reactor err_handler`
         *  @param rd_bufsz `int`: a size of the buffer corresponding to the descriptor.
         *  @param rd_lwm `int`: lower watermark that the buffer should have.
         *  @param address_opt `in_addr option`: if provided, specifies an IPv4 address 
         *      of the interface the data stream should be binded to.
         *)
        fun add_read_data_stream 
                reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm address_opt = 
            add_read_data_stream_internal 
                reactor "add_read_data_stream" name None on_read on_connect_opt on_error rd_bufsz rd_lwm address_opt

        (*
         *  Creates a new write data stream with specified parameters and adds it into the reactor.
         *
         *  @param reactor `'a reactor`.
         *  @param name `string`: a name that will be referring to the created data stream.
         *  @param on_connect_opt `'a connect_handler option`: if provided, the function
         *      is called when the socket descriptor reffers to is connected to another peer.
         *  @param on_error `'a reactor err_handler`
         *  @param wr_bufsz `int`: a size of the buffer corresponding to the descriptor.
         *  @param wr_lwm `int`: lower watermark that the buffer should have.
         *  @param address_opt `in_addr option`: if provided, specifies an IPv4 address 
         *      of the interface the data stream should be binded to.
         *)
        fun add_write_data_stream 
                reactor name on_connect_opt on_error wr_bufsz wr_lwm address_opt =
            add_write_data_stream_internal
                reactor "add_write_data_stream" name None on_connect_opt on_error wr_bufsz wr_lwm address_opt

        (*
         *  Creates a new read write data stream with specified parameters and adds it into the reactor.
         *
         *  @param reactor `'a reactor`.
         *  @param name `string`: a name that will be referring to the created data stream.
         *  @param on_read `'a read_handler`: a callback function called when new
         *      data are read from the data stream.
         *  @param on_connect_opt `'a connect_handler option`: if provided, the function
         *      is called when the socket descriptor reffers to is connected to another peer.
         *  @param on_error `'a reactor err_handler`
         *  @param rd_bufsz `int`: a size of the read buffer corresponding to the descriptor.
         *  @param rd_lwm `int`: lower watermark that the read buffer should have.
         *  @param wr_bufsz `int`: a size of the write buffer corresponding to the descriptor.
         *  @param wr_lwm `int`: lower watermark that the write buffer should have.
         *  @param address_opt `in_addr option`: if provided, specifies an IPv4 address 
         *      of the interface the data stream should be binded to.
         *)
        fun add_read_write_data_stream 
                reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm wr_bufsz wr_lwm address_opt =
           add_read_write_data_stream_internal
                reactor "add_read_write_data_stream" name None on_read on_connect_opt 
                on_error rd_bufsz rd_lwm wr_bufsz wr_lwm address_opt
    end

    (**
     *  Initializes a connection on a socket with specified peer address.
     *
     *  @param reactor `'a reactor`
     *  @param fd `int`: a file descriptor referring to the socket.
     *  @param sockaddr `sockaddr_in`: an address of the peer to initialize
     *      connection to.
     *)
    fun connect reactor fd sockaddr =
        let
            val logger = ReactorType.get_logger reactor

            val fd_info = 
                case ReactorType.get_fd_info_opt reactor fd of
                    Some fd_info => fd_info
                  | None => (
                        Logger.error
                            logger
                            ("Reactor.connect: FD=" ^ Int.toString fd ^
                             ". The descriptor does not belong to the reactor.");
                        raise ReactorBadArgumentError
                  )

            val (SockAddrIn address port) = sockaddr
            (* Internal function that connects the socket, while ignoring
             * interruption (EINTR) errors. `FFIEagain` and `FFIFailure` 
             * exceptions are wrapped into Error type and returned. *)
            fun internal () = (
                Ok (Socket.connect fd address port)
                handle 
                    FFIEintr => internal ()
                  | FFIEagain => Error FFIEagain
                  | FFIFailure => Error FFIFailure

            )
        in
            (* Validate that fd_info indeed corresponds to a data stream. *)
            if not (
                FdInfoType.is_read_data_stream fd_info
                    orelse
                FdInfoType.is_write_data_stream fd_info
                    orelse
                FdInfoType.is_read_write_data_stream fd_info
            ) then (
                Logger.error
                    logger
                    ("Reactor.connect: FD=" ^ Int.toString fd ^
                     ". Corresponding fd_info is not a DataStream.");
                raise ReactorBadArgumentError
            ) else ();

            (* We cannot perform repeated connection attempts, thus, verify
             * that the connection is not establishing or has been established
             * on the socket. *)
            if (
                FdInfoType.get_is_connecting_status fd_info 
                    orelse 
                FdInfoType.get_is_connected_status fd_info
            ) then (
                Logger.error
                    logger
                    ("Reactor.connect: FD=" ^ Int.toString fd ^ 
                     ". Socket already connected, or connection is in progress.");
                raise ReactorBadArgumentError
            ) else ();

            (*  IMPORTANT: if the FDInfo refers to Read only data stream, it will 
             *  not have EPOLLOUT event specified. However, when connection terminates,
             *  exactly this event will be emitted on the socket. Thus, we have to
             *  add the EPOLLOUT event before trying to connect. On connection,
             *  the event should be deleted from the set of events, descriptor is
             *  waiting for.
             *) 
            if (FdInfoType.is_read_data_stream fd_info)
            then (
                let
                    val epoll_fd = ReactorType.get_epoll_fd reactor
                    val events_mask = EpollEventsMask.from_list [Epollet, Epollrdhup, Epollin, Epollout]
                in
                    Epoll.ctl EpollCtlMod epoll_fd fd events_mask
                    handle FFIFailure => (
                        ReactorPrivate.raise_reactor_system_error (fn errno => 
                            Logger.error
                                logger
                                ("Reactor.connect: FD=" ^ Int.toString fd ^
                                 ". Specifying EPOLLOUT event in the epoll for ReadDataStream" ^
                                 " descriptor failed with Error=" ^ Int.toString errno ^ ".")
                        ) None
                    )
                end
            ) else ();

            case internal () of
                Ok () => (
                    (* TCP Connect already succeeded (which is nearly impossible).
                     * In that case we store connected status inside the FDInfo.
                     * 
                     * Likewise, it seems that we should call on_connect callback
                     * function, but we do not do it for now. TODO. *)
                    Logger.info
                        logger
                        ("Reactor.connect: FD=" ^ Int.toString fd ^
                         ". TCP Connect Successful.");
                    ReactorType.add_fd_info reactor (FdInfoType.set_is_connected_status fd_info True)
                )
              | Error FFIEagain => (
                    (* It is a normal condition indicating that connection has
                     * not been established immideately. We just store that 
                     * information in the added FDInfo and return from the function. 
                     *)
                    Logger.info
                        logger
                        ("Reactor.connect: FD=" ^ Int.toString fd ^
                         ". TCP Connection is in progress.");
                    ReactorType.add_fd_info reactor (FdInfoType.set_is_connecting_status fd_info True)
                )
              | Error FFIFailure => (
                    ReactorPrivate.raise_reactor_system_error (fn errno => 
                        Logger.error
                            logger
                            ("Reactor.connect: FD=" ^ Int.toString fd ^ 
                             ". connect() failed with Error=" ^ Int.toString errno ^ ".")
                    ) None
                )
        end

    (**
     *  Creates a new acceptance socket and add it into the reactor.
     *
     *  @param reactor `'a reactor`.
     *  @param name `string`: a name that will be referring to the created acceptor.
     *  @param on_accept `'a accept_handler`: a callback function that should be
     *      called when new connection is accepted.
     *  @param on_error `'a err_handler`: a callback function that should be called
     *      if any error will be obtained when accepting new connections.
     *  @param sockaddr `sockaddr_in`: an IPv4 address and port number the 
     *      listening socket should be binded to.
     *  @param backlog `int`: the maximum length to which the queue of
     *      pending connections for the socket may grow.
     *
     *  @returns `int`: a file descriptor referring to created listening socket.
     *
     *  @raises `ReactorSystemError` if any applied syscall fails.
     *)
    fun add_acceptor reactor name on_accept on_error sockaddr backlog = 
        let
            val logger = ReactorType.get_logger reactor
            val a_where = "add_acceptor"

            val fd = create_socket logger a_where name
            val (SockAddrIn in_addr in_port) = sockaddr

            val fd_info = AcceptorFdInfo name fd on_accept on_error
            val events_mask = EpollEventsMask.from_list [Epollet, Epollin]
        in
            (* Allow to reuse local addresses before binding the socket. *)
            Socket.set_so_reuseaddr fd True
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => 
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". Could not set SO_REUSEADDR with Error=" ^
                         Int.toString errno ^ ".")
                ) None
            );
            
            (* Bind the socket to the specified address *)
            bind logger a_where fd in_addr in_port;

            (* Make the socket listening. *)
            Socket.listen fd backlog
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => 
                    Logger.error
                        logger
                        ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                         ". listen() failed with Error=" ^
                         Int.toString errno ^ ".")
                ) None
            );
            Logger.info
                logger
                ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                 ". Start listening.");

            (* Add the created listening socket into the epoll mechanism. *)
            ReactorPrivate.add_to_epoll reactor a_where fd_info events_mask True;
            fd
        end

    (*
     *  Creates a new timer with specified parameters and adds it into the reactor.
     *
     *  @param reactor `'a reactor`.
     *  @param name `string`: a name that will be referring to the created timer.
     *  @param initial_mcsec `int`: a period of time in microseconds
     *      after which the timer will expire first time.
     *  @param period_mcsec `int`: a period of time in microseconds
     *      that timer periodically fires after the first expiration.
     *  @param on_timer `'a reactor timer_handler`
     *  @param on_error `'a reactor err_handler`
     *
     *  @returns `(int * 'a reactor)`: a timer fd created, and an updated reactor.
     *
     *  @raises `ReactorSystemError` if timer creation, timer setting, or addtion
     *      into the epoll mechanism return an error.
     *)
    fun add_timer reactor (name : string) (initial_mcsec : int) (period_mcsec : int)
            on_timer on_error =
        let
            val logger = ReactorType.get_logger reactor

            val fd = Timer.create ()
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => 
                    Logger.error
                        logger
                        ("Reactor.add_timer: create_timer() failed with Error=" ^
                        Int.toString errno ^ ". Name=" ^ name ^ ".")
                ) None
            )
            val _ = Logger.info logger 
                ("Reactor.add_timer: timer created at FD=" ^ Int.toString fd ^ ". Name=" ^ name ^ ".")

            val _ = Timer.set_time fd initial_mcsec period_mcsec
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor.add_timer: set_timer() failed with Error=" ^
                         Int.toString errno ^ ". FD=" ^ Int.toString fd ^ ".");
                    ReactorPrivate.close_fd logger "add_timer" fd
                )) None
            )
            val _ = Logger.info logger
                ("Reactor.add_timer: FD=" ^ Int.toString fd ^ ". Timer was set.")

            (*  We are allowing the buffer to handle 31 expirations without crunching. 
             *  When a timer expires 31 times, there are only 8 bytes left to read the data,
             *  and, thus, we cannot detect EAGAIN condition while reading 32nd expiration,
             *  without crunching the buffer before.
             *)
            val buff = IOBuffer.init (8 * 32) 9
            val fd_info = TimerFdInfo name fd on_timer on_error buff
            val events_mask = EpollEventsMask.from_list [Epollet, Epollin]
        in
            ReactorPrivate.add_to_epoll reactor "add_timer" fd_info events_mask True;
            fd
        end

    (*
     *  Arms (starts) or disarms (stops) the timer referred to by 
     *  the file descriptor included into the reactor.
     *
     *  @param reactor `'a reactor`.
     *  @param fd `int`: a file descriptor refferring to the timer.
     *  @param initial_mcsec `int`: a period of time in microseconds
     *      after which the timer will expire the first time.
     *  @param period_mcsec `int`: a period of time in microseconds
     *      that timer periodically fires after the first expiration.
     *
     *  @raises `ReactorSystemError` if timer setting returns an error.
     *      Corresponding file descriptor is removed from the reactor
     *      and closed.
     *  @raises `ReactorBadArgumentError` if provided file descriptor does
     *      not belong to the reactor or is not a TimerFdInfo.
     *)
    fun set_timer reactor (fd : int) (initial_mcsec : int) (period_mcsec : int) =
        let
            val logger = ReactorType.get_logger reactor
            
            val fd_info = 
                case ReactorType.get_fd_info_opt reactor fd of
                    Some fd_info => fd_info
                  | None => (
                        Logger.error
                            logger
                            ("Reactor.set_timer: FD=" ^ Int.toString fd ^
                             ". The descriptor does not belong to the reactor.");
                        raise ReactorBadArgumentError
                  )
        in
            (* Validate that fd_info indeed belongs to a timer. *)
            if not (FdInfoType.is_timer fd_info)
            then (
                Logger.error
                    logger
                    ("Reactor.set_timer: FD=" ^ Int.toString fd ^
                     ". Corresponding fd_info is not a Timer.");
                raise ReactorBadArgumentError
            )
            else ();

            Timer.set_time fd initial_mcsec period_mcsec
            handle FFIFailure => (
                ReactorPrivate.raise_reactor_system_error (fn errno => (
                    Logger.error
                        logger
                        ("Reactor.set_timer: FD=" ^ Int.toString fd ^ ". set_timer() failed.")
                )) None
            );

            Logger.info 
                logger
                ("Reactor.set_timer: FD=" ^ Int.toString fd ^ ". Timer was set.")
        end

    local
        (**
         *  Internal implementation to add read or write files into the reactor.
         *
         *  @param reactor `'a reactor`: a reactor where files should be added into.
         *  @param name `string`: a name that will be referring to added file.
         *  @param fd `int`: a file descriptor that refers to added file.
         *  @param on_read_opt `'a reactor read_handler option`: an optional field
         *      with on read event handler. We use these argument to distinguish between
         *      `add_read_file` and `add_write_file` callers.
         *  @param on_error `'a reactor err_handler`
         *  @param bufsz `int`: a size of the buffer corresponding to the file.
         *  @param lwm `int`: lower watermark that the buffer should have.
         *
         *  @raises `ReactorBadArgumentError` if any of the arguments is invalid.
         *  @raises `ReactorSystemError` if syscalls to make file nonblocking,
         *      or add file into the epoll mechanism fails.
         *)
        fun add_file reactor (name : string) (fd : int) on_read_opt on_error
                (bufsz : int) (lwm : int) =
            let
                (* If there is an read handler, then we deal with a read file,
                 * otherwise we deal with write file. *)
                val is_read = Option.isSome on_read_opt
                val a_where = if is_read then "add_read_file" else "add_write_file"
                (* Buffer with zero size is not allowed for read files,
                 * as there would be no space to read data into. *)
                val zero_allowed = if is_read then False else True

                val logger = ReactorType.get_logger reactor
            in
                (* Validate arguments before continuing. May raise `ReactorBadArgumentError`
                 * if corresponding arguments are non-valid. *)
                ReactorPrivate.validate_buffer_args logger a_where name bufsz lwm zero_allowed;

                (* IMPORTANT: the descriptor may be created blocking. Thus, explicitly 
                 * set the descriptor into non-blocking mode, before using it in the reactor. *)
                Fd.set_blocking fd False
                handle FFIFailure => (
                    ReactorPrivate.raise_reactor_system_error (fn errno => (
                        Logger.error
                            logger
                            ("Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                             ". Could not set O_NONBLOCK mode. Failed with Error=" ^ 
                             Int.toString errno ^ ".")
                    )) None
                );

                let
                    (* In theory could raise `IOBufferLowWatermarkTooHigh` exception
                     * but would not, as we verified that watermark is not greater
                     * than the buffer size. *)
                    val buff = IOBuffer.init bufsz lwm
                    val fd_info = 
                        if is_read 
                        then ReadFileFdInfo name fd (Option.valOf on_read_opt) on_error buff
                        else WriteFileFdInfo name fd on_error buff

                    (* Create the events mask *)
                    val ev = if is_read then Epollin else Epollout
                    val events_mask = EpollEventsMask.from_list [Epollet, Epollrdhup, ev]
                in
                    (* Even if addition to the epoll mechanism failed, we would not close 
                     * the descriptor as it was not opened by us.
                     *)
                    ReactorPrivate.add_to_epoll reactor a_where fd_info events_mask False
                end
            end
    in
        fun add_read_file reactor (name : string) (fd : int) on_read on_error
                (rd_bufsz : int) (rd_lwm : int) =
            add_file reactor name fd (Some on_read) on_error rd_bufsz rd_lwm

        fun add_write_file reactor (name : string) (fd : int) on_error 
                (wr_bufsz : int) (wr_lwm : int) = 
            add_file reactor name fd None on_error wr_bufsz wr_lwm
    end

    fun write reactor fd data =
        let
            val logger = ReactorType.get_logger reactor

            val fd_info = 
                case ReactorType.get_fd_info_opt reactor fd of
                    Some fd_info => fd_info
                  | None => (
                        Logger.error
                            logger
                            ("Reactor.write: FD=" ^ Int.toString fd ^
                             ". The descriptor does not belong to the reactor.");
                        raise ReactorBadArgumentError
                  )

            (* Validate that fd_info is indeed writable. *)
            fun validate_fd_info () =
                if  
                    not (ReactorPrivate.fd_info_is_writable fd_info)
                then (
                    Logger.error
                        logger
                        ("Reactor.write: FD=" ^ Int.toString fd ^
                         ". Corresponding fd_info is not writable.");
                    raise ReactorBadArgumentError
                ) else if (
                    (* If the descriptor corresponds to a socket, we require
                     * that the socket MUST be connected prior to the "write". *)
                    (
                        FdInfoType.is_write_data_stream fd_info
                            orelse 
                        FdInfoType.is_read_write_data_stream fd_info
                    ) andalso not (FdInfoType.get_is_connected_status fd_info)
                ) then (
                    Logger.error
                        logger
                        ("Reactor.write: FD=" ^ Int.toString fd ^
                         ". Corresponding fd_info refers to an unconnected socket.");
                        raise ReactorBadArgumentError
                ) else ();
            val _ = validate_fd_info ()

            val wr_buff = FdInfoType.get_wr_buff fd_info
            val initial_buff_size = IOBuffer.size wr_buff
            val n = IO.write_until_eagain fd data wr_buff
                handle 
                    FFIFailure => (
                        ReactorPrivate.raise_reactor_system_error (fn errno => (
                            Logger.error
                                logger
                                ("Reactor.write: FD=" ^ Int.toString fd ^ ". write() failed.")
                        )) None
                    )
                  | IOBufferOverflow => (
                        Logger.error
                            logger
                            ("Reactor.write: FD=" ^ Int.toString fd ^ ".write() failed with Buffer Overflow");
                        raise IOBufferOverflow
                    )

            val written_from_buff = min n initial_buff_size
            val written_from_data = max 0 (n - initial_buff_size)
        in
            Logger.info
                logger
                ("Reactor.write: FD=" ^ Int.toString fd ^
                 ". Written from buffer n_buff=" ^ Int.toString written_from_buff ^ " bytes" ^
                 ", written from data n_data=" ^ Int.toString written_from_data ^ " bytes.")
        end

    (**
     *  Removes a descriptor from the reactor.
     *
     *  @param reactor `'a reactor`
     *  @param fd `int`: a descriptor that should be removed.
     *
     *  All exceptions are logged, but not propagates further.
     *)
    fun remove reactor (fd : int) =
        let
            val logger = ReactorType.get_logger reactor
            val fd_info_opt =  ReactorType.get_fd_info_opt reactor fd
        in
            case fd_info_opt of
                None => (
                    Logger.warn
                        logger
                        ("Reactor.remove: FD=" ^ Int.toString fd ^
                         ". The descriptor does not belong to the reactor.")
                )
              | Some fd_info => (
                    ReactorPrivate.remove_from_epoll
                        reactor "remove" fd
                        (ReactorPrivate.should_fd_info_be_closed fd_info)
              )
               
        end


    (**
     *  Stops the reactor execution. Should be used very carefully,
     *  as the execution of running loop is stopped, and all uprorcessed
     *  events on descriptors are lost.
     *
     *  @param reactor `'a reactor` a reactor which running loop should be stopped.
     *
     *  @raise `ReactorExitRun` that should be catched in the run loop. 
     *)
    fun exit_run reactor = 
        let
            val logger = ReactorType.get_logger reactor
        in
            Logger.info logger "Reactor.exit_run: Reactor is stopping.";
            raise ReactorExitRun
        end
end

structure ReactorInternal =
struct
    local
        fun process_error reactor error_callback errno =
            let
                val (new_state, new_request_opt) = error_callback (ReactorType.get_state reactor) errno
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_read_data_stream_request 
                reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm in_addr_opt callback =
            let
                val fd = ReactorRequest.add_read_data_stream 
                    reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm in_addr_opt
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor) fd
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_existing_read_data_stream_request 
                reactor name fd on_read on_error rd_bufsz rd_lwm callback =
            let
                val _ = ReactorRequest.add_existing_read_data_stream 
                    reactor name fd on_read on_error rd_bufsz rd_lwm
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end
        
        fun process_add_write_data_stream_request 
                reactor name on_connect_opt on_error wr_bufsz wr_lwm in_addr_opt callback =
            let
                val fd = ReactorRequest.add_write_data_stream 
                    reactor name on_connect_opt on_error wr_bufsz wr_lwm in_addr_opt
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor) fd
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_existing_write_data_stream_request 
                reactor name fd on_error wr_bufsz wr_lwm callback =
            let
                val _ = ReactorRequest.add_existing_write_data_stream 
                    reactor name fd on_error wr_bufsz wr_lwm
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_read_write_data_stream_request 
                reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm wr_bufsz wr_lwm in_addr_opt callback =
            let
                val fd = ReactorRequest.add_read_write_data_stream 
                    reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm wr_bufsz wr_lwm in_addr_opt
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor) fd
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end
        
        fun process_add_existing_read_write_data_stream_request 
                reactor name fd on_read on_error rd_bufsz rd_lwm wr_bufsz wr_lwm callback =
            let
                val _ = ReactorRequest.add_existing_read_write_data_stream 
                    reactor name fd on_read on_error rd_bufsz rd_lwm wr_bufsz wr_lwm
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_connect_request reactor fd sockaddr callback =
            let
                val _ = ReactorRequest.connect reactor fd sockaddr
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end


        fun process_add_acceptor_request reactor name on_accept on_error sockaddr backlog callback =
            let
                val fd = ReactorRequest.add_acceptor reactor name on_accept on_error sockaddr backlog
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor) fd
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_timer_request reactor name initial_mcsec period_mcsec on_timer on_err callback =
            let
                val fd = ReactorRequest.add_timer reactor name initial_mcsec period_mcsec on_timer on_err
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor) fd
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_set_timer_request reactor fd initial_mcsec period_mcsec callback =
            let
                val _ = ReactorRequest.set_timer reactor fd initial_mcsec period_mcsec
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_read_file_request reactor name fd on_read on_error rd_bufsz rd_lwm callback =
            let
                val _ = ReactorRequest.add_read_file reactor name fd on_read on_error rd_bufsz rd_lwm
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_add_write_file_request reactor name fd on_error rd_bufsz rd_lwm callback =
            let
                val _ = ReactorRequest.add_write_file reactor name fd on_error rd_bufsz rd_lwm
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        (**
         *  IMPORTANT: returning from Write request does not mean, that
         *  that data has been actually written neither into the sending wires,
         *  nor even into the kernel buffer. Some data may remain unsent and stored
         *  into the FDInfo buffer to be sent later by `DelayedSend`.
         *  Thus, the user should not remove the descriptor, as a callback.
         *
         *  The callback functionality is added for the case if more than 1 write
         *  operation should be performed in a row to several different descriptors.
         *)
        fun process_write_request reactor fd data callback =
            let
                val _ = ReactorRequest.write reactor fd data
                handle IOBufferOverflow => raise ReactorSystemError (~1)

                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_remove_request reactor fd callback =
            let
                val _ = ReactorRequest.remove reactor fd
                val (new_state, new_request_opt) = callback (ReactorType.get_state reactor)
            in
                ReactorType.set_state reactor new_state;
                (reactor, new_request_opt)
            end

        fun process_exit_run reactor = 
            ReactorRequest.exit_run reactor

    in
        fun handle_function_request reactor request_opt =
            case request_opt of
                None => reactor
              | Some (AddReadDataStream name on_read on_connect_opt on_error
                        rd_bufsz rd_lwm in_addr_opt callback error_callback) =>
                    let
                      val (new_reactor, new_request_opt) = 
                            process_add_read_data_stream_request 
                                reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm in_addr_opt callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddExistingReadDataStream name fd on_read on_error
                        rd_bufsz rd_lwm callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_existing_read_data_stream_request 
                                reactor name fd on_read on_error rd_bufsz rd_lwm callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddWriteDataStream name on_connect_opt on_error wr_bufsz wr_lwm 
                        in_addr_opt callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_write_data_stream_request 
                                reactor name on_connect_opt on_error wr_bufsz wr_lwm in_addr_opt callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddExistingWriteDataStream name fd on_error wr_bufsz wr_lwm callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_existing_write_data_stream_request 
                                reactor name fd on_error wr_bufsz wr_lwm callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddReadWriteDataStream name on_read on_connect_opt on_error 
                        rd_bufsz rd_lwm wr_bufsz wr_lwm in_addr_opt callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_read_write_data_stream_request 
                                reactor name on_read on_connect_opt on_error rd_bufsz rd_lwm wr_bufsz wr_lwm in_addr_opt callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddExistingReadWriteDataStream name fd on_read on_error 
                        rd_bufsz rd_lwm wr_bufsz wr_lwm callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_existing_read_write_data_stream_request 
                                reactor name fd on_read on_error rd_bufsz rd_lwm wr_bufsz wr_lwm callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (Connect fd sockaddr callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_connect_request reactor fd sockaddr callback
                        handle
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddAcceptor name on_accept on_error sockaddr backlog callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_acceptor_request 
                                reactor name on_accept on_error sockaddr backlog callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddTimer name initial_mcsec period_mcsec on_timer on_error callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_timer_request reactor name initial_mcsec period_mcsec on_timer on_error callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (SetTimer fd initial_mcsec period_mcsec callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_set_timer_request reactor fd initial_mcsec period_mcsec callback
                        handle 
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddReadFile name fd on_read on_error rd_bufsz rd_lwm callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_read_file_request reactor name fd on_read on_error rd_bufsz rd_lwm callback
                        handle
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (AddWriteFile name fd on_error rd_bufsz rd_lwm callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_add_write_file_request reactor name fd on_error rd_bufsz rd_lwm callback
                        handle
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (Write fd data callback error_callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_write_request reactor fd data callback
                        handle
                            ReactorSystemError errno => process_error reactor error_callback errno
                          | ReactorBadArgumentError => process_error reactor error_callback ~10
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some (Remove fd callback) =>
                    let
                        val (new_reactor, new_request_opt) = 
                            process_remove_request reactor fd callback
                        
                        (* No exception handling, as remove operation does not through,
                         * but just logs the exceptions. *)
                    in
                        handle_function_request new_reactor new_request_opt
                    end
              | Some ExitRun => process_exit_run reactor
    end

    (**
     *  Internal function that handles occurring during i/o errors. 
     *  It logs the error with provided information, and calls user-
     *  specified error handler.
     *
     *  @param reactor `'a reactor`: a reactor where critical error occurred.
     *  @param a_where `string`: a prefix that indicates the public reactor function 
     *      executed while an error occurred.
     *  @param fd_info `'a reactor fd_info`: information about descriptor 
     *      where error occurred.
     *  @param errno_opt `int option`: if provided is used as an errno argument
     *      in error handler. If not provided, current `Errno.errno ()` is used.
     *  @param msg `string`: a message that is appended to the end of the logs.
     *)
    fun handle_io_error reactor (a_where : string) fd_info (errno_opt : int option) (msg : string) =
        let
            val logger = ReactorType.get_logger reactor

            val fd = FdInfoType.get_fd fd_info
            val name = FdInfoType.get_name fd_info
            val errno = case errno_opt of Some errno => errno | None => Errno.errno ()

            val (ErrHandler err_handler) = FdInfoType.get_err_handler fd_info

            val to_log = "Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                ", Name=" ^ name ^ ", errno=" ^ Int.toString errno ^
                ": " ^ msg ^ "."
            val _ = Logger.error logger to_log

            (* Invoke used-defined error handler. *)
            val (new_state, new_request_opt) = err_handler (ReactorType.get_state reactor) fd errno
        in
            ReactorType.set_state reactor new_state;
            handle_function_request reactor new_request_opt
        end

    (**
     *  Internal function that handles occurring during i/o errors that requires
     *  the reactor to be terminated. It logs the error with provided information,
     *  clears and throws an `ReactorExitRun` exception.
     *
     *  @param reactor `'a reactor`: a reactor where critical error occurred.
     *  @param a_where `string`: a prefix that indicates the public reactor function 
     *      executed while an error occurred.
     *  @param fd_info `'a reactor fd_info`: information about descriptor 
     *      where error occurred.
     *  @param errno_opt `int option`: if provided is used as an errno argument
     *      in error handler. If not provided, current `Errno.errno ()` is used.
     *  @param msg `string`: a message that is appended to the end of the logs.
     *
     *  @raises `ReactorExitRun` which should be handled in the poll cycle.
     *)
    fun handle_critical_io_error reactor (a_where : string) fd_info (errno_opt : int option) (msg : string) =
        let
            val logger = ReactorType.get_logger reactor

            val fd = FdInfoType.get_fd fd_info
            val name = FdInfoType.get_name fd_info
            val errno = case errno_opt of Some errno => errno | None => Errno.errno ()

            val (ErrHandler err_handler) = FdInfoType.get_err_handler fd_info

            val to_log = "Reactor." ^ a_where ^ ": FD=" ^ Int.toString fd ^
                ", Name=" ^ name ^ ", errno=" ^ Int.toString errno ^
                ": " ^ msg ^ "."
            val _ = Logger.critical logger to_log

            (* Invoke used-defined error handler. *)
            val (new_state, new_request_opt) = err_handler (ReactorType.get_state reactor) fd errno
        in
            ReactorType.set_state reactor new_state;
            handle_function_request reactor new_request_opt;
            raise ReactorExitRun
        end

    (**
     *  Sent out any bytes remaining into the wr_buff (which were)
     *  not sent synchronously. As it is called from writable descriptor
     *  handlers, we rely on the following preconditions:
     *      - FDInfo has not been deleted from the reactor;
     *      - FDInfo is writable.
     *  It is the responsibility of the caller to ensure that these
     *  preconditions hold.  
     *)
    fun delayed_write reactor fd_info = 
        let
            val logger = ReactorType.get_logger reactor
            
            val fd = FdInfoType.get_fd fd_info
            val wr_buff = FdInfoType.get_wr_buff fd_info
            val initial_buff_size = IOBuffer.size wr_buff
            val res = Ok (IO.write_until_eagain fd (ByteArray.empty 0) wr_buff)
                handle 
                    FFIFailure => Error FFIFailure
                  | IOBufferOverflow => Error IOBufferOverflow
        in
            case res of
                Ok n => (
                    if 
                        initial_buff_size > 0
                    then (
                        Logger.info
                            logger
                            ("Reactor.delayed_write: FD=" ^ Int.toString fd ^
                             ". Written from buffer n_buff=" ^ Int.toString n ^ " bytes.");
                        reactor
                    ) else
                        reactor
                )
              | Error FFIFailure =>
                    handle_io_error reactor "delayed_write" fd_info None "write() failed"
              | Error IOBufferOverflow =>
                    handle_io_error reactor "delayed_write" fd_info (Some (~1)) "write() failed with Buffer Overflow"
        end

    local
        fun handle_connect reactor (a_where : string) fd_info events_mask =
            if 
                (* We are handling connection only if the socket has been
                 * connecting before, and there was no error on the socket. *)
                (FdInfoType.get_is_connecting_status fd_info)
                    andalso
                not (ReactorPrivate.is_error events_mask)
                    andalso
                (ReactorPrivate.is_writable events_mask)
            then (
                let
                    val logger = ReactorType.get_logger reactor

                    val fd = FdInfoType.get_fd fd_info
                    val on_connect_opt = FdInfoType.get_connect_handler_opt fd_info

                    val new_fd_info = FdInfoType.set_is_connected_status
                        (FdInfoType.set_is_connecting_status fd_info False) 
                        True
                    val _ = ReactorType.add_fd_info reactor new_fd_info
                in
                    Logger.info
                        logger
                        ("Reactor." ^ a_where  ^ ": FD=" ^ Int.toString fd ^
                         ": TCP Connect Successful");

                    case on_connect_opt of
                        None => reactor
                      | Some (ConnectHandler connect_handler) => (
                            let
                                val (new_state, new_request_opt) = connect_handler (ReactorType.get_state reactor) fd
                            in
                                ReactorType.set_state reactor new_state;
                                handle_function_request reactor new_request_opt
                            end
                        )
                end
            ) else reactor

        fun handle_read reactor (a_where : string) (fd : int) events_mask = 
            case ReactorType.get_fd_info_opt reactor fd of
                None => (
                    (* Descriptor has been deleted from the reactor by some handler
                     * (most probably, by connect handler). *)
                    reactor
                )
              | Some fd_info => (
                    if 
                        (* We are reading the data only from connected socket. *)
                        FdInfoType.get_is_connected_status fd_info
                            andalso
                        ReactorPrivate.is_readable events_mask
                    then (
                        let
                            val (ReadHandler read_handler) = FdInfoType.get_read_handler fd_info
                            val buff = FdInfoType.get_rd_buff fd_info

                            fun on_read r (fd : int) (buff : io_buffer) =
                                let
                                    val (new_state, n, new_request_opt) = read_handler (ReactorType.get_state r) fd buff
                                in
                                    ReactorType.set_state r new_state;
                                    (handle_function_request r new_request_opt, n)
                                end

                            val result = IO.read_until_eagain reactor fd buff on_read ReactorType.has_fd_info
                        in
                            case result of
                                Ok (new_reactor, n_total) => new_reactor
                              | Error (new_reactor, n_total, exn) => (
                                    (* User-defined error handler is invloked inside 
                                     * `ReactorPrivate.handle_critical_io_error` function. *)
                                    case exn of
                                        FFIFailure => 
                                            handle_io_error 
                                                new_reactor a_where fd_info None "read() failed"
                                      | IOBufferOverflow =>
                                            handle_io_error
                                                new_reactor a_where fd_info (Some (~1)) "read() failed with Buffer Overflow"
                                      | IOEndOfFile =>
                                            handle_io_error
                                                new_reactor a_where fd_info (Some (~2)) "read() results in End-Of-File"
                            )
                        end
                    ) else
                        (* Descriptor has not been connected yet, or there is no 
                            * EPOLLIN event occurred.
                            *
                            * If the descriptor is not connected, usually that means
                            * that there was some error event occurred on the descriptor,
                            * and we have not even tried to handle connect. *)
                        reactor
                )

        fun handle_write reactor (fd : int) events_mask =
            case ReactorType.get_fd_info_opt reactor fd of
                None => (
                    (* Descriptor has been deleted from the reactor by some handler. *)
                    reactor
                )
              | Some fd_info => (
                    if 
                        (* We are writing only in connected sockets, and only 
                         * if no errors occurred on the socket. *)
                        FdInfoType.get_is_connected_status fd_info
                            andalso
                        ReactorPrivate.is_writable events_mask
                            andalso
                        not (ReactorPrivate.is_error events_mask)
                    then (
                        delayed_write reactor fd_info
                    ) else
                        (* Descriptor has not been connected yet, or there is no 
                         * EPOLLOUT event occurred. 
                         *
                         * If the descriptor is not connected, usually that means
                         * that there was some error event occurred on the descriptor,
                         * and we have not even tried to handle connect. *)
                        reactor
                )
    in
        fun handle_read_data_stream reactor fd_info events_mask =
            let
                val a_where = "handle_read_data_stream"
                val fd = FdInfoType.get_fd fd_info
            in
                handle_read (handle_connect reactor a_where fd_info events_mask) a_where fd events_mask
            end

        fun handle_write_data_stream reactor fd_info events_mask =
            let
                val a_where = "handle_write_data_stream"
                val fd = FdInfoType.get_fd fd_info
            in
                handle_write (handle_connect reactor a_where fd_info events_mask) fd events_mask
            end

        fun handle_read_write_data_stream reactor fd_info events_mask =
            let
                val a_where = "handle_read_write_data_stream"
                val fd = FdInfoType.get_fd fd_info
            in
                handle_write (
                    handle_read (
                        handle_connect reactor a_where fd_info events_mask
                    ) a_where fd events_mask
                ) fd events_mask
            end
    end

    (**
     *  Internal function that handles new pending connection events at
     *  listening sockets. May terminate the reactor, if any error occurs
     *  during accepting a new connection.
     *)
    fun handle_accept reactor fd_info (events_mask : epoll_events_mask) =
        (**
         *  For Acceptor sockets, we are only interested in Readability events; also
         *  do NOT accept the connection if there was an EPoll-detected error on the
         *  Acceptor socket (it's just safer to do it this way); any other events 
         *  are silently ignored.
         *)
        if 
            not (ReactorPrivate.is_readable events_mask) 
                orelse 
            ReactorPrivate.is_error events_mask
        then
            reactor
        else
            let
                val logger = ReactorType.get_logger reactor

                val acceptor_fd = FdInfoType.get_fd fd_info
                val (AcceptHandler accept_handler) = FdInfoType.get_accept_handler fd_info

                fun accept_until_eagain r =
                    (* Acceptor can be removed from the reactor as a result of
                     * accept_handler callback. Due to that reason we have to ensure
                     * that the acceptor descriptor still exists in the reactor.
                     * If it has been deleted, we break from the accepting cycle. *)
                    if 
                        not (ReactorType.has_fd_info r acceptor_fd)
                    then 
                        r
                    else
                        let
                            val res = Ok (Socket.accept acceptor_fd)
                            handle exn => Error exn
                        in
                            case res of
                                Ok (client_fd, client_address, client_port) => (
                                    Logger.info 
                                        logger
                                        ("Reactor.handle_accept: FDListening=" ^ Int.toString acceptor_fd ^ 
                                         ". A new connection is accepted at FD=" ^ Int.toString client_fd ^
                                         ", from Address=" ^ InAddr.to_string client_address ^
                                         ", Port=" ^ Int.toString client_port ^ ".");
                                    let
                                        val (new_state, new_request_opt) = 
                                            accept_handler (ReactorType.get_state r) acceptor_fd client_fd (SockAddrIn client_address client_port)
                                    in
                                        ReactorType.set_state r new_state;
                                        accept_until_eagain (handle_function_request r new_request_opt)
                                    end
                                )
                              | Error FFIEintr => 
                                    (* Accepting call has been interrupted. Try again. *)
                                    accept_until_eagain r
                              | Error FFIEagain => 
                                    (* No more connections in the pending queue. We can return now. *)
                                    r
                              | Error FFIFailure => (
                                    (* Some unexpected error occurred while accepting a new connection.
                                     * This is a serious error condition, and we should terminate the reactor.
                                     *)
                                    handle_critical_io_error 
                                        r "handle_accept" fd_info None "accept() failed"
                              )
                        end
            in
                accept_until_eagain reactor
            end

    fun handle_timer reactor fd_info (events_mask : epoll_events_mask) =
        (* In timer we are only interested in Readability events;
         * all other events are silently ignored. *)
        if not (ReactorPrivate.is_readable events_mask)
        then reactor
        else
            let
                val logger = ReactorType.get_logger reactor
                
                val fd = FdInfoType.get_fd fd_info
                val (TimerHandler timer_handler) = FdInfoType.get_timer_handler fd_info
                val buff = FdInfoType.get_rd_buff fd_info

                fun on_read r (fd : int) (buff : io_buffer) = 
                    let
                        val data = IOBuffer.read buff 8
                        val n_expirations = MarshallingHelp.w82n_little data 0
                        val (new_state, new_request_opt) = timer_handler (ReactorType.get_state r) fd n_expirations
                    in
                        ReactorType.set_state r new_state;
                        (handle_function_request r new_request_opt, Word8Array.length data)
                    end

                val result = IO.read_until_eagain reactor fd buff on_read ReactorType.has_fd_info
            in
                case result of
                    Ok (new_reactor, n_total) => (
                        Logger.info
                            logger
                            ("Reactor.handle_timer: FD=" ^ Int.toString fd ^
                            ". Read n=" ^ Int.toString n_total ^ " bytes.");
                        new_reactor
                    )
                  | Error (new_reactor, n_total, exn) => (
                        (* User-defined error handler is invloked inside 
                         * `ReactorPrivate.handle_critical_io_error` function. *)
                        case exn of 
                            FFIFailure =>
                                (* In this case, we terminate the whole Reactor because
                                 * it is a serious INTERNAL error condition. *)
                                handle_critical_io_error 
                                    reactor "handle_timer" fd_info None "read() failed"
                          | IOBufferOverflow =>
                                (*  Means that there is some logical error on the reactor
                                 *  side, as it was we who created a buffer. 
                                 *  In this case, we terminate the whole Reactor as well. *)
                                handle_critical_io_error
                                    reactor "handle_timer" fd_info (Some ~1) "read() failed with Buffer Overflow"
                          | IOEndOfFile =>
                                (* In this case, we terminate the whole Reactor because
                                 * it is a serious INTERNAL error condition. *)
                                handle_critical_io_error
                                    reactor "handle_timer" fd_info (Some ~2) "read() results in End-Of-File"
                  )
            end

    fun handle_read_file reactor fd_info (events_mask : epoll_events_mask) =
        (* In read file we are only interested in Readability events;
         * all other events are silently ignored. *)
        if not (ReactorPrivate.is_readable events_mask)
        then reactor
        else
            let
                val logger = ReactorType.get_logger reactor

                val fd = FdInfoType.get_fd fd_info
                val (ReadHandler read_handler) = FdInfoType.get_read_handler fd_info
                val buff = FdInfoType.get_rd_buff fd_info

                fun on_read r (fd : int) (buff : io_buffer) =
                    let
                        val (new_state, n, new_request_opt) = read_handler (ReactorType.get_state r) fd buff
                    in
                        ReactorType.set_state r new_state;
                        (handle_function_request r new_request_opt, n)
                    end

                val result = IO.read_until_eagain reactor fd buff on_read ReactorType.has_fd_info
            in
                case result of
                    Ok (new_reactor, n_total) => new_reactor
                  | Error (new_reactor, n_total, exn) => (
                        (* User-defined error handler is invloked inside 
                         * `ReactorPrivate.handle_critical_io_error` function. *)
                        case  exn of
                            FFIFailure => 
                                handle_io_error 
                                    new_reactor "handle_read_file" fd_info None "read() failed"
                          | IOBufferOverflow =>
                                handle_io_error
                                    new_reactor "handle_read_file" fd_info (Some (~1)) "read() failed with Buffer Overflow"
                          | IOEndOfFile =>
                                handle_io_error
                                    new_reactor "handle_read_file" fd_info (Some (~2)) "read() results in End-Of-File"
                  )
            end

    fun handle_write_file reactor fd_info (events_mask : epoll_events_mask) =
        (* In write file we are only interested in Readability events;
         * all other events are silently ignored. But we are writing only
         * if there was no previous error, or write will likely fail. *)
        if 
            not (ReactorPrivate.is_writable events_mask)
                orelse
            ReactorPrivate.is_error events_mask
        then reactor
        else delayed_write reactor fd_info

    fun handle_poll_iteration reactor = (
        Logger.trace
            (ReactorType.get_logger reactor)
            ("Reactor.handle_poll_iteration: the iteration finished. " ^ 
             "on_poll callback function is being called.");
        let
            val (PollHandler poll_handler) = ReactorType.get_poll_handler reactor
            val (new_state, new_request_opt) = 
                poll_handler (ReactorType.get_state reactor)
        in
            ReactorType.set_state reactor new_state;
            handle_function_request reactor new_request_opt
        end
    )


end

structure Reactor =
struct
    fun get_state reactor = ReactorType.get_state reactor

    (* 
     *  Creates an epoll descriptor and initializes the reactor. 
     *
     *  @param state: a state that the reactor will return into callback functions.
     *  @param logger `logger`: a logger that will be used to journal errors.
     *
     *  @returns `'a reactor option`: if reactor initialization succeded,
     *      and setup request did not return reactor shutdown, 'Some reactor'
     *      would be returned. Otherwise, 'None'.
     *)
    fun init state logger setup_request on_poll =
        let
            fun create () = 
                let
                    val epoll_fd = Epoll.create ()
                    handle FFIFailure => (
                        ReactorPrivate.raise_reactor_system_error (fn errno =>
                            Logger.critical 
                                logger 
                                ("Reactor.init: epoll_create() failed with Error=" ^ 
                                 Int.toString errno ^ ".")
                                )
                    ) None
                in
                    Logger.info
                        logger 
                        ("Reactor.init: reactor created at FD=" ^ Int.toString epoll_fd ^ ".");
                    ReactorPrivate.init state logger epoll_fd on_poll
                end

            fun setup reactor =
                ReactorInternal.handle_function_request reactor (Some setup_request)

            val reactor_opt = Some (create ())
            handle ReactorSystemError errno => None
        in
            Option.map setup reactor_opt
            (* Clear the reactor and return None if any error occurs during the setup. *)
            handle _ => (ReactorPrivate.clear (Option.valOf reactor_opt); None)
        end

    (**
     *  Clears the reactor: removes all added file descriptors from the
     *  epoll mechanism. If the descriptor was created by the 
     *  reactor (actually, for now it means that the descriptor does
     *  not reffer to a file), close the descriptor. Closes main 
     *  epoll descriptor, mark the reactor as closed, which prevents 
     *  it from further usage.
     *
     *  Any errros are ignored here, and only logged with a 'warn' level of logging.
     *
     *  @param reactor `'a reactor`: a reactor that should be cleared.
     *)
    (* fun clear reactor = ReactorPrivate.clear reactor *)


    fun poll reactor (timeout_msec : int) = 
        let
            fun handle_epoll_event reactor epoll_event =
                let
                    val logger = ReactorType.get_logger reactor
                    
                    val fd = EpollEvent.fd epoll_event
                    val events_mask = EpollEvent.events epoll_event

                    val _ = Logger.info logger 
                        ("Reactor.poll: FD=" ^ Int.toString fd ^
                         ": " ^ EpollEventsMask.to_string events_mask ^ ".")
                in
                    ReactorInternal.handle_poll_iteration (
                        case ReactorType.get_fd_info_opt reactor fd of
                            None => (
                                Logger.warn 
                                    logger 
                                    ("Reactor.poll: OldFD=" ^ Int.toString fd ^
                                     ": No FDInfo, but still got Event=" ^ 
                                     EpollEventsMask.to_string events_mask ^ ".");
                                reactor
                            )
                          | Some fd_info => (
                                let
                                    val new_reactor = 
                                        case fd_info of
                                            (ReadDataStreamFdInfo _ _ _ _ _ _ _ _) => 
                                                ReactorInternal.handle_read_data_stream reactor fd_info events_mask
                                          | (WriteDataStreamFdInfo _ _ _ _ _ _ _) => 
                                                ReactorInternal.handle_write_data_stream reactor fd_info events_mask
                                          | (ReadWriteDataStreamFdInfo _ _ _ _ _ _ _ _ _) => 
                                                ReactorInternal.handle_read_write_data_stream reactor fd_info events_mask
                                          | (AcceptorFdInfo _ _ _ _) =>
                                                ReactorInternal.handle_accept reactor fd_info events_mask
                                          | (TimerFdInfo _ _ _ _ _) => 
                                                ReactorInternal.handle_timer reactor fd_info events_mask
                                          | (ReadFileFdInfo _ _ _ _ _) => 
                                                ReactorInternal.handle_read_file reactor fd_info events_mask
                                          | (WriteFileFdInfo _ _ _ _ ) =>
                                                ReactorInternal.handle_write_file reactor fd_info events_mask

                                    val fd = FdInfoType.get_fd fd_info
                                in
                                    if ReactorPrivate.is_error events_mask
                                    then
                                        if ReactorType.has_fd_info reactor fd
                                        then 
                                            (* The descriptor has not been deleted during usual event handling. 
                                             * Log the error and call the error handler. *)
                                            ReactorInternal.handle_io_error 
                                                reactor "poll" fd_info (Some 0)
                                                    ("epoll_wait() returned Events=" ^ 
                                                     EpollEventsMask.to_string events_mask ^ 
                                                     "which include erroneous events")
                                        else 
                                            (* The descriptor has been already deleted. Just return 
                                             * the reactor. *)
                                            new_reactor 
                                    else new_reactor
                                end
                            )
                    )
                end
            
            fun handle_epoll_events reactor epoll_events = 
                case epoll_events of
                    [] => ()
                  | (ev::evs) => (
                        handle_epoll_event reactor ev; 
                        handle_epoll_events reactor evs
                    )

            val logger = ReactorType.get_logger reactor
            val epoll_fd = ReactorType.get_epoll_fd reactor
            val max_events = List.length (Map.toAscList (ReactorType.get_fds reactor))

            fun wait_and_handle () =
                Epoll.wait epoll_fd max_events timeout_msec
                handle 
                    FFIEintr => (
                        (*  Avoid false exits if `epoll_wait` is interrupted.   *)
                        Logger.info logger "Reactor.poll: Interrupt occurred. Start again.";
                        wait_and_handle ()
                    )
                  | FFIFailure => (
                        (*  This is a critical error which most likely means incorrect logic.
                         *  For this reason, it is NOT passed to "ErrHandler" and not returned as
                         *  an error flag: Throw an exception instead
                         *)
                        Logger.critical
                            logger
                            ("Reactor.poll: epoll_wait() failed with Error=" ^ 
                             Int.toString (Errno.errno()) ^ ".");
                        raise ReactorExitRun
                    )
            val epoll_events = wait_and_handle ()
        in
            Logger.info 
                logger 
                ("Rector.poll: epoll_wait() returned with " ^ 
                 Int.toString (List.length epoll_events) ^ " ready descriptors.");
            handle_epoll_events reactor epoll_events
        end

    fun run reactor =
        let
            val timeout = ~1

            fun loop () = (
                poll reactor timeout;
                loop ()
            )
        in
            if True
            then 
                loop ()
                handle ReactorExitRun => ReactorPrivate.clear reactor
            else ()
        end
end

val _ = 
    Exception.add_exn_name_printer 
        (fn e =>
            case e of
                ReactorExitRun => "ReactorExitRun"
              | ReactorSystemError _ => "ReactorSystemError"
              | ReactorBadArgumentError => "ReactorBadArgumentError"
              | _ => raise Exception.Unknown
        )
val _ = 
    Exception.add_exn_message_printer
        (fn e =>
            case e of
                ReactorExitRun => "ReactorExitRun"
              | ReactorSystemError v => "ReactorSystemError" ^ " " ^ Int.toString v
              | ReactorBadArgumentError => "ReactorBadArgumentError"
              | _ => raise Exception.Unknown
        )
(**
 *  Type that represents key-value storage.
 *
 *  NOTE: Currently there is know need to have a separate type due to the fact
 *  that there is no in memory state stored in CakeML. However the practice when
 *  a function that logically assumes the state change is defined it needs a storage
 *  object as a parameter and return value. So, we make sure that if one day state
 *  appears we will not break compatability with other modules. Also we want to simplify
 *  formal verification in a way that all functions that have side effects always return
 *  updated storage.
 *
 *  @param has_batch: ```bool``` flag that controls whether batch created 
 *)
datatype storage = Storage bool;

(* Internal type that represents ffi error returned as a numeric code *)
datatype storage_error =
    (* DB expected to be open but it is closed and vice versa *) 
    StorageWrongStateError
    (* Can't open or close db *)
    | StorageStateChangeError
    (* Can't save value by key to database *) 
    | StoragePutError
    (* Can't fetch value by key from database *) 
    | StorageGetError
    (* Can't remove a value by key from database *) 
    | StorageDeleteError
    (* Batch request must be closed to open new one and vice versa *) 
    | StorageBatchWrongStateError
    (* An error occured on attemp to apply batch request to database *) 
    | StorageBatchFinalizationError
    (* An error occured on attempt to fully clear database *) 
    | StorageDestroyError
    (* Unexpected error code received from ffi function *) 
    | StorageUndefinedError;

(* Internal type to represent result of ffi function call *)
datatype storage_result = DBSuccess | DBFailure storage_error;

(**
 *  DB expected to be open but it is closed and vice versa.
 *  @param is_open: ```bool`` flag to represent whether database expected to be open or closed.
 *)
exception StorageWrongStateDetected bool;

(**
 *  Can't open or close db.
 *  @param opening: ```bool`` flag to represent whether database is attempted to be open.
 *)
exception StorageStateChangeFailed bool;

(**
 *  Can't save value by key to database.
 *  @param key: ```string`` key that is identifying the value.
 *  @param value: ```byte_array``` value attempted to be save in db.
 *  @param sync: ```bool``` flag defines whether operation is synchronious.
 *)
exception StoragePutFailed string byte_array bool;

(**
 *  Can't fetch value by key from database.
 *  @param key: ```string`` key that is identifying the value.
 *)
exception StorageGetFailed string;

(**
 *  Can't remove a value by key from database.
 *  @param key: ```string`` key that is identifying the value.
 *  @param sync: ```bool``` flag defines whether operation is synchronous.
 *)
exception StorageDeleteFailed string bool;

(**
 *  Unexpected batch request state.
 *  @param preparing: ```bool``` flag defines whether batch request is expected to be preparing or closed.
 *)
exception StorageBatchWrongStateDetected bool;

(**
 *  An error occured on attemp to apply batch request to database.
 *  @param sync: ```bool``` flag defines attempt to apply the request was synchronous.
 *)
exception StorageBatchFinalizationFailed bool;

(**
 *  An error occured on attempt to fully clear database.
 *)
exception StorageDestroyFailed;

(**
 *  Unexpected error code received from ffi function.
 *  @param storage_result: ```storage_result``` ffi call execution result that is unexpected
 *  for the current use case.
 *)
exception StorageUnexpectedStatus storage_result;

(**
 *  The structrure defines helper functions for internal usage such
 *  as parsing and preparing parameters for ffi functions call.
 *)
structure StoragePrivate =
struct
    fun set_has_batch (Storage _) has_batch = Storage has_batch; 
    
    fun prepare_bool_param param = 
        if param then
            ByteArray.to_string (Word8Array.array 1 (Word8.fromInt 1))
        else
            ByteArray.to_string (Word8Array.array 1 (Word8.fromInt 0));

    fun parse_status result =
        let
            val status = Word8.toInt (Word8Array.sub result 0)
        in
            case status of
                0 => DBSuccess
                | 1 => DBFailure StorageWrongStateError
                | 2 => DBFailure StorageStateChangeError
                | 3 => DBFailure StoragePutError
                | 4 => DBFailure StorageGetError
                | 5 => DBFailure StorageDeleteError
                | 6 => DBFailure StorageGetError
                | 7 => DBFailure StorageBatchWrongStateError
                | 8 => DBFailure StorageBatchFinalizationError
                | 9 => DBFailure StorageDestroyError
        end;
end;

(**
 *  The structrure defines public interface to communicate with a RocksDB database.
 *
 *  Implementation supports the following operations by key: put, get, delete. 
 *  Changes to database can be applied either sync or async. Moreover
 *  batch requests are also supported meaning that all operations inside
 *  are either applied all successfull or nothing changes in case if one of the operations
 *  failed.
 *
 *  NOTE: Database must be open before usage (see ```db_open```). Usually it is done
 *  after application starts. Also database must be closed (see ```db_close```) assuming that there will
 *  be no futher requests in the current runtime.
 *
 *  NOTE: Before adding operation to batch request it should be initiated by
 *  calling ```batch_prepare```. To apply operations one must call ```batch_write```.
 *)
structure Storage = 
struct

    (**
     *  Create the database without batch, useful for tests. 
     *  @return ```storage``` value without batch.
     *)
    fun create () = Storage False;
    
    (**
     *  Obtain has_batch value from storage. 
     *  @param storage: ```storage``` storage value that need to return has_batch value.
     *  @return new ```bool``` value.
     *)
    fun get_has_batch (Storage has_batch) = has_batch;
    
    (**
     *  Open the database to accept read/write requests. 
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database already open.
     *  @raises ```StorageStateChangeFailed``` when internal error occured during db opening.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during db opening.
     *
     *  NOTE: Database must be open before usage. Usually it is done
     *  after application starts.
     *)
    fun db_open storage = 
    	let
    		val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected False
                    | DBFailure StorageStateChangeError => raise StorageStateChangeFailed True
                    | _ => raise StorageUnexpectedStatus status;
    	in
    		(#(db_open) "" result; handle_status (StoragePrivate.parse_status result); storage)
    	end;

    (**
     *  Close the database. 
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database already closed.
     *  @raises ```StorageStateChangeFailed``` when internal error occured during db close.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during db close.
     *
     *)
    fun db_close storage = 
    	let
    		val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageStateChangeError => raise StorageStateChangeFailed False
                    | _ => raise StorageUnexpectedStatus status;
    	in
    		(#(db_close) "" result;  handle_status (StoragePrivate.parse_status result); storage)
    	end;

    (**
     *  Remove all data from the database. 
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is open and can't be cleared.
     *  @raises ```StorageDestroyFailed``` when internal error occured during db destroy.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during db destroy.
     *
     *)
    fun db_destroy storage =
        let
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected False
                    | DBFailure StorageDestroyError => raise StorageDestroyFailed
                    | _ => raise StorageUnexpectedStatus status;
        in
            (#(db_destroy) "" result;  handle_status (StoragePrivate.parse_status result); storage)
        end;

    (**
     *  Save a new value by key to the database.
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @param key: ```string``` key to associate the value with.
     *  @param value: ```byte_array``` binary data to associate with the key.
     *  @param flag: ```bool``` flag that states whether the operation must be synchronous.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be changed.
     *  @raises ```StoragePutFailed``` when internal error occured during save.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during save.
     *
     *)
    fun put storage key value sync = 
        let
            val key_size = ByteArray.to_string (BigEndian.int8byte8 (String.size key))
            val sync_param = StoragePrivate.prepare_bool_param sync
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StoragePutError => raise StoragePutFailed key value sync
                    | _ => raise StorageUnexpectedStatus status;
        in
            (#(db_put) (key_size ^ key ^ (ByteArray.to_string value) ^ sync_param) result;
            handle_status (StoragePrivate.parse_status result); 
            storage)
        end;

    (**
     *  Remove association between a value and a key from the database.
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @param key: ```string``` key to remove association with.
     *  @param flag: ```bool``` flag that states whether the operation must be synchronous.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be changed.
     *  @raises ```StorageDeleteFailed``` when internal error occured during delete.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during delete.
     *
     *)
    fun delete storage key sync =
        let
            val sync_param = StoragePrivate.prepare_bool_param sync
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageDeleteError => raise StorageDeleteFailed key sync
                    | _ => raise StorageUnexpectedStatus status;
        in
            (#(db_delete) (sync_param ^ key) result; handle_status (StoragePrivate.parse_status result); storage)
        end;

    (**
     *  Fetches the value associated with a key from the database.
     *  @param storage: ```storage``` storage value that is intended to be queried.
     *  @param key: ```string``` key to query.
     *  @return ```byte_array option``` (value if exists and None otherwise).
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be queried.
     *  @raises ```StorageGetFailed``` when internal error occured during query execution.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during query execution.
     *
     *)
    fun get storage key = 
        let
            val prep_result = ByteArray.make_empty (1 + 8)

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageGetError => raise StorageGetFailed key
                    | _ => raise StorageUnexpectedStatus status;

            fun prepare () =
                let
                    val prep_result = ByteArray.make_empty (1 + 8)
                in
                    (#(db_get_prepare) key prep_result; 
                    handle_status (StoragePrivate.parse_status prep_result); 
                    BigEndian.byte8int8 (ByteArray.range prep_result 1 8))
                end

            fun finalize vallen =
                let
                    val final_result = ByteArray.make_empty (vallen + 1)
                in
                    if ((Int.compare vallen 0) = Greater) then
                        (#(db_get_finalize) "" final_result; 
                        handle_status (StoragePrivate.parse_status final_result);
                        Some (ByteArray.range final_result 1 vallen))
                    else
                        None
                end
        in
            finalize (prepare ())
        end;

    (**
     *  Starts new batch request. This method always must be called before calling
     *  batch operational methods (for example, ```batch_put```).
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be changed.
     *  @raises ```StorageBatchWrongStateDetected``` when preparing batch request already exists.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured during batch request creation.
     *)
    fun batch_prepare storage = 
        let
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageBatchWrongStateError => raise StorageBatchWrongStateDetected False
                    | _ => raise StorageUnexpectedStatus status;            
        in
            (#(db_write_batch_prepare) "" result; handle_status (StoragePrivate.parse_status result); (StoragePrivate.set_has_batch storage True))
        end;

    (**
     *  Add put operation to the current batch request.
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @param key: ```string``` key to associate the value with.
     *  @param value: ```byte_array``` binary data to associate with the key.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be changed.
     *  @raises ```StorageBatchWrongStateDetected``` when there is no pending batch request.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured.
     *
     *)
    fun batch_put storage key value = 
        let
            val key_size = ByteArray.to_string (BigEndian.int8byte8 (String.size key))
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageBatchWrongStateError => raise StorageBatchWrongStateDetected True
                    | _ => raise StorageUnexpectedStatus status;
        in
            (#(db_write_batch_put) (key_size ^ key ^ (ByteArray.to_string value)) result;
            handle_status (StoragePrivate.parse_status result); 
            storage)
        end;

    (**
     *  Add delete operation to the current batch request.
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @param key: ```string``` key to remove assciation with.
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be changed.
     *  @raises ```StorageBatchWrongStateDetected``` when there is no pending batch request.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured.
     *
     *)
    fun batch_delete storage key = 
        let
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageBatchWrongStateError => raise StorageBatchWrongStateDetected True
                    | _ => raise StorageUnexpectedStatus status;
        in
            (#(db_write_batch_delete) key result; handle_status (StoragePrivate.parse_status result); storage)
        end;

    (**
     *  Apply current batch request to the database.
     *  @param storage: ```storage``` storage value that is intended to be changed.
     *  @param sync: ```bool``` flag that controls whether changes must be applied synchronous
     *  @return new ```storage``` value.
     *
     *  @raises ```StorageWrongStateDetected``` when database is closed and can't be changed.
     *  @raises ```StorageBatchWrongStateDetected``` when there is no pending batch request to apply.
     *  @raises ```StorageBatchFinalizationFailed``` when internal error occured during batch application.
     *  @raises ```StorageUnexpectedStatus``` when unexpected error occured.
     *
     *)
    fun batch_write storage sync = 
        let
            val sync_param = StoragePrivate.prepare_bool_param sync
            val result = ByteArray.make_empty 1

            fun handle_status status =
                case status of
                    DBSuccess => ()
                    | DBFailure StorageWrongStateError => raise StorageWrongStateDetected True
                    | DBFailure StorageBatchWrongStateError => raise StorageBatchWrongStateDetected True
                    | DBFailure StorageBatchFinalizationError => raise StorageBatchFinalizationFailed sync
                    | _ => raise StorageUnexpectedStatus status;
        in
            (#(db_write_batch_finalize) sync_param result; handle_status (StoragePrivate.parse_status result); (StoragePrivate.set_has_batch storage False))
        end;
end;

let
    fun storage_error_to_string storage_error =
        case storage_error of
            StorageWrongStateError => "StorageWrongStateError"
          | StorageStateChangeError => "StorageStateChangeError"
          | StoragePutError => "StoragePutError"
          | StorageGetError => "StorageGetError"
          | StorageDeleteError => "StorageDeleteError"
          | StorageBatchWrongStateError => "StorageBatchWrongStateError"
          | StorageBatchFinalizationError => "StorageBatchFinalizationError"
          | StorageDestroyError => "StorageDestroyError"
          | StorageUndefinedError => "StorageUndefinedError"
    
    fun storage_result_to_string storage_result = 
        case storage_result of
            DBSuccess => "DBSuccess"
          | DBFailure storage_error => "( DBFailure " ^ storage_error_to_string storage_error ^ " )"
in
    Exception.add_exn_message_printer
	(fn e =>
		case e of
			StorageWrongStateDetected v => 
                "StorageWrongStateDetected" ^ " " ^ Bool.toString v
          | StorageStateChangeFailed v => 
                "StorageStateChangeFailed" ^ " " ^ Bool.toString v
          | StoragePutFailed v1 v2 v3 => 
                "StoragePutFailed" ^ " " ^ v1 ^ " " ^ Hex.bytes_to_hex v2 ^ " " ^ Bool.toString v3
          | StorageGetFailed v => 
                "StorageGetFailed" ^ " " ^ v
          | StorageDeleteFailed v1 v2 => 
                "StorageDeleteFailed" ^ " " ^ v1 ^ " " ^ Bool.toString v2
          | StorageBatchWrongStateDetected v => 
                "StorageBatchWrongStateDetected" ^ " " ^ Bool.toString v
          | StorageBatchFinalizationFailed v => 
                "StorageBatchFinalizationFailed" ^ " " ^ Bool.toString v
          | StorageDestroyFailed => "StorageDestroyFailed"
          | StorageUnexpectedStatus v => 
                "StorageUnexpectedStatus" ^ " " ^ storage_result_to_string v
		  | _ => raise Exception.Unknown
	)
end;
structure SafetyReader = 
struct
	fun read storage =
		case (Storage.get storage (SafetyData.db_key ())) of
            Some safety_data => fst (SafetyData.deserialize safety_data)
            | None => (SafetyData.init ());
end;structure SafetyWriter = 
struct
	fun write storage data =
		let
            val value = SafetyData.serialize data
        in
        	if (Storage.get_has_batch storage) then
				Storage.batch_put storage (SafetyData.db_key ()) value
			else
				Storage.put storage (SafetyData.db_key ()) value True
        end;
end;datatype tx_accumulator = TxAccumulator ((string, hash_value) map) int;
exception TxAccumulatorEmptyRoot;

datatype key = Key int int ;
structure Key = 
struct

    fun get_key (Key i r) = 
        Int.toString i ^ " " ^ Int.toString r

    fun get_number (Key number _ ) = number

    fun get_layer (Key _ layer ) = layer

    fun get_left_child_key (Key i r) = 
        Int.toString i ^ " " ^ Int.toString (r-1)

    fun get_right_child_key (Key i r) = 
        Int.toString (i+(exp 2 (r-1))) ^ " " ^ Int.toString (r-1)

    fun left_child (Key i r) = Key i (r-1)

    fun right_child (Key i r) = Key (i+(exp 2 (r-1))) (r-1)

    fun inc_number (Key number layer ) = Key (number+1) layer 

    fun db_key (Key i r) =
		"proof_node" ^ (Hex.bytes_to_hex (HashFunction.calculate_from_bytes (ByteArray.concat (Serialization.encode_int_flex i) (Serialization.encode_int_flex r))));

end;

structure TxAccumulatorPrivate = 
struct
    fun get_tree (TxAccumulator tree _) = tree;
end;

structure TxAccumulator = 
struct

    fun init () = TxAccumulator (Map.empty (String.compare)) 0

    fun format_tr_info_list tr_info_list accum key = 
        case tr_info_list of
           [] => accum
         | (x::tl) => format_tr_info_list tl (Map.insert accum (Key.get_key key) (HashFunction.calculate_from_bytes (TransactionInfo.serialize x)) ) (Key.inc_number key)

    fun insert_transactions (TxAccumulator frozen n) tr_info_list =
        let
            val key = Key n 0 
            val result = format_tr_info_list tr_info_list frozen key
            val new_tr_number = n + (List.length tr_info_list)
        in
          TxAccumulator result new_tr_number
        end
        
    fun reduce (TxAccumulator frozen n) version =
        if version < n then
            let
                fun copy_at mapping key =
                    Map.insert mapping key (Option.valOf (Map.lookup frozen key))

                val frozen = List.foldl 
                        (fn mapping => fn v => copy_at mapping (Key.get_key (Key v 0))) 
                        (Map.empty (String.compare))
                        (List.genlist (fn index => index) version)
            in
                TxAccumulator frozen version
            end
        else
            TxAccumulator frozen n


    fun logarithm value =
        let
         val start_val = 0
         fun calculate x lg = 
            case x of
            0 => if (Word64.toInt ( Word64.andb (Word64.fromInt value) (Word64.fromInt 1))) = 0 
                    then 
                        if (exp 2 (lg-1)) = value
                        then 
                            (lg-1)
                        else 
                            lg
                    else 
                        lg
            | n => calculate (Word64.toInt (Word64.>> (Word64.fromInt x) 1)) (lg+1)
        in
         calculate value start_val
        end

    local
		val default_hash = HashFunction.calculate_from_bytes (Serialization.encode_int32 19092389)
	in
		fun get_defaul_hash () = default_hash;
	end
    
    fun merkls_tree m key n tr = 
        let
            val mapkey = Key.get_key key
            val left_child_key = Key.left_child key
            val left_child_mapkey = Key.get_left_child_key key
            val right_child_key = Key.right_child key
            val right_child_mapkey = Key.get_right_child_key key
        in
            if Option.isSome (Map.lookup tr mapkey)
            then (Map.insert m mapkey (Option.valOf (Map.lookup tr mapkey)) )
            else
                if (Key.get_layer key) = 0
                then
                    if (Key.get_number key) < n
                    then (Map.insert m mapkey (Option.valOf (Map.lookup tr mapkey)))
                    else (Map.insert m mapkey (get_defaul_hash ()))
                else
                    let
                        val left_child = merkls_tree m left_child_key n tr
                        val right_child = merkls_tree m right_child_key n tr  
                        fun calculate_hash h1 h2 = 
                            (HashFunction.calculate_from_bytes (ByteArray.concat h1 h2))
                    in
                        if (Key.get_number right_child_key) >= n 
                        then 
                            ( Map.insert 
                                ( Map.insert 
                                    left_child
                                    mapkey 
                                    (calculate_hash
                                        (Option.valOf (Map.lookup left_child left_child_mapkey) 
                                        ) (
                                        get_defaul_hash ()
                                        )
                                    ) 
                                ) right_child_mapkey (get_defaul_hash ())
                            )
                        else
                            ( Map.insert 
                                (Map.union left_child right_child )
                                mapkey
                                (calculate_hash
                                    (Option.valOf (Map.lookup left_child left_child_mapkey)
                                    ) (
                                    Option.valOf (Map.lookup right_child right_child_mapkey)
                                    )
                                ) 
                            )
                    end
                    
        end

    fun rebuild_tree m key n tr = 
        let
            val mapkey = Key.get_key key
            val left_child_key = Key.left_child key
            val left_child_mapkey = Key.get_left_child_key key
            val right_child_key = Key.right_child key
            val right_child_mapkey = Key.get_right_child_key key
        in
            if (Key.get_layer key) = 0
                then
                    if (Key.get_number key) < n
                    then (Map.insert m mapkey (Option.valOf (Map.lookup tr mapkey)))
                    else (Map.insert m mapkey (get_defaul_hash ()))
                else
                    let
                        val left_child = rebuild_tree m left_child_key n tr
                        val right_child = rebuild_tree m right_child_key n tr  
                        fun calculate_hash h1 h2 = 
                            (HashFunction.calculate_from_bytes (ByteArray.concat h1 h2))
                    in
                        if (Key.get_number right_child_key) >= n 
                        then 
                            ( Map.insert 
                                ( Map.insert 
                                    left_child
                                    mapkey 
                                    (calculate_hash
                                        (Option.valOf (Map.lookup left_child left_child_mapkey) 
                                        ) (
                                        get_defaul_hash ()
                                        )
                                    ) 
                                ) right_child_mapkey (get_defaul_hash ())
                            )
                        else
                            ( Map.insert 
                                (Map.union left_child right_child )
                                mapkey
                                (calculate_hash
                                    (Option.valOf (Map.lookup left_child left_child_mapkey)
                                    ) (
                                    Option.valOf (Map.lookup right_child right_child_mapkey)
                                    )
                                ) 
                            )
                    end        
        end

    fun get_depth (TxAccumulator _ n) = logarithm n
    
    fun get_tr_number (TxAccumulator _ n) = n
    
    fun get_tree (TxAccumulator tree _) = tree

    fun get_root accum =
        let
            val key = Key 0 (get_depth accum)
        in
           Map.lookup (TxAccumulatorPrivate.get_tree accum) (Key.get_key key)
        end;

    fun calculate_merkls_tree accum = 
        let
          val empty_map = Map.empty (String.compare)
          val key = Key 0 (get_depth accum)
          val tr_number = get_tr_number accum
          val transactions = get_tree accum
          val tree = merkls_tree empty_map key tr_number transactions
        in
          TxAccumulator tree tr_number
        end

    fun recalculate_merkle_tree accum =
        let
          val empty_map = Map.empty (String.compare)
          val key = Key 0 (get_depth accum)
          val tr_number = get_tr_number accum
          val transactions = get_tree accum
          val tree = rebuild_tree empty_map key tr_number transactions
        in
          TxAccumulator tree tr_number
        end

    fun print_accum (TxAccumulator tree n) = 
        let 
            fun print_map value =
                case value of
                [] => ()
                | (x,y)::tl => (print (x ^ " " ^ (Hex.bytes_to_hex y) ^ "\n" ); print_map tl)
        in
            (print_map (Map.toAscList tree); print ("number of transactions: " ^ (Int.toString n) ^ "\n"))
        end

    fun equal accum1 accum2 = 
        let
            val equal_tr_number = Int.compare (get_tr_number accum1) (get_tr_number accum2)
            val equal_tree = Comparators.eq_map ByteArray.equal (get_tree accum1) (get_tree accum2)
        in
            (equal_tr_number = Equal) andalso equal_tree
        end

    fun check (TxAccumulator tree vertex_count) = 
        let
            fun is_parrent parrent lchild rchild = 
                let
                    val concat = ByteArray.concat lchild rchild
                    val calculated_hash = HashFunction.calculate_from_bytes concat
                in
                    ByteArray.equal parrent calculated_hash
                end
                
            fun from_root key =
                let
                    val lchild_key = Key.left_child key
                    val rchild_key = Key.right_child key
                    
                    val parrent_mapkey = Key.get_key key
                    val lchild_mapkey = Key.get_left_child_key key
                    val rchild_mapkey = Key.get_right_child_key key

                    val parrent_hash = Map.lookup tree parrent_mapkey
                    val lchild_hash = Map.lookup tree lchild_mapkey
                    val rchild_hash = Map.lookup tree rchild_mapkey
                in
                    if Option.isSome parrent_hash
                    then
                        if Option.isNone lchild_hash
                        then
                            if Option.isNone rchild_hash
                            then
                                True
                            else
                                False
                        else
                            if Option.isNone rchild_hash
                            then
                                (from_root lchild_key) andalso 
                                (is_parrent (Option.valOf parrent_hash) (Option.valOf lchild_hash) (get_defaul_hash ()))
                            else
                                (from_root lchild_key) andalso 
                                (from_root rchild_key) andalso 
                                (is_parrent (Option.valOf parrent_hash) (Option.valOf lchild_hash) (Option.valOf rchild_hash))
                    else
                        raise TxAccumulatorEmptyRoot             
                end

            val root_key = Key 0 (get_depth (TxAccumulator tree vertex_count) )
        in
            from_root root_key
        end
end; 

local
    fun exn_printer e =
        case e of
            TxAccumulatorEmptyRoot => "TxAccumulatorEmptyRoot"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
structure AccumulatorReader = 
struct
    fun read storage key accum = 
        let
            val db_key = Key.db_key key
            val map_key = Key.get_key key
            val result = Storage.get storage db_key
        in
            if Option.isSome result
            then 
                Some (Map.insert accum map_key (Option.valOf result))
            else 
                None
        end
    
    local
		val default_hash = HashFunction.calculate_from_bytes (Serialization.encode_int32 19092389)
	in
		fun get_defaul_hash () = default_hash;
	end

    fun count_transactions storage = 
        let
            val new_key = Key 0 0
            fun count storage key = 
                if (Option.isSome (Storage.get storage (Key.db_key key))) andalso ((ByteArray.equal (Option.valOf (Storage.get storage (Key.db_key key))) (get_defaul_hash())) = False)
                then
                    count storage (Key.inc_number key)
                else
                    Key.get_number key
        in
            count storage new_key
        end


    fun read_tree storage key accum = 
        if (Key.get_layer key) = 0
		then 
            let
                val result = read storage key accum 
            in
                if Option.isSome result
                then Option.valOf result
                else accum
            end
		else
            let
                val left = read_tree storage (Key.left_child key) accum 
                val right = read_tree storage (Key.right_child key) left
                val result = read storage key right
            in
                if Option.isSome result
                then Option.valOf result
                else accum
            end
    
    fun read_full_tree storage = 
        let
            val tr_number = count_transactions storage
            val key = Key 0 (TxAccumulator.logarithm tr_number)
            val empty_map = Map.empty (String.compare)
        in
          read_tree storage key empty_map
        end

    fun read_frosen storage key accum r_key = 
        let
            val result = if key = r_key then None else read storage key accum 
            val lchild = Key.left_child key
            val rchild = Key.right_child key
            val rkey = Key.get_key rchild
        in
            if (Key.get_layer key) = 0 
            then 
                if (Option.isSome result) 
                then Option.valOf result
                else accum
            else
                let
                    val r_branch = read_frosen storage rchild (if (Option.isSome result) then (Option.valOf result) else accum) r_key
                    val r_hash = Map.lookup r_branch rkey
                in
                    if Option.isSome r_hash
                    then
                        if ByteArray.equal (Option.valOf r_hash) (get_defaul_hash ())
                        then 
                            read_frosen storage lchild accum r_key
                        else 
                            r_branch
                    else
                        read_frosen storage lchild r_branch r_key
                end
        end 

    fun read_state_root storage =
        let
            val tr_number = count_transactions storage
            val key = Key 0 (TxAccumulator.logarithm tr_number)
            val empty_map = Map.empty (String.compare)
            val state_root = read storage key empty_map
        in
            if Option.isSome state_root
            then Option.valOf (Map.lookup (Option.valOf state_root) (Key.get_key key))
            else (get_defaul_hash ())
        end 

    fun read_accumulator storage =
        let
            val tr_number = count_transactions storage
            val key = Key 0 (TxAccumulator.logarithm tr_number)
            val empty_map = Map.empty (String.compare)
            val state_root = TxAccumulator (Map.insert empty_map (Key.get_key key) (read_state_root (Storage.create ()))) tr_number 
            val left_child = (Key.left_child key)
            val right_child = (Key.right_child key)
        in
            if tr_number = exp 2 (Key.get_layer key)
            then state_root
            else
                let
                    val r_frosen = (read_frosen storage right_child empty_map right_child) 
                    val l_frosen = (Option.valOf (read storage left_child empty_map))
                in
                    TxAccumulator ( Map.union r_frosen l_frosen) tr_number 
                end
              
        end

    fun read_full_accumulator storage = 
        let
            val tr_number = count_transactions storage
            val key = Key 0 (TxAccumulator.logarithm tr_number)
            val empty_map = Map.empty (String.compare)
            val tree = read_tree storage key empty_map
        in
            TxAccumulator tree tr_number 
        end

end;

structure AccumulatorWriter = 
struct

    fun write batch key tree =
		let
		  	val hash = (Map.lookup tree (Key.get_key key))
			val db_key = Key.db_key key
		in
		  	if Option.isSome hash
        			then 
        				if (Storage.get_has_batch batch) then
        					Storage.batch_put batch db_key (Option.valOf hash)
					else
						Storage.put batch db_key (Option.valOf hash) True
				else batch
		end

	fun write_tree batch key tree =
		if (Key.get_layer key) = 0
		then write batch key tree
		else
			let
				val lbatch = write_tree batch (Key.left_child key) tree
				val rbatch = write_tree lbatch (Key.right_child key) tree
			in
				write rbatch key tree
			end

	fun write_accumulator storage accumulator =
		let
		  	val key = (Key 0 (TxAccumulator.get_depth accumulator))
			val tree = (TxAccumulator.get_tree accumulator)
		in
		  	if (Storage.get_has_batch storage) then
                write_tree storage key tree
            else
                Storage.batch_write (write_tree (Storage.batch_prepare storage) key tree) True
		end

end;
structure TransactionDbKey =
struct
	fun tx_version_key tx =
		("tx" ^ (ByteArray.to_string (HashFunction.calculate_from_bytes (TransactionPayload.serialize (SignedTransaction.get_payload tx)))));

	fun tx_key tx_version =
		("tx" ^ (ByteArray.to_string (HashFunction.calculate_from_bytes (Serialization.encode_int_flex tx_version))));
	
	fun tx_count_key () = "tx_count";
	
	fun li_key li_index =
		("li" ^ (ByteArray.to_string (HashFunction.calculate_from_bytes (Serialization.encode_int_flex li_index))));
		
	fun li_count_key () = "li_count";
end;
datatype commited_transaction = CommitedTransaction int int signed_transaction 

structure TransactionReader =
struct
	fun read_tx_version storage tx_hash =
		case (Storage.get storage ("tx" ^ (ByteArray.to_string tx_hash))) of 
				Some tx_version_ser => Some (fst (Serialization.decode_int_flex tx_version_ser))
				| None => None;

	fun read_tx storage tx_version =
		case (Storage.get storage (TransactionDbKey.tx_key tx_version)) of
				Some tuple_ser => Some (fst (Serialization.decode_tuple2 SignedTransaction.deserialize Serialization.decode_int_flex tuple_ser))
				| None => None;
		
	fun read_tx_count storage =
		 case (Storage.get storage (TransactionDbKey.tx_count_key ())) of
				Some tx_count_ser => Some (fst (Serialization.decode_int_flex tx_count_ser))
				| None => None;
	
	fun read_li storage li_index =
		case (Storage.get storage (TransactionDbKey.li_key li_index)) of
				Some signed_ledger_info_ser => Some (fst (SignedLedgerInfo.deserialize signed_ledger_info_ser))
				| None => None;
	
	fun read_li_count storage =
		case (Storage.get storage (TransactionDbKey.li_count_key ())) of
				Some li_count_ser => Some (fst (Serialization.decode_int_flex li_count_ser))
				| None => None;
				
	fun get_commited_transaction storage tx_hash =	
		let
			val tx_version = read_tx_version storage tx_hash
			val tuple = Option.mapPartial (fn version => read_tx storage version) tx_version
		in
			Option.map2 (fn version => fn (tx, li_index) => CommitedTransaction li_index version tx) tx_version tuple
		end;
end;
structure TransactionWriter =
struct
	fun write_tx_version storage tx tx_version =
		if (Storage.get_has_batch storage) then
			Storage.batch_put storage (TransactionDbKey.tx_version_key tx) (Serialization.encode_int_flex tx_version)
		else
			Storage.put storage (TransactionDbKey.tx_version_key tx) (Serialization.encode_int_flex tx_version) True;
		
	fun write_tx storage tx_version tx li_index  =
		if (Storage.get_has_batch storage) then
			Storage.batch_put storage (TransactionDbKey.tx_key tx_version) (Serialization.encode_tuple2 SignedTransaction.serialize Serialization.encode_int_flex (tx, li_index))
		else
			Storage.put storage (TransactionDbKey.tx_key tx_version) (Serialization.encode_tuple2 SignedTransaction.serialize Serialization.encode_int_flex (tx, li_index)) True;

	fun write_tx_count storage tx_count =
		if (Storage.get_has_batch storage) then
			Storage.batch_put storage (TransactionDbKey.tx_count_key ()) (Serialization.encode_int_flex tx_count)
		else
			Storage.put storage (TransactionDbKey.tx_count_key ()) (Serialization.encode_int_flex tx_count) True;
		
	fun write_li storage li_index signed_ledger_info =
		if (Storage.get_has_batch storage) then
			Storage.batch_put storage (TransactionDbKey.li_key li_index) (SignedLedgerInfo.serialize signed_ledger_info)
		else
			Storage.put storage (TransactionDbKey.li_key li_index) (SignedLedgerInfo.serialize signed_ledger_info) True;
		
	fun write_li_count storage li_count =
		if (Storage.get_has_batch storage) then
			Storage.batch_put storage (TransactionDbKey.li_count_key ()) (Serialization.encode_int_flex li_count)
		else
			Storage.put storage (TransactionDbKey.li_count_key ()) (Serialization.encode_int_flex li_count) True;
end;
datatype raw_key = RawKey (bool Vector.vector);

exception RawKeyIndexOutOfBounds int int;

structure RawKey = 
struct
	fun empty () = RawKey (Vector.fromList []);

	fun from_items items = RawKey (Vector.fromList items);

	fun length (RawKey v) = Vector.length v;

	fun compare (RawKey v1) (RawKey v2) =
		Vector.collate Bool.compare v1 v2;
	
	fun equal k1 k2 = (compare k1 k2 = Equal);

	fun bit_at (RawKey v) index =
		let
			val len = Vector.length v
		in
			if len > index then
				Vector.sub v index
			else
				raise RawKeyIndexOutOfBounds len index
		end;

	fun common_prefix (RawKey v1) (RawKey v2) =
		let
			val min_len = min (Vector.length v1) (Vector.length v2)
			val l1 = List.take (Vector.toList v1) min_len
			val l2 = List.take (Vector.toList v2) min_len
		in
			RawKey (Vector.fromList (fst (List.unzip (List.takeUntil (fn p => not ((fst p) = (snd p))) (List.zip (l1, l2))))))
		end;

	fun concat (RawKey prefix) (RawKey suffix) =
		RawKey (Vector.concat [prefix, suffix]);

	fun next r value =
		concat r (from_items [value])

	fun from_bytes bytes =
		let
			val bytes_len = Word8Array.length bytes

			fun calc_at index =
				let
					val byte_index = Int.div index 8
					val byte = Word8Array.sub bytes byte_index
					val is_zero_bit = (Word8.toInt (Word8.andb byte (Word8.<< (Word8.fromInt 1) (index - byte_index * 8))) = 0)
				in
					not is_zero_bit
				end
		in
			RawKey (Vector.tabulate (bytes_len * 8) calc_at)
		end;

	fun from_hex hex =
		from_bytes (Hex.hex_to_bytes hex);

	fun to_string (RawKey v) =
		String.concat (List.map (fn b => if b then "1" else "0") (Vector.toList v));

	fun serialize (RawKey v) =
		Serialization.encode_list Serialization.encode_bool (Vector.toList v);

	fun deserialize bytes =
		let
			val (lst, lst_len) = Serialization.decode_list Serialization.decode_bool bytes
		in
			(from_items lst, lst_len)
		end;
end;

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
			RawKeyIndexOutOfBounds _ _ => "RawKeyIndexOutOfBounds" 
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
			RawKeyIndexOutOfBounds v1 v2 => 
				"RawKeyIndexOutOfBounds" ^ " " ^ Int.toString v1 ^ " " ^ Int.toString v2
		  | _ => raise Exception.Unknown
	)
datatype state_key = StateKey raw_key int;

structure StateKey = 
struct
	fun create r v = StateKey r v;

	fun get_raw (StateKey r _) = r;

	fun get_version (StateKey _ v) = v;

	fun set_version (StateKey r _) v = StateKey r v;

	fun key_length (StateKey r _) = RawKey.length r;

	fun next_key (StateKey r v) item = 
		StateKey (RawKey.concat r (RawKey.from_items [item])) v;

	fun inc_version (StateKey r v) = StateKey r (v + 1);

	fun root version =
		StateKey (RawKey.empty ()) version;

	fun compare (StateKey r1 v1) (StateKey r2 v2) =
		let
			val version_order = Int.compare v1 v2
		in
			if version_order = Equal then
				RawKey.compare r1 r2
			else
				version_order
		end

	fun equal k1 k2 =
		compare k1 k2 = Equal;

	fun serialize (StateKey raw version) = 
		ByteArray.concat (RawKey.serialize raw) (Serialization.encode_int_flex version);

	fun deserialize bytes =
		let
			val (raw, raw_len) = RawKey.deserialize bytes
			val (version, version_len) = Serialization.decode_int_flex (ByteArray.suffix bytes raw_len)
		in
			(StateKey raw version, raw_len + version_len)
		end;

	fun db_key state_key =
		"state_node" ^ (ByteArray.to_string (serialize state_key));

	fun to_string prefix state_key =
		(prefix ^ "StateKey" ^ "\n")
			^
		(prefix ^ "  " ^ "Raw key: " ^ RawKey.to_string (get_raw state_key) ^ "\n")
			^
		(prefix ^ "  " ^ "Version: " ^ Int.toString (get_version state_key))
end;datatype state_tree_change = StateTreeChange (state_key option) account;

structure StateTreeChange = 
struct
	fun compare (StateTreeChange _ a1) (StateTreeChange _ a2) = 
		ByteArray.compare (Account.get_account_id a1) (Account.get_account_id a2);

	fun set_key (StateTreeChange _ a) k = StateTreeChange k a;
	fun set_account (StateTreeChange k _) a = StateTreeChange k a;

	fun get_key (StateTreeChange k _) = k;
	fun get_account (StateTreeChange _ a) = a;
end;datatype state_node = StateNull
	| StateInternal hash_value (state_key option) (state_key option)
	| StateLeaf hash_value account;

structure StateNode = 
struct
	fun left_child s =
		case s of
			StateInternal _ l _ => l
			| _ => None;

	fun right_child s =
		case s of
			StateInternal _ _ r => r
			| _ => None;

	fun equal n1 n2 =
		let
			fun equal_leaf (StateLeaf h1 a1) (StateLeaf h2 a2) =
				(ByteArray.equal h1 h2) andalso (Account.equal a1 a2);

			fun equal_internal (StateInternal h1 l1 r1) (StateInternal h2 l2 r2) =
				(ByteArray.equal h1 h2) andalso
				((Option.compare (StateKey.compare) l1 l2) = Equal) andalso
				((Option.compare (StateKey.compare) r1 r2) = Equal);
		in
			case (n1, n2) of
				(StateNull, StateNull) => True
				| ((StateLeaf h1 a1), (StateLeaf h2 a2)) => equal_leaf (StateLeaf h1 a1) (StateLeaf h2 a2)
				| ((StateInternal h1 l1 r1), (StateInternal h2 l2 r2)) => equal_internal (StateInternal h1 l1 r1) (StateInternal h2 l2 r2)
				| (_, _) => False
		end;

	fun serialize node =
		let
			fun encode_leaf hash account =
				ByteArray.concat hash (Account.serialize account);

			fun encode_internal hash left right =
				let
					val left_encode = Serialization.encode_option (StateKey.serialize) left
					val right_encode = Serialization.encode_option (StateKey.serialize) right
				in
					ByteArray.concat hash (ByteArray.concat left_encode right_encode)
				end;
		in
			case node of
				StateNull => Serialization.encode_int8 0
				| StateInternal hash left right  => ByteArray.concat (Serialization.encode_int8 1) (encode_internal hash left right)
				| StateLeaf hash account => ByteArray.concat (Serialization.encode_int8 2) (encode_leaf hash account)
		end;

	fun deserialize bytes =
		let
			val (node_type, type_len) = Serialization.decode_int8 bytes

			fun decode_internal bytes type_len =
				let
					val hash_len = HashFunction.size ()
					val hash = ByteArray.prefix bytes hash_len
					val (left, left_len) = Serialization.decode_option (StateKey.deserialize) (ByteArray.suffix bytes hash_len)
					val (right, right_len) = Serialization.decode_option (StateKey.deserialize) (ByteArray.suffix bytes (hash_len + left_len))
				in
					(StateInternal hash left right, type_len + hash_len + left_len + right_len)
				end;

			fun decode_leaf bytes type_len =
				let
					val hash_len = HashFunction.size ()
					val hash = ByteArray.prefix bytes hash_len
					val (account, acc_len) = Account.deserialize (ByteArray.suffix bytes hash_len)
				in
					(StateLeaf hash account, type_len + hash_len + acc_len)
				end;
		in
			case node_type of
				0 => (StateNull, type_len)
				| 1 => decode_internal (ByteArray.suffix bytes type_len) type_len
				| 2 => decode_leaf (ByteArray.suffix bytes type_len) type_len
		end
end;structure StateTreeReader = 
struct
	fun read db key = 
		let
			val db_key = StateKey.db_key key
			val encoded_value = Storage.get db db_key
		in
			Option.map (fn e => fst (StateNode.deserialize e)) encoded_value
		end;
end;(**
 *	Type that represents state tree responsible for account storage for each version 
 *	and merkle hash calculation based on accounts list. 
 *
 *	@param store: ```map``` key value store mapping key to node.
 *	@param version: ```int``` current version of the tree meaning a number
 *	of upgrades (see ```upgrade```) apply to the empty tree.
 *)
datatype state_tree = StateTree ((state_key, state_node) map) int;

(**
 *	Type that represents result for the account fetch request (see ```StateTree.get_account```).
 *	The state tree is also returned as the second argument due
 *	to the fact that some nodes might not be in memory and pulled out from
 *  the database changing tree's internal state.
 *
 *	@param object: ```'a``` generic object that is searched. In our case it is ```account```.
 *	@param tree: ```state_tree``` changed tree.
 *)
datatype 'a state_fetch_result = StateFetchResult 'a state_tree;

(**
 *	Exception is raised when a node is expected to be in the tree but it is missing for unknown reason.
 *	@param state_key: ```state_key``` key the node is queried by.
 *)
exception StateTreeMissingNode state_key;

(**
 *	Structure containing getters for fetch result type.
 *)
structure StateFetchResult = 
struct
	fun get_value (StateFetchResult v s) = v;
	fun get_tree (StateFetchResult v s) = s;
end;

(**
 *	Structure containing private functions for state tree manipulation.
 *)
structure StateTreePrivate = 
struct
	fun account_id_bit_at account_id index =
		RawKey.bit_at (RawKey.from_bytes account_id) index;

	fun get_store (StateTree s _) = s;

	local
		val default_hash = HashFunction.calculate_from_bytes (Serialization.encode_int_flex 20112819)
	in
		fun get_defaul_hash () = default_hash;
	end

	fun get_hash node =
		case node of
			StateNull => get_defaul_hash ()
			| StateInternal hash _ _ => hash
			| StateLeaf hash _ => hash;

	fun get_node store db key =
		let
			val node = Map.lookup store key
		in
			if Option.isSome node then
				(Option.valOf node, store)
			else
				let
					val db_node = StateTreeReader.read db key
				in
					Option.getOpt (Option.map (fn n => (n, (Map.insert store key n))) db_node) (StateNull, store)
				end
		end;

	fun preload_reachable store db key =
		let
			val (node, store) = get_node store db key

			fun preload_children store left right =
				let
					val store = Option.getOpt (Option.map (fn k => preload_reachable store db k) left) store
					val store = Option.getOpt (Option.map (fn k => preload_reachable store db k) right) store
				in
					store
				end;

		in
			case node of
				StateLeaf _ _ => store
				| StateInternal _ left right => preload_children store left right
				| StateNull => raise StateTreeMissingNode key
		end;

	fun break_changes changes index =
		let
			val all_changes = Set.to_list changes

			fun threshold (StateTreeChange _ account) =
				not (account_id_bit_at (Account.get_account_id account) index);

			val (lst0, lst1) = List.partition threshold all_changes
		in
			(Set.from_list StateTreeChange.compare lst0, Set.from_list StateTreeChange.compare lst1)
		end;

	fun update store db changes key path upver =
		if Set.is_empty changes then
			(Some key, store)
		else
			let
				val (node, store) = get_node store db key
			in
				case node of
				StateNull => update_null store db changes key path upver
				| StateLeaf hash account => update_leaf store db changes key (StateLeaf hash account) path upver
				| StateInternal _ _ _ => update_internal store db changes key path upver
			end

	and update_null store db changes key path upver =
		if (Set.length changes) = 1 then
				handle_single_change store db (Set.any changes) key path upver
			else
				handle_multiple_changes store db changes key path upver

	and update_leaf store db changes key (StateLeaf _ account) path upver =
		let
			val new_change = StateTreeChange (Some key) account
		in
			if Set.member changes new_change then
				if Set.length changes = 1 then
					handle_single_change store db (Set.any changes) key path upver
				else
					handle_multiple_changes store db changes key path upver
			else
				handle_multiple_changes store db (Set.add changes new_change) key path upver
		end

	and update_internal store db changes key path upver =
		handle_multiple_changes store db changes key path upver

	and handle_single_change store db (StateTreeChange pref_key account) key path upver =
		if Option.isSome pref_key then
			(pref_key, store)
		else
			let
				val hash = HashFunction.calculate_from_bytes (Account.serialize account)
				val node = StateLeaf hash account
				val new_key = StateKey.create path upver
				val new_store = Map.insert store new_key node
			in
				(Some new_key, new_store)
			end

	and handle_multiple_changes store db changes key path upver = 
		let
			fun update_left_child store changes key =
				let
					val (node, store) = get_node store db key
					val child_key = StateNode.left_child node
				in
					if Set.is_empty changes then
						(child_key, store)
					else
						let
						 	val next_key = Option.getOpt child_key (StateKey.next_key key False)
						 	val next_path = RawKey.next path False
						 in
						 	update store db changes next_key next_path upver
						 end 
				end

			fun update_right_child store changes key =
				let
					val (node, store) = get_node store db key
					val child_key = StateNode.right_child node
				in
					if Set.is_empty changes then
						(child_key, store)
					else
						let
						 	val next_key = Option.getOpt child_key (StateKey.next_key key True)
						 	val next_path = RawKey.next path True
						 in
						 	update store db changes next_key next_path upver
						 end 
				end

			val bit_index = RawKey.length path
			val (changes0, changes1) = break_changes changes bit_index
			val (left, store) = update_left_child store changes0 key
			val (right, store) = update_right_child store changes1 key
			
			val (left_node, store) = Option.getOpt (Option.map (fn k => get_node store db k) left) (StateNull, store)
			val (right_node, store) = Option.getOpt (Option.map (fn k => get_node store db k) right) (StateNull, store)

			val lhash = get_hash left_node
			val rhash = get_hash right_node
			val hash = HashFunction.calculate_from_bytes (ByteArray.concat lhash rhash)
			val new_node = StateInternal hash left right
			val new_key = StateKey.create path upver
			val final_store = Map.insert store new_key new_node
		in
			(Some new_key, final_store)
		end;

end;

(**
 *	Structure that implements public interface allowing changing/creating accounts and
 *	fetching existing accounts.
 *
 *	Merkle tree is build storing hashes of the accounts in the leaf. Each leaf is deterministically
 * 	identified by account's 128 bit guid. However building the full tree requires
 *	2^128 nodes to store that is hardly feasible. So, two step optimization
 *	is applied. On the first step max empty subtrees are replaced with default
 *	hash (see ```default_hash```). Then, all max subtrees with a single leaf are
 * 	replaced with this leaf. Moreover, storing a separate tree for each version
 *	is also not efficient. It turns out that one can store only nodes that are
 *	changed/created for the current version and refering nodes which are not changed from
 *	previous versions of the tree.
 *
 *	Moreover implementation fetches nodes which are not currently in memory from the database
 *	when needed allowing efficient memory usage.
 *)
structure StateTree = 
struct

	(**
	 *	Get state tree's version.
	 *	@param state_tree: ```state_tree``` state tree to query.
	 *	@result ```int``` value.
	 *)
	fun get_version (StateTree _ v) = v;

	(**
	 *	Create tree with empty in-memory store and zero version.
	 *	@return ```state_tree``` empty state tree.
	 *)
	fun empty () = StateTree (Map.empty StateKey.compare) 0;

	(**
	 *	Create tree with empty in-memory store and given version.
	 *	Use this function to create a tree and load nodes from database later
	 *	when requested.
	 *	@param version: ```int``` tree's version.
	 *	@return ```state_tree``` created state tree.
	 *)
	fun init version = StateTree (Map.empty StateKey.compare) version;

	(**
	 *	Create tree with initial list of accounts. The final tree will have zero version.
	 *	Use this function, for example, to create a tree from genesis block.
	 *	@param db: ```storage``` persistent storage to load nodes which are not in-memory.
	 *	@param accounts: ```account list``` list of the accounts to create or update.
	 *	@return ```state_tree``` new state tree.
	 *)
	fun init_accounts db accounts =
		let
			val tree = empty ()
			val changes = Set StateTreeChange.compare (List.map (fn a => StateTreeChange None a) accounts)
			val path = RawKey.empty ()
			val init_key = StateKey path ~1
			val (_, new_store) = StateTreePrivate.update (StateTreePrivate.get_store tree) db changes init_key path 0
		in
			StateTree new_store 0
		end

	(**
	 *	Create a tree with a given version and preload nodes for this version
	 *	from the database.
	 *	@param db: ```storage``` persistent storage to load nodes from.
	 *	@param version: ```version``` tree's version.
	 *	@return ```state_tree``` created state tree.
	 *
	 *	@raises ```StateTreeMissingNode``` if there is no node found in the database associated with
	 *	a key representing a child of the existing node.
	 *)
	fun preload db version =
		let
			val store = StateTreePrivate.preload_reachable (Map.empty StateKey.compare) db (StateKey.root version)
		in
			StateTree store version
		end;

	(**
	 *	Fetch merkle root from the tree.
	 *	@param tree: ```state_tree``` state tree to calculate merkle root for.
	 *	@param db: ```storage``` persistent storage to load nodes which are not in-memory.
	 *	@param version: ```version``` tree version for which the merkle root must be calculated.
	 *	@return ```fetch_result``` contaning ```hash_value``` and changed ```state_tree```.
	 *)
	fun root_hash (StateTree store tree_version) db version = 
		let
			val key = StateKey.root version
			val (node, new_store) = StateTreePrivate.get_node store db key
		in
			StateFetchResult (StateTreePrivate.get_hash node) (StateTree store tree_version)
		end;

	(**
	 *	Fetch account by id from the tree.
	 *	@param tree: ```state_tree``` state tree to query for account.
	 *	@param db: ```storage``` persistent storage to load nodes which are not in-memory.
	 *	@param account_id: ```guid``` account's identifier
	 *	@param version: ```version``` tree version for which account must be fetched.
	 *	@return ```fetch_result``` contaning ```account``` or None and changed ```state_tree```.
	 *)
	fun get_account tree db account_id version =
		let
			val store = StateTreePrivate.get_store tree
			val tree_version = get_version tree

			fun search_account store account_id key =
				let
					fun get_account_or_none account =
						if (ByteArray.equal (Account.get_account_id account) account_id) then 
							Some account
						else 
							None;

					fun next_node store left right =
						if (StateTreePrivate.account_id_bit_at account_id (StateKey.key_length key)) then 
							Option.getOpt (Option.map (fn k => search_account store account_id k) right) (None, store)
						else
							Option.getOpt (Option.map (fn k => search_account store account_id k) left) (None, store);
				in
					let
						val (node, store) = StateTreePrivate.get_node store db key
					in
						case node of
							StateNull => (None, store)
							| StateLeaf _ account => (get_account_or_none account, store)
							| StateInternal _ left right => next_node store left right
					end
				end;
		in
			if tree_version >= version then
				let
					val (account, store) = search_account store account_id (StateKey.root version)
				in
					StateFetchResult account (StateTree store tree_version)
				end
			else
				StateFetchResult None (StateTree store tree_version)
		end;

	(**
	 *	Converts tree to string.
	 *	@param tree: ```state_tree``` state tree to convert.
	 *	@param db: ```storage``` persistent storage to load nodes which are not in-memory.
	 *	@return ```string``` representing tree.
	 *)

	fun to_string tree db =
		let
			fun append_default result prefix =
				let
					val hash_value = StateTreePrivate.get_defaul_hash ()
				in
					result ^ prefix ^ ("default") ^ (" - ") ^ (Hex.bytes_to_hex hash_value) ^ "\n"
				end

			fun append_leaf hash_value account result prefix =
				result ^ prefix ^ (Hex.bytes_to_hex hash_value) ^ "\n" ^ prefix ^ (Hex.bytes_to_hex (Account.get_account_id account)) ^ "\n"

			fun append tree node result prefix =
				case node of
					StateNull => append_default result prefix
					| StateLeaf hash_value account => append_leaf hash_value account result prefix
					| StateInternal hash_value left right => append_node tree hash_value left right result prefix

			and append_node tree hash_value left right result prefix =
				let
					fun handle_key maybe_key result prefix =
						case maybe_key of
							Some state_key => append tree (fst (StateTreePrivate.get_node (StateTreePrivate.get_store tree) db state_key)) result prefix
							| None => append_default result prefix

					val result = handle_key right result (prefix ^ "  ")
					val result = result ^ prefix ^ (Hex.bytes_to_hex hash_value) ^ "\n"
					val result = handle_key left result (prefix ^ "  ")
				in
					result
				end;

			val version = get_version tree
			val root_key = StateKey.root version
			val store = StateTreePrivate.get_store tree
			val (node, _) = StateTreePrivate.get_node store db root_key
		in
			append tree node "" ""
		end

	(**
	 *	Update or create accounts and increment the version of the tree.
	 *	@param tree: ```state_tree``` state tree to be changed.
	 *	@param db: ```storage``` persistent storage to load nodes which are not in-memory.
	 *	@param accounts: ```account list``` list of the accounts to create or update.
	 *	@return ```state_tree``` new state tree.
	 *)
	fun upgrade tree db accounts = 
		let
			val version = get_version tree
			val changes = Set StateTreeChange.compare (List.map (fn a => StateTreeChange None a) accounts)
			val path = RawKey.empty ()
			val init_key = StateKey.create path version
			val (_, new_store) = StateTreePrivate.update (StateTreePrivate.get_store tree) db changes init_key path (version + 1)
		in
			StateTree new_store (version + 1)
		end;

	(**
	 *	Reduces the version of the tree meaning that all node with higher version
	 *	are removed. If new version if too high or less then zero then nothing changes.
	 *	@param tree: ```state_tree``` state tree to be changed.
	 *	@param new_version: ```int``` new version to set.
	 *	@return ```state_tree``` new state tree.
	 *)
	fun reduce tree new_version =
		if new_version < 0 orelse ((get_version tree) <= new_version) then tree
		else
			let
				fun filter key node new_store =
					if (StateKey.get_version key) <= new_version then
						Map.insert new_store key node
					else
						new_store;

				val store = Map.foldrWithKey filter (Map.empty StateKey.compare) (StateTreePrivate.get_store tree)
			in
				StateTree store new_version
			end;
end;

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
			StateTreeMissingNode _ => "StateTreeMissingNode" 
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
			StateTreeMissingNode v => 
				"StateTreeMissingNode" ^ "\n" ^ StateKey.to_string "  " v
		  | _ => raise Exception.Unknown
	)
(**
 *	Structure implements private functions mainly needed to traverse tree's in-memory store and save
 *	needed nodes to database.
 *)
structure StateTreeWriterPrivate = 
struct
	fun write db key node =
		let
			val db_key = StateKey.db_key key
			val db_node = StateNode.serialize node
		in
			if (Storage.get_has_batch db) then
				Storage.batch_put db db_key db_node
			else
				Storage.put db db_key db_node True
		end;

	fun put_node db store key version = 
		let
			fun put_children db left right =
				let
					val ldb = Option.getOpt (Option.map (fn k => put_node db store k version) left) db
				in
					Option.getOpt (Option.map (fn k => put_node ldb store k version) right) ldb
				end;

			fun process_next db node = 
				case node of
					StateInternal _ left right => put_children db left right
					| _ => db;
		in
			if ((StateKey.get_version key) = version) then
				case Map.lookup store key of
					Some node => process_next (write db key node) node
					| None => db
			else
				db
		end;

	fun put_version db store version final_version =
		if version <= final_version then
			let
				val db = put_node db store (StateKey.root version) version
			in
				put_version db store (version + 1) final_version	
			end
		else
			db;
end;

(**
 *	Structure implements public functions to persist tree to the database.
 *)
structure StateTreeWriter = 
struct	
	(**
	 *	Save version's of the tree ([from, to]) to the database.
	 *	Writers either put nodes to existing batch request or writes
	 *	directly to the database.
	 *	@param db: ```storage``` to persist tree to.
	 *	@param tree: ```state_tree``` tree to persist into the database.
	 *	@param from: ```int``` start version of the nodes to store.
	 *	@param to: ```int``` end version of the nodes to store.
	 *	@return ```storage``` update storage.
	 *)
	fun write_tree db tree from to =
		let
			val tree_version = StateTree.get_version tree
			val store = StateTreePrivate.get_store tree
			val start_version = min from tree_version
			val end_version = min to tree_version
		in
			StateTreeWriterPrivate.put_version db store start_version end_version
		end;

end;
datatype Negotiation = NotSet | WaitingCustomer | WaitingSupplier | NegotiationRejected | NegotiationApproved ;
structure Negotiation = 
struct
	fun serialize enum = 
		let
		  val str_size = 1;
		in
			case enum of
			   NotSet => Word8Array.array str_size (Word8.fromInt 0)
			 | WaitingCustomer => Word8Array.array str_size (Word8.fromInt 1)
			 | WaitingSupplier => Word8Array.array str_size (Word8.fromInt 2)
			 | NegotiationRejected => Word8Array.array str_size (Word8.fromInt 3)
			 | NegotiationApproved => Word8Array.array str_size (Word8.fromInt 4)
		end

	fun deserialize bytes = 
		case (Word8.toInt (Word8Array.sub bytes 0)) of
		   0 => (NotSet, 1)
		 | 1 => (WaitingCustomer, 1)
		 | 2 => (WaitingSupplier, 1)
		 | 3 => (NegotiationRejected, 1)
		 | 4 => (NegotiationApproved, 1)

end;

datatype PaymentStatus = WaitingForPayment | PaymentCompleted | PaymentRejected ;
structure PaymentStatus = 
struct
	fun serialize enum = 
		let
		  val str_size = 1;
		in
			case enum of
			   WaitingForPayment => Word8Array.array str_size (Word8.fromInt 0)
			 | PaymentCompleted => Word8Array.array str_size (Word8.fromInt 1)
			 | PaymentRejected => Word8Array.array str_size (Word8.fromInt 2)
		end

	fun deserialize bytes = 
		case (Word8.toInt (Word8Array.sub bytes 0)) of
		   0 => (WaitingForPayment, 1)
		 | 1 => (PaymentCompleted, 1)
		 | 2 => (PaymentRejected, 1)

end;

datatype Phase = PhaseAgreement | PhaseTasks | PhaseDeclined ;
structure Phase = 
struct
	fun serialize enum = 
		let
		  val str_size = 1;
		in
			case enum of
			   PhaseAgreement => Word8Array.array str_size (Word8.fromInt 0)
			 | PhaseTasks => Word8Array.array str_size (Word8.fromInt 1)
			 | PhaseDeclined => Word8Array.array str_size (Word8.fromInt 2)
		end

	fun deserialize bytes = 
		case (Word8.toInt (Word8Array.sub bytes 0)) of
		   0 => (PhaseAgreement, 1)
		 | 1 => (PhaseTasks, 1)
		 | 2 => (PhaseDeclined, 1)

end;

datatype TaskStatus = TaskNotAccepted | TaskAccepted | TaskReadyToPerform | GasRequested | Performing | Confirmed | TaskCompleted ;
structure TaskStatus = 
struct
	fun serialize enum = 
		let
		  val str_size = 1;
		in
			case enum of
			   TaskNotAccepted => Word8Array.array str_size (Word8.fromInt 0)
			 | TaskAccepted => Word8Array.array str_size (Word8.fromInt 1)
			 | TaskReadyToPerform => Word8Array.array str_size (Word8.fromInt 2)
             | GasRequested => Word8Array.array str_size (Word8.fromInt 3)
             | Performing => Word8Array.array str_size (Word8.fromInt 4)
             | Confirmed => Word8Array.array str_size (Word8.fromInt 5)
             | TaskCompleted => Word8Array.array str_size (Word8.fromInt 6)
		end

	fun deserialize bytes = 
		case (Word8.toInt (Word8Array.sub bytes 0)) of
		   0 => (TaskNotAccepted, 1)
		 | 1 => (TaskAccepted, 1)
		 | 2 => (TaskReadyToPerform, 1)
         | 3 => (GasRequested, 1)
         | 4 => (Performing, 1)
         | 5 => (Confirmed, 1)
         | 6 => (TaskCompleted, 1)

end;

datatype PaymentType = Pre | Post | Delayed ;
structure PaymentType = 
struct
	fun serialize enum = 
		let
		  val str_size = 1;
		in
			case enum of
			   Pre => Word8Array.array str_size (Word8.fromInt 0)
			 | Post => Word8Array.array str_size (Word8.fromInt 1)
			 | Delayed => Word8Array.array str_size (Word8.fromInt 2)
		end

	fun deserialize bytes = 
		case (Word8.toInt (Word8Array.sub bytes 0)) of
		   0 => (Pre, 1)
		 | 1 => (Post, 1)
		 | 2 => (Delayed, 1)

end;

datatype Context = Context int int (Word8.word list);
fun get_context_msgSender (Context msgSender _ _) = msgSender;
fun get_context_blockNum (Context _ blockNum _) = blockNum;
fun get_context_storage (Context _ _ storage) = storage;

datatype Person = Person int string;
(*setters for Person*) 
fun set_person_addr (Person a name) value = Person value name;
fun set_person_name (Person addr a) value = Person addr value;
(*getters for Person*)
fun get_person_addr (Person addr _) = addr;
fun get_person_name (Person _ name) = name;
structure Person = 
struct
	fun serialize (Person addr name) = 
        ByteArray.from_list(
            ByteArray.to_list (Serialization.encode_int_flex addr) @
            ByteArray.to_list (Serialization.encode_string name)
        )

	fun deserialize bytes = 
		let
            val (addr, addr_len) = Serialization.decode_int_flex bytes
            val (name, name_len) = Serialization.decode_string (ByteArray.from_list (List.drop (ByteArray.to_list bytes) addr_len))
        in
            ((Person addr name), (addr_len + name_len))
        end

end;

datatype AgreementDetails = AgreementDetails string int;
(*setters for AgreementDetails*)
fun set_agreementDetails_details (AgreementDetails details a ) value = AgreementDetails value a ;
fun set_agreementDetails_bankAddress (AgreementDetails a bankAddress ) value = AgreementDetails a value ;
(*getters for AgreementDetails*) 
fun get_agreementDetails_details (AgreementDetails details _ ) = details;
fun get_agreementDetails_bankAddress (AgreementDetails _ bankAddress ) = bankAddress;
structure AgreementDetails = 
struct
	fun serialize (AgreementDetails details bankAddress) = 
        ByteArray.from_list(
            ByteArray.to_list (Serialization.encode_string details) @
            ByteArray.to_list (Serialization.encode_int_flex bankAddress)
        )

	fun deserialize bytes = 
		let
            val (details, details_len) = Serialization.decode_string bytes
            val (bankAddress, bankAddress_len) = Serialization.decode_int_flex (ByteArray.from_list (List.drop (ByteArray.to_list bytes) details_len))
        in
            ((AgreementDetails details bankAddress), (details_len + bankAddress_len))
        end

end;

datatype Agreement = Agreement Negotiation Person Person AgreementDetails;
(*setters for Agreement*)
fun set_agreement_negotiation (Agreement negotiation a b c) value = Agreement value a b c;
fun set_agreement_customer (Agreement a customer b c) value = Agreement a value b c;
fun set_agreement_supplier (Agreement a b supplier c) value = Agreement a b value c;
fun set_agreement_details (Agreement a b c details) value = Agreement a b c value;
(*getters for Agreement*) 
fun get_agreement_negotiation (Agreement negotiation _ _ _) = negotiation;
fun get_agreement_customer (Agreement _ customer _ _) = customer;
fun get_agreement_supplier (Agreement _ _ supplier _) = supplier;
fun get_agreement_details (Agreement _ _ _ details) = details;
structure Agreement = 
struct
	fun serialize (Agreement negotiation customer supplier details) = 
        ByteArray.from_list(
            ByteArray.to_list (Negotiation.serialize negotiation) @
            ByteArray.to_list (Person.serialize customer) @
            ByteArray.to_list (Person.serialize supplier) @
            ByteArray.to_list (AgreementDetails.serialize details)
        )

	fun deserialize bytes = 
		let
            val (negotiation, negotiation_len) = Negotiation.deserialize bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list bytes) negotiation_len)
            val (customer, customer_len) = Person.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) customer_len)
            val (supplier, supplier_len) = Person.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) supplier_len)
            val (details, details_len) = AgreementDetails.deserialize updated_bytes
        in
            ((Agreement negotiation customer supplier details), (negotiation_len + customer_len + supplier_len + details_len))
        end

end;

datatype PriceChange = PriceChange int Negotiation int;
(*setters for PriceChange*)
fun set_priceChange_price (PriceChange price a b) value = PriceChange value a b;
fun set_priceChange_negotiation (PriceChange a negotiation b) value = PriceChange a value b;
fun set_priceChange_startTime (PriceChange a b startTime) value = PriceChange a b value;
(*getters for PriceChange*)
fun get_priceChange_price (PriceChange price _ _) = price;
fun get_priceChange_negotiation (PriceChange _ negotiation _) = negotiation;
fun get_priceChange_startTime (PriceChange _ _ startTime) = startTime;
structure PriceChange = 
struct
	fun serialize (PriceChange price negotiation startTime) = 
        ByteArray.from_list(
            ByteArray.to_list (Serialization.encode_int_flex price) @
            ByteArray.to_list (Negotiation.serialize negotiation) @
            ByteArray.to_list (Serialization.encode_int_flex startTime)
        )

	fun deserialize bytes = 
		let
            val (price, price_len) = Serialization.decode_int_flex bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list bytes) price_len)
            val (negotiation, negotiation_len) = Negotiation.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) negotiation_len)
            val (startTime, startTime_len) = Serialization.decode_int_flex updated_bytes
        in
            ((PriceChange price negotiation startTime), (price_len + negotiation_len + startTime_len))
        end

end;

datatype PaymentOrder = PaymentOrder int int int int PaymentStatus bool;
(*setters for PaymentOrder*) 
fun set_PaymentOrder_amount (PaymentOrder amount a b c d e) value = PaymentOrder value a b c d e;
fun set_PaymentOrder_paymentTime (PaymentOrder a paymentTime b c d e) value = PaymentOrder a value b c d e;
fun set_PaymentOrder_paymentId (PaymentOrder a b paymentId c d e) value = PaymentOrder a b value c d e;
fun set_PaymentOrder_taskId (PaymentOrder a b c taskId d e) value = PaymentOrder a b c value d e;
fun set_PaymentOrder_paymentStatus (PaymentOrder a b c d paymentStatus e) value = PaymentOrder a b c d value e;
fun set_PaymentOrder_direction (PaymentOrder a b c d e direction) value = PaymentOrder a b c d e value;
(*getters for PaymentOrder*)
fun get_PaymentOrder_amount (PaymentOrder amount _ _ _ _ _) = amount;
fun get_PaymentOrder_paymentTime (PaymentOrder _ paymentTime _ _ _ _) = paymentTime;
fun get_PaymentOrder_paymentId (PaymentOrder _ _ paymentId _ _ _) = paymentId;
fun get_PaymentOrder_taskId (PaymentOrder _ _ _ taskId _ _) = taskId;
fun get_PaymentOrder_paymentStatus (PaymentOrder _ _ _ _ paymentStatus _) = paymentStatus;
fun get_PaymentOrder_direction (PaymentOrder _ _ _ _ _ direction) = direction;
structure PaymentOrder = 
struct
	fun serialize (PaymentOrder amount paymentTime paymentId taskId paymentStatus direction) = 
        ByteArray.from_list(
            ByteArray.to_list (Serialization.encode_int_flex amount) @
            ByteArray.to_list (Serialization.encode_int_flex paymentTime) @
            ByteArray.to_list (Serialization.encode_int_flex paymentId) @
            ByteArray.to_list (Serialization.encode_int_flex taskId) @
            ByteArray.to_list (PaymentStatus.serialize paymentStatus) @
            ByteArray.to_list (Serialization.encode_bool direction)
        )

	fun deserialize bytes = 
		let
            val (amount, amount_len) = Serialization.decode_int_flex bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list bytes) amount_len)
            val (paymentTime, paymentTime_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) paymentTime_len)
            val (paymentId, paymentId_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) paymentId_len)
            val (taskId, taskId_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) taskId_len)
            val (paymentStatus, paymentStatus_len) = PaymentStatus.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) paymentStatus_len)
            val (direction, direction_len) = Serialization.decode_bool updated_bytes
        in
            ( (PaymentOrder amount paymentTime paymentId taskId paymentStatus direction), 
                (amount_len + paymentTime_len + paymentId_len + taskId_len + paymentStatus_len + direction_len)
            )
        end

end;

datatype Task = Task int Negotiation Person Person int int int int int int int int TaskStatus PaymentType;
(*setters for Task*)
fun set_task_id             (Task taskID  a b c d e f g h i k m n l) value =        Task value a b c d e f g h i k m n l;
fun set_task_negotiation    (Task a negotiation b c d e f g h i k m n l) value =    Task a value b c d e f g h i k m n l;
fun set_task_captain        (Task a b captain c d e f g h i k m n l) value =        Task a b value c d e f g h i k m n l;
fun set_task_worker         (Task a b c worker d e f g h i k m n l) value =         Task a b c value d e f g h i k m n l;
fun set_task_expectedGas    (Task a b c d expectedGas e f g h i k m n l) value =    Task a b c d value e f g h i k m n l;
fun set_task_requestedGas   (Task a b c d e requestedGas f g h i k m n l) value =   Task a b c d e value f g h i k m n l;
fun set_task_suppliedGas    (Task a b c d e f suppliedGas g h i k m n l) value =    Task a b c d e f value g h i k m n l;
fun set_task_totalGas       (Task a b c d e f g totalGas h i k m n l) value =       Task a b c d e f g value h i k m n l;
fun set_task_requestTime    (Task a b c d e f g h requestTime i k m n l) value =    Task a b c d e f g h value i k m n l;
fun set_task_suppliedTime   (Task a b c d e f g h i suppliedTime k m n l) value =   Task a b c d e f g h i value k m n l;
fun set_task_completionTime (Task a b c d e f g h i k completionTime m n l) value = Task a b c d e f g h i k value m n l;
fun set_task_paymentTime    (Task a b c d e f g h i k m paymentTime n l) value =    Task a b c d e f g h i k m value n l;
fun set_task_taskStatus     (Task a b c d e f g h i k m n taskStatus l) value =     Task a b c d e f g h i k m n value l;
fun set_task_paymentType    (Task a b c d e f g h i k m n l paymentType) value =    Task a b c d e f g h i k m n l value;
(*getters for Task*)
fun get_task_id (Task taskID _ _ _ _ _ _ _ _ _ _ _ _ _) = taskID;
fun get_task_negotiation (Task _ negotiation _ _ _ _ _ _ _ _ _ _ _ _) = negotiation;
fun get_task_captain (Task _ _ captain _ _ _ _ _ _ _ _ _ _ _) = captain;
fun get_task_worker (Task _ _ _ worker _ _ _ _ _ _ _ _ _ _) = worker;
fun get_task_expectedGas (Task _ _ _ _ expectedGas _ _ _ _ _ _ _ _ _) = expectedGas;
fun get_task_requestedGas (Task _ _ _ _ _ requestedGas _ _ _ _ _ _ _ _) = requestedGas;
fun get_task_suppliedGas (Task _ _ _ _ _ _ suppliedGas _ _ _ _ _ _ _) = suppliedGas;
fun get_task_totalGas (Task _ _ _ _ _ _ _ totalGas _ _ _ _ _ _ ) = totalGas;
fun get_task_requestTime (Task _ _ _ _ _ _ _ _ requestTime _ _ _ _ _ ) = requestTime;
fun get_task_suppliedTime (Task _ _ _ _ _ _ _ _ _ suppliedTime _ _ _ _ ) = suppliedTime;
fun get_task_completionTime (Task _ _ _ _ _ _ _ _ _ _ completionTime _ _ _ ) = completionTime;
fun get_task_paymentTime (Task _ _ _ _ _ _ _ _ _ _ _ paymentTime _ _ ) = paymentTime;
fun get_task_taskStatus (Task _ _ _ _ _ _ _ _ _ _ _ _ taskStatus _ ) = taskStatus;
fun get_task_paymentType (Task _ _ _ _ _ _ _ _ _ _ _ _ _ paymentType ) = paymentType;
structure Task = 
struct
	fun serialize (Task taskID negotiation captain worker expectedGas requestedGas suppliedGas totalGas requestTime suppliedTime completionTime paymentTime taskStatus paymentType) = 
        ByteArray.from_list(
            ByteArray.to_list (Serialization.encode_int32 taskID) @
            ByteArray.to_list (Negotiation.serialize negotiation) @
            ByteArray.to_list (Person.serialize captain) @
            ByteArray.to_list (Person.serialize worker) @
            ByteArray.to_list (Serialization.encode_int_flex expectedGas) @
            ByteArray.to_list (Serialization.encode_int_flex requestedGas) @
            ByteArray.to_list (Serialization.encode_int_flex suppliedGas) @
            ByteArray.to_list (Serialization.encode_int_flex totalGas) @
            ByteArray.to_list (Serialization.encode_int_flex requestTime) @
            ByteArray.to_list (Serialization.encode_int_flex suppliedTime) @
            ByteArray.to_list (Serialization.encode_int_flex completionTime) @
            ByteArray.to_list (Serialization.encode_int_flex paymentTime) @
            ByteArray.to_list (TaskStatus.serialize taskStatus) @
            ByteArray.to_list (PaymentType.serialize paymentType)
        )

	fun deserialize bytes = 
		let
            val (taskID, taskID_len) = Serialization.decode_int32 bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list bytes) taskID_len)
            val (negotiation, negotiation_len) = Negotiation.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) negotiation_len)
            val (captain, captain_len) = Person.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) captain_len)
            val (worker, worker_len) = Person.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) worker_len)
            val (expectedGas, expectedGas_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) expectedGas_len)
            val (requestedGas, requestedGas_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) requestedGas_len)
            val (suppliedGas, suppliedGas_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) suppliedGas_len)
            val (totalGas, totalGas_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) totalGas_len)
            val (requestTime, requestTime_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) requestTime_len)
            val (suppliedTime, suppliedTime_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) suppliedTime_len)
            val (completionTime, completionTime_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) completionTime_len)
            val (paymentTime, paymentTime_len) = Serialization.decode_int_flex updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) paymentTime_len)
            val (taskStatus, taskStatus_len) = TaskStatus.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) taskStatus_len)
            val (paymentType, paymentType_len) = PaymentType.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) paymentType_len)
        in
            ( (Task taskID negotiation captain worker expectedGas requestedGas suppliedGas totalGas requestTime suppliedTime completionTime paymentTime taskStatus paymentType), 
                (taskID_len + negotiation_len + captain_len + worker_len + expectedGas_len + requestedGas_len + suppliedGas_len + totalGas_len + requestTime_len + suppliedTime_len + completionTime_len + paymentTime_len + taskStatus_len + paymentType_len)
            )
        end

end;

datatype Campaign = Campaign Agreement (Task list) Negotiation (PriceChange list) Phase (PaymentOrder list); 
(*setters for Campaign*)
fun set_campaign_agreement (Campaign agreement a b c d e) value = Campaign value a b c d e ;
fun set_campaign_tasks (Campaign a tasks b c d e) value = Campaign a value b c d e;
fun set_campaign_negotiation (Campaign a b negotiation c d e) value = Campaign a b value c d e;
fun set_campaign_priceChanges (Campaign a b c priceChanges d e) value = Campaign a b c value d e;
fun set_campaign_phase (Campaign a b c d phase e) value = Campaign a b c d value e;
fun set_campaign_paymentOrders (Campaign a b c d e paymentOrders) value = Campaign a b c d e value;
(*getters for Campaign*)
fun get_campaign_agreement (Campaign agreement _ _ _ _ _) = agreement;
fun get_campaign_tasks (Campaign _ tasks _ _ _ _) = tasks;
fun get_campaign_negotiation (Campaign _ _ negotiation _ _ _) = negotiation;
fun get_campaign_priceChanges (Campaign _ _ _ priceChanges _ _) = priceChanges;
fun get_campaign_phase (Campaign _ _ _ _ phase _) = phase;
fun get_campaign_paymentOrders (Campaign _ _ _ _ _ paymentOrders) = paymentOrders;
structure Campaign = 
struct
	fun serialize (Campaign agreement tasks negotiation priceChanges phase paymentOrders) = 
        ByteArray.from_list(
            ByteArray.to_list (Agreement.serialize agreement) @
            ByteArray.to_list (Serialization.encode_list Task.serialize tasks) @
            ByteArray.to_list (Negotiation.serialize negotiation) @
            ByteArray.to_list (Serialization.encode_list PriceChange.serialize priceChanges) @
            ByteArray.to_list (Phase.serialize phase) @
            ByteArray.to_list (Serialization.encode_list PaymentOrder.serialize paymentOrders)
        )

	fun deserialize bytes = 
		let
            val (agreement, agreement_len) = Agreement.deserialize bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list bytes) agreement_len)
            val (tasks, tasks_len) = Serialization.decode_list Task.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) tasks_len)
            val (negotiation, negotiation_len) = Negotiation.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) negotiation_len)
            val (priceChanges, priceChanges_len) = Serialization.decode_list PriceChange.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) priceChanges_len)
            val (phase, phase_len) = Phase.deserialize updated_bytes
            val updated_bytes = ByteArray.from_list (List.drop (ByteArray.to_list updated_bytes) phase_len)
            val (paymentOrders, paymentOrders_len) = Serialization.decode_list PaymentOrder.deserialize updated_bytes
        in
            ( (Campaign agreement tasks negotiation priceChanges phase paymentOrders), 
                (agreement_len + tasks_len + negotiation_len + priceChanges_len + phase_len + paymentOrders_len)
            )
        end

end;datatype SCvalue = SCInt int
    | SCString string
    | SCBool bool
    | SCAgreement Agreement
    | SCTask Task
    | SCNegotiation Negotiation
    | SCPriceChange PriceChange
    | SCPaymentOrder PaymentOrder
    | SCCampaign Campaign
    | SCPerson Person
    | SCPaymentStatus PaymentStatus 
    | SCTaskStatus TaskStatus 
    | SCAgreementDetails AgreementDetails 
    | SCPaymentType PaymentType
    | SCPhase Phase ;

structure SCvalue = 
struct 
    fun serialize value = 
        let
		    val str_size = 1;
            fun append v1 v2 = 
                ByteArray.from_list ((ByteArray.to_list v1) @ (ByteArray.to_list v2));
            fun bytes_from_int num = 
                Word8Array.array str_size (Word8.fromInt num);
		in
            case value of 
               SCString str => append (bytes_from_int 0) (Serialization.encode_string str)
             | SCInt integer => append (bytes_from_int 1) (Serialization.encode_int_flex integer)
             | SCBool someBool => append (bytes_from_int 2) (Serialization.encode_bool someBool)
             | SCNegotiation negotiation => append (bytes_from_int 3) (Negotiation.serialize negotiation)
             | SCPaymentStatus paymentStatus => append (bytes_from_int 4) (PaymentStatus.serialize paymentStatus)
             | SCAgreementDetails agreementDetails => append (bytes_from_int 5) (AgreementDetails.serialize agreementDetails)
             | SCPerson person => append (bytes_from_int 6) (Person.serialize person)
             | SCPaymentOrder paymentOrder => append (bytes_from_int 7) (PaymentOrder.serialize paymentOrder)
             | SCPriceChange priceChange => append (bytes_from_int 8) (PriceChange.serialize priceChange) 
             | SCPhase phase => append (bytes_from_int 9) (Phase.serialize phase) 
             | SCTaskStatus taskStatus => append (bytes_from_int 10) (TaskStatus.serialize taskStatus) 
             | SCPaymentType paymentType => append (bytes_from_int 11) (PaymentType.serialize paymentType) 
             | SCAgreement agreement => append (bytes_from_int 12) (Agreement.serialize agreement) 
             | SCTask task => append (bytes_from_int 13) (Task.serialize task) 
             | SCCampaign campaign => append (bytes_from_int 14) (Campaign.serialize campaign)
        end

    fun deserialize bytes = 
        let
            fun update_bytes value =
                ByteArray.from_list (List.drop (ByteArray.to_list value) 1)
        in
            case (Word8.toInt (Word8Array.sub bytes 0)) of
               0 => ((SCString (fst (Serialization.decode_string (update_bytes bytes)))), ((snd (Serialization.decode_string (update_bytes bytes)))+1))
             | 1 => ((SCInt (fst (Serialization.decode_int_flex (update_bytes bytes)))), ((snd (Serialization.decode_int_flex (update_bytes bytes)))+1))
             | 2 => ((SCBool (fst (Serialization.decode_bool (update_bytes bytes)))), ((snd (Serialization.decode_bool (update_bytes bytes)))+1))
             | 3 => ((SCNegotiation (fst (Negotiation.deserialize (update_bytes bytes)))), ((snd (Negotiation.deserialize (update_bytes bytes)))+1))
             | 4 => ((SCPaymentStatus (fst (PaymentStatus.deserialize (update_bytes bytes)))), ((snd (PaymentStatus.deserialize (update_bytes bytes)))+1))
             | 5 => ((SCAgreementDetails (fst (AgreementDetails.deserialize (update_bytes bytes)))), ((snd (AgreementDetails.deserialize (update_bytes bytes)))+1))
             | 6 => ((SCPerson (fst (Person.deserialize (update_bytes bytes)))), ((snd (Person.deserialize (update_bytes bytes)))+1))
             | 7 => ((SCPaymentOrder (fst (PaymentOrder.deserialize (update_bytes bytes)))), ((snd (PaymentOrder.deserialize (update_bytes bytes)))+1))
             | 8 => ((SCPriceChange (fst (PriceChange.deserialize (update_bytes bytes)))), ((snd (PriceChange.deserialize (update_bytes bytes)))+1))
             | 9 => ((SCPhase (fst (Phase.deserialize (update_bytes bytes)))), ((snd (Phase.deserialize (update_bytes bytes)))+1))
             | 10 => ((SCTaskStatus (fst (TaskStatus.deserialize (update_bytes bytes)))), ((snd (TaskStatus.deserialize (update_bytes bytes)))+1))
             | 11 => ((SCPaymentType (fst (PaymentType.deserialize (update_bytes bytes)))), ((snd (PaymentType.deserialize (update_bytes bytes)))+1))
             | 12 => ((SCAgreement (fst (Agreement.deserialize (update_bytes bytes)))), ((snd (Agreement.deserialize (update_bytes bytes)))+1))
             | 13 => ((SCTask (fst (Task.deserialize (update_bytes bytes)))), ((snd (Task.deserialize (update_bytes bytes)))+1))
             | 14 => ((SCCampaign (fst (Campaign.deserialize (update_bytes bytes)))), ((snd (Campaign.deserialize (update_bytes bytes)))+1))
        end

end;


(* SCValue -> int option *)
fun scvalue_to_int x = 
    case x of 
    (SCInt x) => Some x
    | _ => None;
(* SCValue -> string option*)
fun scvalue_to_string x =
    case x of 
    (SCString x) => Some x
    | _ => None;
(* SCValue -> bool option*)
fun scvalue_to_bool x =
    case x of 
    (SCBool x) => Some x
    | _ => None;
(* SCValue -> AgreementDetails option*)
fun scvalue_to_agreementDetails x =
    case x of 
    (SCAgreementDetails x) => Some x
    | _ => None;
(*SCValue -> Negotiation option*)
fun scValue_to_negotiation x = 
    case x of 
    (SCNegotiation x) => Some x
    | _ => None;
(*SCValue -> Person option*)
fun scValue_to_person x = 
    case x of 
    (SCPerson x) => Some x
    | _ => None;
(*SCValue -> TaskStatus option*)
fun scValue_to_taskStatus x =
    case x of 
    (SCTaskStatus x) => Some x
    | _ => None;
(*SCValue -> Campaign option*)
fun scValue_to_campaign x =
    case x of 
    (SCCampaign x) => Some x
    | _ => None;
(*SCValue -> PaymentType option*)
fun scValue_to_paymentType x =
    case x of 
    (SCPaymentType x) => Some x
    | _ => None;
(*SCValue -> Task option*)
fun scValue_to_Task x =
    case x of 
    (SCTask x) => Some x
    | _ => None;
(*SCValue -> Agreement option*)
fun scValue_to_Agreement x =
    case x of 
    (SCAgreement x) => Some x
    | _ => None;
(*SCValue -> PriceChange option*)
fun scValue_to_PriceChange x =
    case x of 
    (SCPriceChange x) => Some x
    | _ => None;exception ErrorMsg string;

datatype 'a optionErr = SOME 'a | RET 'a 'a | NONE string; 

(* OptionErr -> ('a option) *)
fun get x = 
    case x of 
    SOME x => Some x
    | RET _ _ => None
    | NONE msg => (print msg; None);
(* OptionErr -> (string option) *)
fun get_err x =
    case x of 
    NONE x => Some x
    | RET _ _ => None
    | SOME _ => None;
(* OptionErr -> ('a option) *)
fun get_ret_state x = 
    case x of
    RET a _ => Some a 
    | NONE _ => None
    | SOME _ => None;
(* OptionErr -> ('a option) *)
fun get_ret_val x = 
    case x of
    RET _ a => Some a 
    | NONE _ => None
    | SOME _ => None;structure ContractPrivate = 
struct
    fun p_get_campaign_task_by_task_id campaign taskId = 
    let
        fun get_task (x::tail) taskId =
            if (get_task_id x) = taskId then
                Some x
            else if tail = [] then 
                None                
            else
                get_task (tail) taskId;
    in 
        get_task (get_campaign_tasks campaign) taskId
    end;

fun p_get_last_price_change campaign =  
        let
            val priceChanges = get_campaign_priceChanges campaign;
        in
            if priceChanges = [] then 
                None
            else
                Some (List.hd priceChanges)
        end;

(*functions for Agreement*)
fun update_agreement_details agreement details = 
    set_agreement_details agreement details;

fun approve_agreement agreement = 
    set_agreement_negotiation agreement NegotiationApproved;

fun reject_agreement agreement = 
    set_agreement_negotiation agreement NegotiationRejected;

(*functions for Campaign*)
fun p_update_Campaign_tasks campaign task taskID = 
    let
        fun change_task (x::tail) task taskID = 
            if get_task_id x = taskID then 
                task::tail 
            else 
                x::(change_task tail task taskID)
    in
        set_campaign_tasks (campaign) (change_task (get_campaign_tasks campaign) task taskID) 
    end;

fun p_add_task_in_Campaign campaign task = 
    set_campaign_tasks campaign ((get_campaign_tasks campaign) @ [task]);

fun waitCustomer_in_Campaign campaign = 
    set_campaign_negotiation campaign WaitingCustomer;

fun waitSupplier_in_Campaign campaign = 
    set_campaign_negotiation campaign WaitingSupplier;

fun reject_tasks_in_Campaign campaign = 
    set_campaign_negotiation campaign NegotiationRejected;

fun approve_tasks_in_Campaign campaign = 
    set_campaign_negotiation campaign NegotiationApproved;

fun p_remove_task_from_Campaign campaign taskID =
    let 
        fun remove_task_by_id (x::tail) taskID = 
            if get_task_id x = taskID then 
                tail 
            else 
                x::(remove_task_by_id tail taskID)
    in
        set_campaign_tasks campaign (remove_task_by_id (get_campaign_tasks campaign) taskID)
    end;

fun p_get_paymentOrder_by_id campaign paymentId = 
    let 
        fun get_paymentOrder (x::tail) paymentId = 
            if (get_PaymentOrder_paymentId x) = paymentId then
                Some x 
            else if tail = [] then
                None
            else
                get_paymentOrder (tail) paymentId;
    in
        get_paymentOrder (get_campaign_paymentOrders campaign) paymentId
    end;

fun p_update_paymentOrder_by_id campaign paymentOrder paymentId = 
    let
        fun change_paymentOrder (x::tail) paymentOrder paymentId = 
            if (get_PaymentOrder_paymentId x) = paymentId then 
                paymentOrder::tail 
            else 
                x::(change_paymentOrder tail paymentOrder paymentId);
    in
        set_campaign_paymentOrders campaign (change_paymentOrder (get_campaign_paymentOrders campaign) paymentOrder paymentId)
    end;

fun change_price_campaign campaign priceChange = 
    set_campaign_priceChanges campaign ( [priceChange] @ (get_campaign_priceChanges campaign))

fun approve_price_campaign campaign = 
    let 
        fun approve_last_priceChange (x::tail) = 
                [(set_priceChange_negotiation x NegotiationApproved)] @ tail
    in
        set_campaign_priceChanges campaign ( approve_last_priceChange (get_campaign_priceChanges campaign))
    end;

fun reject_price_campaign campaign = 
    let 
        fun reject_last_priceChange (x::tail) = 
                [(set_priceChange_negotiation x NegotiationRejected)] @ tail
    in
        set_campaign_priceChanges campaign ( reject_last_priceChange (get_campaign_priceChanges campaign))
    end;

fun p_perform campaign taskId neededGas = 
    let
        fun change_task (x::tail) taskId = 
            if get_task_id x = taskId then 
                (set_task_requestTime (set_task_requestedGas x neededGas) 0)::tail 
            else 
                x::(change_task tail taskId)
    in
        set_campaign_tasks campaign (change_task (get_campaign_tasks campaign) taskId) 
    end;

fun p_completed campaign taskId suppliedGas = 
    let
        fun change_task (x::tail) taskId = 
            if get_task_id x = taskId then 
                (set_task_suppliedTime (set_task_suppliedGas x suppliedGas) 0)::tail 
            else 
                x::(change_task tail taskId)
    in
        set_campaign_tasks campaign (change_task (get_campaign_tasks campaign) taskId) 
    end;

fun p_confirm campaign taskId = 
    let
        fun change_task (x::tail) taskId = 
            if get_task_id x = taskId then 
                (set_task_completionTime x 0)::tail 
            else 
                x::(change_task tail taskId)
    in
        set_campaign_tasks campaign (change_task (get_campaign_tasks campaign) taskId) 
    end;

fun calculateLastPrice campaign = 
    let 
        fun get_last_approved arr = 
            if (get_priceChange_negotiation (List.last arr)) = NegotiationApproved then 
                Some (get_priceChange_price (List.last arr))
            else if List.length arr = 1 then
                None
            else
                get_last_approved (List.take arr ((List.length arr) - 1))
    in 
        get_last_approved (get_campaign_priceChanges campaign)
    end;


(* (Task list) -> int -> Task *)
fun p_get_task_by_id taskList taskId = 
    case taskList of
       [] => NONE ("Task not found")
     | (x::tail) => 
        if get_task_id x = taskId then 
           SOME x 
        else 
            p_get_task_by_id tail taskId;

fun get_element_with_number (x::tail) number = if number = 0 then x else get_element_with_number tail (number-1);
    
(* Campaign -> int -> Campaign *)
fun p_approve_task campaign taskId = 
        let
        fun change_task (x::tail) taskId = 
            if get_task_id x = taskId then 
                (set_task_negotiation x NegotiationApproved)::tail 
            else 
                x::(change_task tail taskId)
    in
        set_campaign_tasks campaign (change_task (get_campaign_tasks campaign) taskId) 
    end;

(* Campaign -> int -> Campaign *)
fun p_reject_task campaign taskId = 
        let
        fun change_task (x::tail) taskId = 
            if get_task_id x = taskId then 
                (set_task_negotiation x NegotiationRejected)::tail 
            else 
                x::(change_task tail taskId)
    in
        set_campaign_tasks campaign (change_task (get_campaign_tasks campaign) taskId) 
    end;

(* Campaign -> int -> Campaign *)
fun p_accept_task campaign taskId = 
    let
        fun change_task (x::tail) taskId = 
            if get_task_id x = taskId then 
                (set_task_taskStatus x TaskAccepted)::tail 
            else 
                x::(change_task tail taskId)
    in
        set_campaign_tasks campaign (change_task (get_campaign_tasks campaign) taskId) 
    end;
end;

structure Contract = 
struct

(* Context -> (SCValue list) -> (SCValue OptionErr)*)
fun constructor context params = 
    let
        (* (SCValue list) -> (SCValue OptionErr) *)
        fun validate_params params = 
            let
                val customer_addr = scvalue_to_int ((List.nth params 0));
                val customer_name = scvalue_to_string ((List.nth params 1));
                val supplier_addr = scvalue_to_int ((List.nth params 2));
                val supplier_name = scvalue_to_string ((List.nth params 3));
                val agreement_details = scvalue_to_string ((List.nth params 4));
                val bank_addr = scvalue_to_int ((List.nth params 5));
            in 
                if (((List.length params) = 6) andalso
                ((Option.isSome customer_addr) andalso ((Option.isSome customer_name) andalso
                ((Option.isSome supplier_name) andalso ((Option.isSome supplier_addr) andalso 
                ((Option.isSome agreement_details) andalso (Option.isSome bank_addr))))))) then
                    SOME (SCBool True)
                else
                    NONE "Parse params error."                                                    
            end;

        (* (SCValue list) -> (SCValue OptionErr) *)
        fun create params campaign =
            let
                val customer_addr       = (Option.valOf (scvalue_to_int    ((List.nth params 0))));
                val customer_name       = (Option.valOf (scvalue_to_string ((List.nth params 1))));
                val supplier_addr       = (Option.valOf (scvalue_to_int    ((List.nth params 2))));
                val supplier_name       = (Option.valOf (scvalue_to_string ((List.nth params 3))));
                val agreement_details   = (Option.valOf (scvalue_to_string ((List.nth params 4))));
                val bank_addr           = (Option.valOf (scvalue_to_int    ((List.nth params 5))));
            in 
                if (get_context_msgSender context) = customer_addr then
                    SOME (SCCampaign (Campaign (Agreement WaitingSupplier (Person customer_addr customer_name) (Person supplier_addr supplier_name) (AgreementDetails agreement_details bank_addr)) [] WaitingCustomer [] PhaseAgreement []))
                else
                    NONE ( "Only customer allowed to create agreement")
            end;
        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            create params context
        else
            validated
    end; 

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun getAgreement context params campaign = RET (SCCampaign campaign) (SCAgreement (get_campaign_agreement campaign));

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun rejectAgreement context params campaign = 
    let
        val sender = (get_context_msgSender context);
        val agreement = (get_campaign_agreement campaign);
    in 
        if sender = (get_person_addr( get_agreement_supplier agreement))then
            if (get_campaign_phase campaign) = PhaseAgreement then
                if (get_agreement_negotiation agreement) = WaitingSupplier then
                    SOME (SCCampaign (set_campaign_agreement campaign (set_agreement_negotiation agreement WaitingCustomer)))
                else
                    NONE ( "Supplier is not allowed to reject at this point")
            else 
                NONE ( "Supplier is not allowed to reject at this point")
        else
            NONE ( "Only supplier allowed to reject agreement")
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun approveAgreement context params campaign = 
    let
        val sender = (get_context_msgSender context);
        val agreement = (get_campaign_agreement campaign);
    in 
        if sender = (get_person_addr((get_agreement_supplier agreement)))then
            if (get_campaign_phase campaign) = PhaseAgreement then
                if (get_agreement_negotiation agreement) = WaitingSupplier then 
                    SOME (SCCampaign (set_campaign_agreement (set_campaign_phase campaign PhaseTasks) (set_agreement_negotiation agreement NegotiationApproved)))
                else
                    NONE ( "Supplier is not allowed to approve at this point")
            else 
                NONE ( "Supplier is not allowed to approve at this point")
        else
            NONE ( "Only supplier allowed to approve agreement")
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun changeAgreementDetails context params campaign = 
    let
        val sender = (get_context_msgSender context);
        val agreement = (get_campaign_agreement campaign);
        val details = (Option.valOf (scvalue_to_string (List.nth params 0))); 
        val bankAddr = (Option.valOf (scvalue_to_int (List.nth params 1))); 
        val customer = get_person_addr (get_agreement_customer agreement); 
        val supplier = get_person_addr (get_agreement_supplier agreement); 
    in 
        if (sender = customer) then
            if (get_campaign_phase campaign) = PhaseAgreement then
                if (get_agreement_negotiation agreement) = WaitingCustomer andalso (sender = customer) then
                    SOME (SCCampaign (set_campaign_agreement campaign (set_agreement_details (set_agreement_negotiation agreement WaitingSupplier) (AgreementDetails details bankAddr))))
                else 
                    NONE ( "Customer is not allowed to change details at this point")
            else 
                NONE ( "Customer is not allowed to change details at this point")
        else
            if (sender = supplier) then
                if (get_campaign_phase campaign) = PhaseAgreement then
                    if (get_agreement_negotiation agreement) = WaitingSupplier andalso (sender = supplier) then
                        SOME (SCCampaign (set_campaign_agreement campaign (set_agreement_details (set_agreement_negotiation agreement WaitingCustomer) (AgreementDetails details bankAddr))))
                    else
                        NONE ( "Supplier is not allowed to change details at this point")
                else
                    NONE ( "Supplier is not allowed to change details at this point")
            else
                NONE ( "Only customer or supplier allowed to change details")
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun getPriceChangeWithNumber context params campaign = 
    let
    fun validate_params params = 
        let
          val index = (scvalue_to_int (List.nth params 0));
        in
          if (List.length params) = 1 then
            if (Option.isSome index) then
                 SOME (SCBool True)
            else
                NONE "Parse param error: index incorrect type."
          else
            NONE "Wrong number of params"
        end
        
        fun getPriceChange context params campaign = 
            let
        val sender = (get_context_msgSender context);
        val index = Option.valOf(scvalue_to_int (List.nth params 0));
    in 
        if (List.length (get_campaign_priceChanges campaign)) > 0 then
            RET (SCCampaign campaign) (SCPriceChange (ContractPrivate.get_element_with_number (get_campaign_priceChanges campaign) index)) 
        else 
            NONE ( "No price changes")
    end

        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            getPriceChange context params campaign
        else
            validated
    end; 

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun getPriceChangesLength context params campaign = 
    if (List.length (get_campaign_priceChanges campaign)) > 0 then 
        RET (SCCampaign campaign) (SCInt ((List.length (get_campaign_priceChanges campaign)-1)))
    else 
        NONE ( "No price changes");

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun rejectPrice context params campaign = 
    let
        val sender = (get_context_msgSender context);
        val priceChange = (ContractPrivate.p_get_last_price_change campaign); 
    in 
        if sender = get_person_addr (get_agreement_customer (get_campaign_agreement campaign)) then
            if (get_campaign_phase campaign) = PhaseTasks then
                if (Option.isSome priceChange) then 
                    if (get_priceChange_negotiation (Option.valOf priceChange)) = WaitingCustomer then 
                        SOME (SCCampaign (ContractPrivate.reject_price_campaign campaign))
                    else 
                        NONE ( "Customer is not allowed to reject at this point")
                else 
                    NONE ( "No price changes")
            else
                NONE ( "Phase is not PhaseTasks")
        else
            NONE ( "Only customer allowed to reject PriceChange")
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun approvePrice context params campaign = 
    let
        val sender = (get_context_msgSender context);
        val priceChange = (ContractPrivate.p_get_last_price_change campaign); 
    in 
        if sender = get_person_addr (get_agreement_customer (get_campaign_agreement campaign)) then
            if (get_campaign_phase campaign) = PhaseTasks then
                if (Option.isSome priceChange) then 
                    if (get_priceChange_negotiation (Option.valOf priceChange)) = WaitingCustomer then 
                        SOME (SCCampaign (set_campaign_phase (ContractPrivate.approve_price_campaign campaign) PhaseTasks))
                    else 
                        NONE ( "Customer is not allowed to approve at this point")
                else 
                    NONE ( "No price changes")
            else
                NONE ( "Phase is not PhaseTasks")
        else
            NONE ( "Only customer allowed to approve PriceChange")
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun declinePrice context params campaign = 
    let
        val sender = (get_context_msgSender context);
        val priceChange = (ContractPrivate.p_get_last_price_change campaign); 
    in 
        if sender = get_person_addr (get_agreement_customer (get_campaign_agreement campaign)) then
            if (get_campaign_phase campaign) = PhaseTasks then
                if (Option.isSome priceChange) then 
                    if (get_priceChange_negotiation (Option.valOf priceChange)) = WaitingCustomer then 
                        SOME (SCCampaign (set_campaign_phase campaign PhaseDeclined))
                    else 
                        NONE ( "Customer is not allowed to decline at this point")
                else 
                    NONE ( "No price changes")
            else
                NONE ( "Phase is not PhaseTasks")
        else
            NONE ( "Only customer allowed to decline PriceChange")
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun createPriceChange context params campaign = 
    let
    fun validate_params params = 
        let
            val price =       (scvalue_to_int( List.nth params 0));
            val startTime =   (scvalue_to_int( List.nth params 1));
        in
            if (Option.isSome price) then
                if (Option.valOf price) > 0 then
                        if (Option.isSome startTime) then
                            if (Option.valOf startTime) > 0 then
                                SOME (SCBool True)
                            else
                                NONE "Start Time must be more than 0."
                        else
                            NONE "Parse param error: startTime incorrect type."
                else
                    NONE "Price must be more than 0."
            else
                NONE "Parse param error: price incorrect type."
        end
        
    (* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
    fun create context params campaign = 
    let
        val sender = (get_context_msgSender context);

        val price = Option.valOf (scvalue_to_int( List.nth params 0));
        val startTime = Option.valOf(scvalue_to_int( List.nth params 1));
        val priceChange = (ContractPrivate.p_get_last_price_change campaign);
    in 
        if sender = get_person_addr (get_agreement_supplier (get_campaign_agreement campaign)) then
            if (get_campaign_phase campaign) = PhaseTasks then
                if (Option.isSome priceChange) then 
                    if (get_priceChange_negotiation (Option.valOf priceChange)) = NegotiationApproved orelse (get_priceChange_negotiation (Option.valOf priceChange)) = NegotiationRejected then 
                        SOME (SCCampaign (ContractPrivate.change_price_campaign campaign (PriceChange price WaitingCustomer startTime )))
                    else 
                        NONE ("The last change of price should be approved or rejected before adding another priceChange")
                else 
                    SOME (SCCampaign (set_campaign_priceChanges campaign [(PriceChange price WaitingCustomer startTime )] ))
            else
                NONE ("Phase is not PhaseTasks")
        else
            NONE ("Only supplier allowed to create PriceChange")
    end
            
        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            create context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun getTask context params campaign = 
    let
    fun validate_params params = 
        let
            val taskId = (scvalue_to_int (List.nth params 0));
        in 
            if (Option.isSome taskId) then 
                if Option.isSome (ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId)) then
                    SOME (SCBool True)
                else
                    NONE "Task does not exist."
            else
                NONE "Parse param error: taskId. Incorrect type."
        end;
        
    (* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
    fun action context params campaign = 
        let
        val sender = (get_context_msgSender context);
        val taskId = Option.valOf (scvalue_to_int (List.hd params));
        val task = (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));
        val agreement = (get_campaign_agreement campaign);
    in 
        RET (SCCampaign campaign) (SCTask task)
    end

        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun approveTask context params campaign = 
    let
    fun validate_params params = 
        let
          val taskId =  (scvalue_to_int (List.hd params));
        in
          if (List.length params) = 1 then
            if (Option.isSome taskId) then
                if (Option.valOf taskId) > 0 then
                    SOME (SCBool True)
                 else
                    NONE "Price must be more than 0."
            else
                NONE "Parse param error: taskId incorrect type."
          else
            NONE "Wrong number of params"
        end
        
    (* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
    fun approve context params campaign = 
        let
        val sender = (get_context_msgSender context);
        val taskId = Option.valOf (scvalue_to_int (List.hd params));
    in 
        if Option.isNone (get_err (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId)) then
            if sender = get_person_addr (get_agreement_supplier (get_campaign_agreement campaign)) then
                if (get_campaign_phase campaign) = PhaseTasks then
                    if get_task_negotiation (Option.valOf (get (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId))) <> NegotiationRejected then
                        SOME (SCCampaign (ContractPrivate.p_approve_task campaign taskId))
                    else
                        NONE ( "Task was rejected")
                else
                    NONE ( "Phase is not PhaseTasks")
            else
                NONE ( "Only supplier allowed to approve")
        else
            NONE ( "Task does not exists.")
    end

        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            approve context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun rejectTask context params campaign = 
    let
    fun validate_params params = 
        let
          val taskId = scvalue_to_int (List.hd params);
        in
          if (List.length params) = 1 then
            if (Option.isSome taskId) then
                if (Option.valOf taskId) > 0 then
                    SOME (SCBool True)
                 else
                    NONE "Price must be more than 0."
            else
                NONE "Parse param error: taskId incorrect type."
          else
            NONE "Wrong number of params"
        end
        
    (* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
    fun reject context params campaign = 
    let
        val sender = get_context_msgSender context;
        val taskId = Option.valOf (scvalue_to_int (List.hd params));
    in 
        if Option.isNone (get_err (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId)) then
            if sender = get_person_addr (get_agreement_supplier (get_campaign_agreement campaign)) then
                if (get_campaign_phase campaign) = PhaseTasks then
                    if get_task_negotiation (Option.valOf (get (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId))) <> NegotiationApproved then
                            SOME (SCCampaign (ContractPrivate.p_reject_task campaign taskId))
                    else
                        NONE ( "Task was approved")
                else
                    NONE ( "Phase is not PhaseTasks")
            else
                NONE ( "Only supplier allowed to reject Task")
        else
            NONE ( "Task does not exists.")
    end

        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            reject context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun acceptTask context params campaign = 
    let
        fun validate_params params = 
            let
            val taskId = (scvalue_to_int (List.hd params));
            in
            if (List.length params) = 1 then
                if (Option.isSome taskId) then
                    if (Option.valOf taskId) > 0 then
                        SOME (SCBool True)
                    else
                        NONE "Price must be more than 0."
                else
                    NONE "Parse param error: taskId incorrect type."
            else
                NONE "Wrong number of params"
            end;
        
    (* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
    fun accept context params campaign = 
        let
        val sender = (get_context_msgSender context);
        val taskId = Option.valOf(scvalue_to_int (List.hd params));
        in 
            if Option.isNone (get_err (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId)) then
                if sender = get_person_addr (get_task_worker (Option.valOf (get (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId)))) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if get_task_negotiation (Option.valOf (get (ContractPrivate.p_get_task_by_id (get_campaign_tasks campaign) taskId))) = NegotiationApproved then
                            SOME (SCCampaign (ContractPrivate.p_accept_task campaign taskId))
                        else
                            NONE ( "Task is not approved yet.")
                    else
                        NONE ( "Phase is not PhaseTasks")
                else
                    NONE ( "Only worker allowed to accept Task")
            else
                NONE ( "Task does not exists.")
        end;

        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            accept context params campaign
        else
            validated
    end;


(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun addTask context params campaign = 
     let
        fun validate_params params = 
        let
          val taskId =         (scvalue_to_int (List.nth params 0));
          val negotiation =    (scValue_to_negotiation (List.nth params 1));
          val captain_addr =   (scvalue_to_int (List.nth params 2));
          val captain_name =   (scvalue_to_string (List.nth params 3));
          val worker_addr =    (scvalue_to_int (List.nth params 4));
          val worker_name =    (scvalue_to_string (List.nth params 5));
          val expectedGas =    (scvalue_to_int (List.nth params 6));
          val requestedGas =   (scvalue_to_int (List.nth params 7));
          val suppliedGas =    (scvalue_to_int (List.nth params 8));
          val totalGas =       (scvalue_to_int (List.nth params 9));
          val requestTime =    (scvalue_to_int (List.nth params 10));
          val suppliedTime =   (scvalue_to_int (List.nth params 11));
          val completionTime = (scvalue_to_int (List.nth params 12));
          val paymentTime =    (scvalue_to_int (List.nth params 13));
          val taskStatus =     (scValue_to_taskStatus (List.nth params 14));
          val paymentType =    (scValue_to_paymentType (List.nth params 15));
        in
            if (((List.length params) = 16) andalso
            ((Option.isSome taskId) andalso ((Option.isSome negotiation) andalso
            ((Option.isSome captain_name) andalso ((Option.isSome captain_addr) andalso
            ((Option.isSome worker_name) andalso ((Option.isSome worker_addr) andalso
            ((Option.isSome expectedGas) andalso ((Option.isSome requestedGas) andalso
            ((Option.isSome suppliedGas) andalso ((Option.isSome totalGas) andalso
            ((Option.isSome requestTime) andalso ((Option.isSome suppliedTime) andalso
            ((Option.isSome completionTime) andalso ((Option.isSome paymentTime) andalso
            ((Option.isSome taskStatus) andalso (Option.isSome paymentType))))))))))))))))) then
                SOME (SCBool True)
            else
                NONE "Parse param error"
        end;
        
    (* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
    fun add context params campaign = 
        let
            val sender = (get_context_msgSender context);

          val taskId =         Option.valOf (scvalue_to_int (List.nth params 0));
          val negotiation =    Option.valOf (scValue_to_negotiation (List.nth params 1));
          val captain_addr =   Option.valOf (scvalue_to_int (List.nth params 2));
          val captain_name =   Option.valOf (scvalue_to_string (List.nth params 3));
          val worker_addr =    Option.valOf (scvalue_to_int (List.nth params 4));
          val worker_name =    Option.valOf (scvalue_to_string (List.nth params 5));
          val expectedGas =    Option.valOf (scvalue_to_int (List.nth params 6));
          val requestedGas =   Option.valOf (scvalue_to_int (List.nth params 7));
          val suppliedGas =    Option.valOf (scvalue_to_int (List.nth params 8));
          val totalGas =       Option.valOf (scvalue_to_int (List.nth params 9));
          val requestTime =    Option.valOf (scvalue_to_int (List.nth params 10));
          val suppliedTime =   Option.valOf (scvalue_to_int (List.nth params 11));
          val completionTime = Option.valOf (scvalue_to_int (List.nth params 12));
          val paymentTime =    Option.valOf (scvalue_to_int (List.nth params 13));
          val taskStatus =     Option.valOf (scValue_to_taskStatus (List.nth params 14));
          val paymentType =     Option.valOf (scValue_to_paymentType (List.nth params 15));
        in 
        if sender = get_person_addr( get_agreement_customer (get_campaign_agreement campaign) )then
            if (get_campaign_phase campaign) = PhaseTasks then
                    SOME (SCCampaign (ContractPrivate.p_add_task_in_Campaign campaign (Task taskId negotiation (Person captain_addr captain_name) (Person worker_addr worker_name) expectedGas requestedGas suppliedGas totalGas requestTime suppliedTime completionTime paymentTime taskStatus paymentType) ))
            else
                NONE ( "Phase is not PhaseTasks")
        else
            NONE ( "Only customer allowed to add Task")
    end;

        val validated = (validate_params params);
    in
        if Option.isNone (get_err validated) then 
            add context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun readyToPerformTask context params campaign = 
    let 
        val sender = (get_context_msgSender context);

        fun validate_params params campaign = 
            let
                val taskId = (scvalue_to_int (List.nth params 0));
            in 
                if Option.isSome taskId then 
                    if Option.isSome(ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId)) then
                        SOME (SCBool True)
                    else
                        NONE ("Task does not exist.")
                else
                    NONE ("Parse param error: TaskID. Incorrect type.")
            end;

        fun action context params campaign =
            let 
                val taskId = (Option.valOf(scvalue_to_int (List.nth params 0)));
                val task = (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));
            in 
                if sender = (get_person_addr (get_task_worker task)) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if (get_task_taskStatus task) = TaskAccepted then
                            SOME (SCCampaign (ContractPrivate.p_update_Campaign_tasks campaign (set_task_taskStatus task TaskReadyToPerform) taskId))
                        else 
                            NONE ( "Task is not accepted yet.")
                    else
                        NONE ( "Action is not allowed at this point")
                else 
                    NONE ( "Only worker allowed to do this action.")
            end;

        val validated = (validate_params params campaign);
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun requestGas context params campaign = 
    let 
        val sender = (get_context_msgSender context);
        val requestTime = (get_context_blockNum context);

        fun validate_params params campaign = 
            let
                val taskId = (scvalue_to_int (List.nth params 0));
                val amount = (scvalue_to_int (List.nth params 1));

                val priceChange = (ContractPrivate.p_get_last_price_change campaign);
            in 
                if Option.isSome taskId then 
                    if Option.isSome (ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId )) then 
                        if Option.isSome amount then
                            if (Option.valOf amount) > 0 then
                                if ( (get_task_paymentType (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId )))) = Pre ) andalso (Option.isNone (ContractPrivate.calculateLastPrice campaign)) then
                                    NONE "No approved prices."
                                else
                                    SOME (SCBool True)
                            else
                                NONE "Amount must be more than 0."
                        else
                            NONE "Parse param error: Amount. Incorrect type."
                    else
                        NONE "Task does not exist."
                else
                    NONE "Parse param error: TaskId. Incorrect type."
            end;

        fun action context params campaign = 
            let
                val taskId = (Option.valOf (scvalue_to_int (List.nth params 0)));
                val amount = (Option.valOf (scvalue_to_int (List.nth params 1)));
                val paymentId = (Option.valOf (scvalue_to_int (List.nth params 2)));

                val task = (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));
                val price = Option.valOf (ContractPrivate.calculateLastPrice campaign);

                (* Task -> Task *)
                fun update_info task = (set_task_requestTime (set_task_requestedGas (set_task_totalGas (set_task_taskStatus task GasRequested) ((get_task_totalGas task) + amount)) amount) requestTime)
                (* Campaign -> Campaign *)
                fun add_payment_order campaign = 
                    if (get_task_paymentType task = Pre) then 
                        set_campaign_paymentOrders campaign (( get_campaign_paymentOrders campaign) @ [(PaymentOrder (amount*price) 0 paymentId taskId WaitingForPayment True)])
                    else
                        campaign;
                                    
            in
                if sender = (get_person_addr (get_task_captain task)) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if (get_task_taskStatus task = TaskReadyToPerform) then
                            SOME (SCCampaign 
                                (ContractPrivate.p_update_Campaign_tasks (add_payment_order campaign) (update_info task) taskId)
                            )
                        else 
                            NONE ("Task is not ready to be performed.")
                    else
                        NONE ("Action is not allowed at this point.")
                else 
                    NONE ("Only captain allowed to do this action.")
            end;
        val validated = (validate_params params campaign);
        
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun paymentCompleted context params campaign = 
    let 
        val sender = (get_context_msgSender context);
        val paymentTime = (get_context_blockNum context);

        fun validate_params params campaign = 
            let
                val paymentId = (scvalue_to_int (List.nth params 0));
            in 
                if (Option.isSome paymentId) then 
                    if (Option.isSome (ContractPrivate.p_get_paymentOrder_by_id campaign ( Option.valOf paymentId))) then
                        if Option.isSome (ContractPrivate.p_get_campaign_task_by_task_id campaign (get_PaymentOrder_taskId (Option.valOf (ContractPrivate.p_get_paymentOrder_by_id campaign ( Option.valOf paymentId))))) then
                            SOME (SCBool True)
                        else
                            NONE "Task does not exist."
                    else 
                        NONE "Payment order does not exist."
                else
                    NONE "Parse param error: PaymentId. Incorrect type."
            end;

        fun action context params campaign = 
            let
                val paymentId = (Option.valOf(scvalue_to_int (List.nth params 0)));
                val paymentOrder = (Option.valOf(ContractPrivate.p_get_paymentOrder_by_id campaign paymentId));
                val taskId = (get_PaymentOrder_taskId paymentOrder);
                val task = (Option.valOf (ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));
            in
                if sender = (get_agreementDetails_bankAddress (get_agreement_details (get_campaign_agreement campaign))) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if ((get_task_taskStatus task) = Confirmed) then
                            SOME (SCCampaign 
                                (ContractPrivate.p_update_Campaign_tasks (ContractPrivate.p_update_paymentOrder_by_id campaign (set_PaymentOrder_paymentStatus paymentOrder PaymentCompleted) paymentId) (set_task_taskStatus task TaskCompleted) taskId)
                            )
                        else
                            SOME (SCCampaign 
                                (ContractPrivate.p_update_paymentOrder_by_id campaign (set_PaymentOrder_paymentStatus paymentOrder PaymentCompleted) paymentId) 
                            )
                    else
                        NONE ( "Action is not allowed at this point.")
                else 
                    NONE ( "Only bank allowed to do this action.")
            end;
        val validated = (validate_params params campaign);
        
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun performTask context params campaign = 
    let 
        val sender = (get_context_msgSender context);
        val requestTime = (get_context_blockNum context);

        fun validate_params params campaign = 
            let
                val taskId = (scvalue_to_int (List.nth params 0));
            in 
                if (Option.isSome taskId) then 
                    if Option.isSome (ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId)) then
                        SOME (SCBool True)
                    else
                        NONE "Task does not exist."
                else
                    NONE "Parse param error: taskId. Incorrect type."
            end;

        fun action context params campaign = 
            let
                val taskId = (Option.valOf (scvalue_to_int (List.nth params 0)));
                val task = (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));
            in
                if sender = (get_person_addr (get_task_worker task)) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if (get_task_taskStatus task) = GasRequested then
                            SOME (SCCampaign (ContractPrivate.p_update_Campaign_tasks campaign (set_task_taskStatus task Performing) taskId))
                        else 
                            NONE ( "No gas requests.")
                    else
                        NONE ( "Action is not allowed at this point")
                else 
                    NONE ( "Only worker allowed to do this action.")
            end;
        
        val validated = (validate_params params campaign);
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun taskCompleted context params campaign = 
    let 
        val sender = (get_context_msgSender context);
        val suppliedTime = (get_context_blockNum context);

        fun validate_params params campaign = 
            let
                val taskId = (scvalue_to_int (List.nth params 0));
                val suppliedGas = (scvalue_to_int (List.nth params 1));

            in 
                if (Option.isSome taskId) then 
                    if Option.isSome (ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId)) then
                        SOME (SCBool True)
                    else
                        NONE "Task does not exist."
                else
                    NONE "Parse param error: taskId. Incorrect type."
            end;

        fun action context params campaign = 
            let
                val taskId = (Option.valOf (scvalue_to_int (List.nth params 0)));
                val suppliedGas = (Option.valOf (scvalue_to_int (List.nth params 1)));

                val task = (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));
            in
                if sender = (get_person_addr (get_task_worker task)) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if (get_task_taskStatus task) = Performing then
                            SOME (SCCampaign (ContractPrivate.p_update_Campaign_tasks campaign 
                                                (set_task_taskStatus 
                                                    (set_task_suppliedGas 
                                                        (set_task_suppliedTime task suppliedTime) 
                                                        suppliedGas) 
                                                    TaskCompleted) 
                                                taskId))
                        else 
                            NONE (  "No one is perfroming the task.")
                    else
                        NONE ( "Action is not allowed at this point")
                else 
                    NONE ( "Only worker allowed to do this action.")
            end;
        val validated = (validate_params params campaign);
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

(* Context -> (SCValue list) -> Campaign -> (SCValue OptionErr)  *)
fun confirmTask context params campaign = 
    let 
        val sender = (get_context_msgSender context);
        val suppliedTime = (get_context_blockNum context);

        fun validate_params params campaign = 
            let
                val taskId = (scvalue_to_int (List.nth params 0));
            in 
                if (Option.isSome taskId) then 
                    if Option.isSome (ContractPrivate.p_get_campaign_task_by_task_id campaign (Option.valOf taskId)) then
                        if (Option.isSome (ContractPrivate.calculateLastPrice campaign)) then 
                            SOME (SCBool True)
                        else
                            NONE "No approved prices."
                    else
                        NONE "Task does not exist."
                else
                    NONE "Parse param error: taskId. Incorrect type."
            end;
        
        fun action context params campaign = 
            let
                val taskId = (Option.valOf (scvalue_to_int (List.nth params 0)));
                val task = (Option.valOf(ContractPrivate.p_get_campaign_task_by_task_id campaign taskId));

                val suppliedGas = (get_task_suppliedGas task);
                val totalGas = (get_task_totalGas task);

                val direction = 
                    if (get_task_suppliedGas task) < (get_task_totalGas task) then
                        if (get_task_paymentType task) = Pre then
                            False
                        else
                            True
                    else
                        True;

                fun make_payment_order task =
                    let 

                        val price = Option.valOf (ContractPrivate.calculateLastPrice campaign);
                    in
                        if (get_task_paymentType task) = Pre then 
                            if suppliedGas < totalGas then
                                (PaymentOrder (( totalGas - suppliedGas )* price) 0 0 taskId WaitingForPayment direction)
                            else
                                (PaymentOrder (( suppliedGas - totalGas ) * price) 0 0 taskId WaitingForPayment direction)
                        else if (get_task_paymentType task) = Post then 
                            (PaymentOrder ( suppliedGas * price) 0 0 taskId WaitingForPayment direction)
                        else 
                            (PaymentOrder ( suppliedGas * price) (get_task_paymentTime task) 0 taskId WaitingForPayment direction)
                    end;

                (* Campaign -> Campaign *)
                fun add_payment_order campaign order = 
                    set_campaign_paymentOrders campaign (( get_campaign_paymentOrders campaign) @ [order])
            in
                if sender = (get_person_addr (get_task_captain task)) then
                    if (get_campaign_phase campaign) = PhaseTasks then
                        if (get_task_taskStatus task) = TaskCompleted then
                            if (suppliedGas <> totalGas) then 
                                SOME (SCCampaign (add_payment_order 
                                                    (ContractPrivate.p_update_Campaign_tasks campaign (set_task_taskStatus task Confirmed) taskId) 
                                                    (make_payment_order task )))
                                                    
                            else
                                SOME (SCCampaign (ContractPrivate.p_update_Campaign_tasks campaign (set_task_taskStatus task Confirmed) taskId))
                        else 
                            NONE ( "No gas requests.")
                    else
                        NONE ( "Action is not allowed at this point")
                else 
                    NONE ( "Only captain allowed to do this action.")
            end;

        val validated = (validate_params params campaign);
    in
        if Option.isNone (get_err validated) then 
            action context params campaign
        else
            validated
    end;

end;fun extract somelist foo = 
    case somelist of
    [] => "[]"
    | (x::tail) => if tail = [] then foo x else foo x ^ extract tail foo;

fun negotiation_toString x = 
    if x = NotSet then 
        "NotSet" 
    else if x = WaitingCustomer then 
        "WaitingCustomer"
    else if x = WaitingSupplier then 
        "WaitingSupplier" 
    else if x = NegotiationRejected then 
        "NegotiationRejected" 
    else "NegotiationApproved" 

fun negotiation_toPrettyString x =
    "\t\t\tNgtn: " ^ negotiation_toString x ^ "\n";

(* PaymentStatus -> string *)
fun paymentStatus_toString x = 
    if x = WaitingForPayment then 
        "WaitingForPayment" 
    else if x = PaymentCompleted then 
        "PaymentCompleted"
    else "PaymentRejected" 

(* string -> string *)
fun paymentStatus_toPrettyString x =
    "\t\t\tPaymentStatus: " ^ paymentStatus_toString x ^ "\n";
    
(* Phase -> string *)
fun phase_toString x = 
    case x of
       PhaseAgreement => "PhaseAgreement"
     | PhaseTasks => "PhaseTasks"
     | PhaseDeclined => "PhaseDeclined";

(* string -> string *)
fun phase_toPrettyString x =
    "\t\t\tPhase: " ^ phase_toString x ^ "\n";

(* Phase -> string *)
fun taskStatus_toString x = 
    case x of
       TaskNotAccepted => "TaskNotAccepted"
     | TaskAccepted => "TaskAccepted"
     | TaskReadyToPerform => "TaskReadyToPerform"
     | GasRequested => "GasRequested"
     | Performing => "Performing"
     | Confirmed => "Confirmed"
     | TaskCompleted => "TaskCompleted";

(* string -> string *)
fun taskStatus_toPrettyString x =
    "\t\t\tTaskStatus: " ^ taskStatus_toString x ^ "\n";

(* PaymentType -> string *)
fun paymentType_toString x = 
    case x of
       Pre => "Pre"
     | Post => "Post"
     | Delayed => "Delayed";

(* string -> string *)
fun paymentType_toPrettyString x =
    "\t\t\tPaymentType: " ^ paymentType_toString x ^ "\n";

(* PriceChange string functions *)

(* PriceChange -> string *)
fun priceChange_toString x =
    case x of PriceChange price negotiation startTime =>
    Int.toString price ^
    negotiation_toString negotiation ^
    Int.toString startTime;

(* string -> string *)
fun priceChange_toPrettyString x =
    case x of PriceChange price negotiation startTime =>
    "\t\t\tPrce: " ^ Int.toString price ^ "\n" ^
    "\t\t\tNgtn: " ^ negotiation_toPrettyString negotiation ^ "\n" ^
    "\t\t\tStTm: " ^ Int.toString startTime ^ "\n";

(* Person string functions *) 

(* Person -> string *)
fun person_toString x =
    case x of Person addr name =>
    Int.toString addr ^
    name;  

(* string -> string *)
fun person_toPrettyString x =
    case x of Person addr name =>
    "\t\t\taddr: " ^ Int.toString addr ^ "\n" ^
    "\t\t\tName: " ^ name ^ "\n";

(* AgreementDetails string functions *) 

(* AgreementDetails -> string *)
fun agreementDetails_toString x =
    case x of AgreementDetails details bankAddress =>
    details ^
    Int.toString bankAddress;    

(* string -> string *)
fun agreementDetails_toPrettyString x =
    case x of AgreementDetails details bankAddress =>
    "\t\t\tName: " ^ details ^ "\n" ^
    "\t\t\taddr: " ^ Int.toString bankAddress ^ "\n";

(* Agreement string functions *) 
fun agreement_toString x =
    case x of Agreement negotiation customer supplier details =>
    negotiation_toString negotiation ^
    person_toString customer ^
    person_toString supplier ^
    agreementDetails_toString details;    

fun agreement_toPrettyString x =
    case x of Agreement negotiation customer supplier details =>
    "\t\t\tNgtn: " ^ negotiation_toPrettyString negotiation ^ "\n" ^
    "\t\t\tCstm: " ^ person_toPrettyString customer ^ "\n" ^
    "\t\t\tSplr: " ^ person_toPrettyString supplier ^ "\n" ^
    "\t\t\tDtls: " ^ agreementDetails_toPrettyString details ^ "\n";

fun bool_to_string b = if b then "True" else "False";

(* PaymentOrder string functions *)
fun paymentOrder_toString x =
    case x of PaymentOrder amount paymentTime paymentId taskId paymentStatus direction =>
    Int.toString amount ^
    Int.toString paymentTime ^
    Int.toString paymentId ^
    Int.toString taskId ^ 
    paymentStatus_toPrettyString paymentStatus ^
    bool_to_string direction ;    

fun paymentOrder_toPrettyString x =
    case x of PaymentOrder amount paymentTime paymentId taskId paymentStatus direction =>
    "\t\t\tAmount: " ^ Int.toString amount ^ "\n" ^
    "\t\t\tPmTime: " ^ Int.toString paymentTime ^ "\n" ^
    "\t\t\tPmIndx: " ^ Int.toString paymentId ^ "\n" ^
    "\t\t\tTaskId: " ^ Int.toString taskId ^ "\n" ^
    paymentStatus_toPrettyString paymentStatus ^
    "\t\t\tDirection: " ^ bool_to_string direction ;

(* Task string functions *)
fun task_toString x =
    case x of Task taskId negotiation captain worker expectedGas requestedGas suppliedGas totalGas requestTime suppliedTime completionTime paymentTime taskStatus paymentType => 
    Int.toString taskId ^ 
    negotiation_toString negotiation ^
    person_toString captain ^ 
    person_toString worker ^ 
    Int.toString expectedGas ^ 
    Int.toString requestedGas ^ 
    Int.toString suppliedGas ^ 
    Int.toString totalGas ^
    Int.toString requestTime ^ 
    Int.toString suppliedTime ^ 
    Int.toString completionTime ^ 
    Int.toString paymentTime ^ 
    taskStatus_toString taskStatus ^
    paymentType_toString paymentType ;

fun task_toPrettyString x =
    case x of Task taskId negotiation captain worker expectedGas requestedGas suppliedGas totalGas requestTime suppliedTime completionTime paymentTime taskStatus paymentType => 
    "\t TskId:" ^ Int.toString taskId ^ "\n" ^ 
    "\t Negotiation:" ^ negotiation_toString negotiation ^ "\n" ^ 
    "\t Captn:\n" ^ person_toPrettyString captain ^ "\n" ^ 
    "\t Workr:\n" ^ person_toPrettyString worker ^ "\n" ^ 
    "\t ExpGs:" ^ Int.toString expectedGas ^ "\n" ^ 
    "\t ReqGs:" ^ Int.toString requestedGas ^ "\n" ^ 
    "\t SupGs:" ^ Int.toString suppliedGas ^ "\n" ^ 
    "\t totalGas:" ^ Int.toString totalGas ^ "\n" ^ 
    "\t ReqTm:" ^ Int.toString requestTime ^ "\n" ^ 
    "\t SupTm:" ^ Int.toString suppliedTime ^ "\n" ^ 
    "\t CmpTm:" ^ Int.toString completionTime ^ "\n" ^ 
    "\t paymentTime:" ^ Int.toString paymentTime ^ "\n" ^
    taskStatus_toPrettyString taskStatus ^
    "\t paymentType:" ^ paymentType_toString paymentType ^ "\n" ;

(* Campaign string functions *)
fun campaign_toString x = 
    case x of Campaign agreement tasks negotiation priceChanges phase paymentOrders => 
    agreement_toString agreement  ^ 
    extract tasks task_toString ^ 
    negotiation_toPrettyString negotiation ^ 
    extract priceChanges priceChange_toString ^
    phase_toString phase ^  
    extract paymentOrders paymentOrder_toString;

fun campaign_toPrettyString x = 
    case x of Campaign agreement tasks negotiation priceChanges phase paymentOrders => 
    "Agrmt: " ^ agreement_toPrettyString agreement  ^ "\n" ^
    "Tasks:\n" ^ extract tasks task_toPrettyString^
    "Negot: " ^ negotiation_toPrettyString negotiation ^ "\n" ^
    "PrChn: " ^ extract priceChanges priceChange_toPrettyString ^ "\n" ^
    "Phase: " ^ phase_toPrettyString phase ^ "\n" ^
    "paymentOrders: " ^ extract paymentOrders paymentOrder_toPrettyString ^ "\n" ;

fun scValue_toPrettyString x =
    case x of 
       SCString str => "RET string: " ^ str ^ "\n"
     | SCInt integer => "RET int: " ^ (Int.toString integer) ^ "\n"
     | SCBool someBool => "RET bool: " ^ (bool_to_string someBool) ^ "\n"
     | SCNegotiation negotiation => negotiation_toPrettyString negotiation
     | SCPaymentStatus paymentStatus => paymentStatus_toPrettyString paymentStatus
     | SCAgreementDetails agreementDetails => agreementDetails_toPrettyString agreementDetails
     | SCPerson person => person_toPrettyString person
     | SCPaymentOrder paymentOrder => paymentOrder_toPrettyString paymentOrder
     | SCPriceChange priceChange => priceChange_toPrettyString priceChange
     | SCPhase phase => phase_toPrettyString phase
     | SCTaskStatus taskStatus => taskStatus_toPrettyString taskStatus
     | SCPaymentType paymentType => paymentType_toPrettyString paymentType
     | SCAgreement agreement => "RET agreement: " ^ agreement_toPrettyString agreement
     | SCTask task => task_toPrettyString task
     | SCCampaign campaign => campaign_toPrettyString campaign;structure ContractRuntimePrivate = 
struct
    (* int -> (Word8.word list) -> (SCValue list) -> (SCValue OptionErr)*)
    fun execute f context params campaign = 
        case f of 
        2 => Contract.getAgreement context params campaign
        | 3 => Contract.rejectAgreement context params campaign
        | 4 => Contract.approveAgreement context params campaign
        | 5 => Contract.changeAgreementDetails context params campaign
        | 6 => Contract.getPriceChangeWithNumber context params campaign
        | 7 => Contract.getPriceChangesLength context params campaign
        | 8 => Contract.rejectPrice context params campaign
        | 9 => Contract.approvePrice context params campaign
        | 10 => Contract.declinePrice context params campaign
        | 11 => Contract.createPriceChange context params campaign
        | 12 => Contract.getTask context params campaign
        | 13 => Contract.approveTask context params campaign
        | 14 => Contract.rejectTask context params campaign
        | 15 => Contract.acceptTask context params campaign
        | 17 => Contract.addTask context params campaign
        | 18 => Contract.readyToPerformTask context params campaign
        | 19 => Contract.requestGas context params campaign
        | 20 => Contract.paymentCompleted context params campaign
        | 21 => Contract.performTask context params campaign
        | 22 => Contract.taskCompleted context params campaign
        | 23 => Contract.confirmTask context params campaign
        | n => NONE "The function doesn't exist";
end;

structure ContractRuntime = 
struct
    fun call f context params =
    let        
        val storage = (get_context_storage context);

        (*(Word8Word list) -> Campaign option*)
        fun deserialize storage = 
            if storage = [] then 
                None
            else 
                Some (fst (Campaign.deserialize (ByteArray.from_list storage)));
        
        val campaign = deserialize storage;

        val optionCampaign = 
            if Option.isSome campaign then
                if f <> 1 then
                    (ContractRuntimePrivate.execute f context params (Option.valOf campaign))
                else 
                    NONE "Storage is not empty"
            else if f = 1 then 
                Contract.constructor context params
            else
                NONE "Error deserializtion";        
    in
        if Option.isNone (get_err optionCampaign) then
            if Option.isSome (get optionCampaign) then
                SOME (Campaign.serialize (Option.valOf (scValue_to_campaign (Option.valOf ( get optionCampaign )))))
            else
                RET (Campaign.serialize (Option.valOf (scValue_to_campaign (Option.valOf ( get_ret_state optionCampaign )))))  (SCvalue.serialize (Option.valOf ( get_ret_val optionCampaign )))
        else
            NONE (Option.valOf (get_err optionCampaign))
    end;
end;datatype computed_state = ComputedState state_tree tx_accumulator;

structure ComputedState = 
struct
	fun get_state_tree (ComputedState tree _) = tree;
	fun set_state_tree (ComputedState _ accum) tree = ComputedState tree accum;

	fun get_tx_accum (ComputedState _ accum) = accum;
	fun set_tx_accum (ComputedState tree _) accum = ComputedState tree accum;

	fun reduce state version =
		let
			val new_state_tree = StateTree.reduce (get_state_tree state) version
			val new_accum = TxAccumulator.recalculate_merkle_tree (TxAccumulator.reduce (get_tx_accum state) version)
		in
			ComputedState new_state_tree new_accum
		end
end;datatype state_computer_node = StateComputerNode executed_block hash_value;

structure StateComputerNode = 
struct
	fun get_block (StateComputerNode block _) = block;
	fun get_state_id (StateComputerNode _ state_id) = state_id;
	fun get_result node = ExecutedBlock.get_state_compute_result (get_block node);
	fun get_version node = StateComputeResult.get_current_version (get_result node);
end;structure TxExecutionUtil = 
struct
	fun filter_success pair =
		case (snd pair) of
			Success => True
			| Failure => False

	fun get_success_txs blocks =
		let
			fun map_block block =
				let
					val transactions = ExecutedBlock.get_transactions block
					val statuses = StateComputeResult.get_compute_status (ExecutedBlock.get_state_compute_result block)
				in
					List.zip (transactions, statuses)
				end
		in
			fst (List.unzip (List.filter filter_success (List.concat (List.map map_block blocks))))
		end;

	fun get_success_info_list info_list statuses =
		fst (List.unzip (List.filter filter_success (List.zip (info_list, statuses))));

	fun create_info tx tree storage =
		let
			val version = StateTree.get_version tree
			val fetch_result = StateTree.root_hash tree storage version
			val state_hash = (StateFetchResult.get_value fetch_result)
			val tx_hash = Hashing.from_tx tx
		in
			TransactionInfo tx_hash state_hash
		end;
end;exception StateComputerNoAccount guid;
exception StateComputerSignaturesInvalid guid (sign set);
exception StateComputerNonceMismatch int int;
exception StateComputerAccountAlreadyExists guid;
exception StateComputerAccountNotFonfirmed guid;
exception StateComputerExpectedNotEmptyList;
exception StateComputerInvalidValue;
exception StateComputerInvalidAccountId;
exception StateComputerInvalidPublicKey byte_array;
exception StateComputerDuplicatedPublicKey;
exception StateComputerMismatchPublicKeys (public_key list) (public_key list);
exception StateComputerVersionMismatch int int;

exception StateComputerInvalidCommitChain;
exception StateComputerBlockNotExists hash_value;
exception StateComputerMissingNode hash_value;
exception StateComputerMissingState hash_value;
exception StateComputerMissingAccumRoot;
exception StateComputerAccumMismatch hash_value hash_value;

exception StateComputerUnexpectedVersion int;
exception StateComputerUnexpectedLedgerInfo int;
exception StateComputerUnexpectedGenesisAccounts block;

structure TxExecutionCheck = 
struct
	fun read_version_or_raise storage =
		let
			val version = Option.getOpt (TransactionReader.read_tx_count storage) ~1
		in
			if version >= 0 then
				version
			else
				raise StateComputerUnexpectedVersion version
		end;

	fun read_last_li_or_raise storage =
		let
			val li_count = Option.getOpt (TransactionReader.read_li_count storage) 0
		in
			if li_count > 0 then
				case TransactionReader.read_li storage (li_count - 1) of
					Some ledger_info => ledger_info
					| None => raise StateComputerUnexpectedLedgerInfo li_count
			else
				raise StateComputerUnexpectedLedgerInfo li_count
		end;

	fun fetch_accum_root_or_raise accum =
		case (TxAccumulator.get_root accum) of
			Some hash_value => hash_value
			| None => raise StateComputerMissingAccumRoot

	fun fetch_state_or_raise block_id block_version commit_block_id commit_state_id commit_version nodes states =
		let
			fun fetch_state_id () =
				case Map.lookup nodes block_id of
					Some (StateComputerNode _ state_id) => state_id
					| None => raise StateComputerMissingNode block_id

			fun fetch_state state_id version =
				case Map.lookup states state_id of
					Some state => ComputedState.reduce state version
					| None => raise StateComputerMissingState state_id
		in
			if (ByteArray.equal block_id commit_block_id) then
				(commit_state_id, fetch_state commit_state_id commit_version)
			else 
				let
					val state_id = fetch_state_id ()
				in
					(state_id, fetch_state state_id block_version)
				end				
		end;		

	fun ensure_signatures account tx =
		let
			val message = TransactionPayload.serialize (SignedTransaction.get_payload tx)
			val signatures = SignedTransaction.get_signatures tx
		in
			if not (AccountValidation.validate_signatures account message signatures) then
				raise StateComputerSignaturesInvalid (Account.get_account_id account) signatures
			else 
				()
		end;

	fun ensure_nonce account tx =
		let
			val acc_nonce = Account.get_nonce account
			val tx_nonce = TransactionPayload.get_nonce (SignedTransaction.get_payload tx)
		in
			if not (acc_nonce = tx_nonce) then
				raise StateComputerNonceMismatch acc_nonce tx_nonce
			else
				()
		end;

	fun ensure_no_account account_id tree storage =
		let
			val version = StateTree.get_version tree
		in
			case (StateTree.get_account tree storage account_id version) of
				StateFetchResult (Some account) _ => raise StateComputerAccountAlreadyExists account_id
				| StateFetchResult None _ => ()
		end;

	fun ensure_account_confirmed account =
		if not (Account.get_is_confirmed account) then
				raise StateComputerAccountNotFonfirmed (Account.get_account_id account)
			else
				();

	fun ensure_not_empty alist =
		if List.null alist then
				raise StateComputerExpectedNotEmptyList
			else
				();

	fun ensure_none optional =
		if (Option.isSome optional) then
			raise StateComputerInvalidValue
		else 
			();

	fun ensure_value comparator expected actual =
		if (comparator expected actual) <> Equal then
			raise StateComputerInvalidValue
		else
			();


	fun ensure_valid_account_id account_id =
		if not (Word8Array.length account_id = (Guid.size ())) then
			raise StateComputerInvalidAccountId
		else
			();

	fun fetch_accounts_from_block_or_raise block =
		case Block.get_accounts block of
			Some account_set => Set.to_list account_set
			| None => raise StateComputerUnexpectedGenesisAccounts block;

	fun fetch_existing_account account_id version tree storage =
		let
			val _ = ensure_valid_account_id account_id
		in
			case (StateTree.get_account tree storage account_id version) of
			   StateFetchResult (Some account) tree => StateFetchResult account tree
			 | StateFetchResult None tree => raise StateComputerNoAccount account_id
		end;

	fun ensure_valid_public_keys keys =
		let
			fun ensure_all_keys_of_valid_size () =
				let
					val invalid_key = List.find (fn key => not ((Word8Array.length key) = (Keypair.pub_size ()))) keys
				in
					case invalid_key of
						Some key => raise StateComputerInvalidPublicKey key
						| None => ()
				end
			
			fun ensure_no_duplications () =
				let
					val keys_set = Set.from_list (ByteArray.compare) keys
				in
					if (Set.length keys_set) <> (List.length keys) then
						raise StateComputerDuplicatedPublicKey
					else
						()
				end
		in
			(ensure_all_keys_of_valid_size (); ensure_no_duplications ())
		end;

	fun ensure_public_keys_exist_in_account account keys =
		let
			val account_keys = Set.to_list (Account.get_public_keys account)
			val result = List.all (fn key => (List.exists (fn num => (ByteArray.equal num key)) account_keys)) keys
		in
			if result then
				()
			else 
				raise (StateComputerMismatchPublicKeys account_keys keys)
		end;

	fun ensure_master account =
		ensure_value (Int.compare) (Account.get_type account) (Account.master ());

	fun ensure_user account =
		ensure_value (Int.compare) (Account.get_type account) (Account.user ());

	fun ensure_block_exists commit_id nodes block =
		let
			val block_id = Hashing.from_executed_block block
		in
			if not ((ByteArray.equal commit_id block_id) orelse (Option.isSome (Map.lookup nodes block_id))) then
				raise StateComputerBlockNotExists block_id
			else
				()
		end;

	fun ensure_blocks_exist commit_id nodes blocks =
		List.app (ensure_block_exists commit_id nodes) blocks;

	fun ensure_valid_chain_from_root commit_id blocks =
		let
			fun ensure_extension prev_id block =
				let
					val block_id = Hashing.from_executed_block block
					val parent_id = ExecutedBlock.get_parent_hash block
				in
					if (ByteArray.equal parent_id prev_id) then
						block_id
					else
						raise StateComputerInvalidCommitChain
				end
		in
			(List.foldl ensure_extension commit_id blocks; ())
		end;

	fun ensure_valid_ledger_info commit_id commit_version states storage signed_ledger_info =
		let
			fun fetch_commit_tree_or_raise () =
				case Map.lookup states commit_id of
					Some state => ComputedState.get_state_tree state
					| None => raise (StateComputerMissingState commit_id)

			val tree = fetch_commit_tree_or_raise ()
			val message = LedgerInfo.serialize (SignedLedgerInfo.get_ledger_info signed_ledger_info)

			fun ensure_signature account_id signatre =
				let	
					val (StateFetchResult account _) = fetch_existing_account account_id commit_version tree storage
				in
					if not (AccountValidation.validate_signature account message signatre) then
						raise StateComputerSignaturesInvalid account_id (Set.from_list (ByteArray.compare) [signatre])
					else 
						()
				end
		in
			List.app (fn (account_id, signatre) => ensure_signature account_id signatre)
				 (Map.toAscList (SignedLedgerInfo.get_signatures signed_ledger_info))
		end;

	fun ensure_final_state state signed_ledger_info = 
		let
			val root = fetch_accum_root_or_raise (ComputedState.get_tx_accum state)
			val ledger_state_id = BlockInfo.get_executed_state_id (SignedLedgerInfo.get_commit_info signed_ledger_info)
		in
			if not (ByteArray.equal root ledger_state_id) then
				raise StateComputerAccumMismatch root ledger_state_id
			else
				()
		end;
	fun check_account_storage_key key =
		let
			val key_len = String.size key

			fun check_if_length_proper key =
				if ((key_len = 0) orelse (key_len > 32)) then
					False
				else
					True

			fun check_if_letter chr =
				((Char.ord #"a" <= chr) andalso (chr <= Char.ord #"z"))
					orelse
				((Char.ord #"A" <= chr) andalso (chr <= Char.ord #"Z"))

			fun check_if_digit chr =
				(chr >= Char.ord #"0") andalso (chr <= Char.ord #"9")

			fun check_if_hyphen_or_underscore chr =
				(chr = Char.ord #"-") orelse (chr = Char.ord #"_")

			fun check_chars s =
				let
					val chars_list = String.explode s
					fun check_all_except_first chr =
						let
							val chr_ord = Char.ord chr
						in
							((check_if_letter chr_ord) orelse (check_if_digit chr_ord) orelse (check_if_hyphen_or_underscore chr_ord))
						end
				in
					(check_if_letter (Char.ord (List.hd chars_list)))
						andalso
					(
					if key_len > 1 then
						(List.all (check_all_except_first) (List.tl chars_list))
					else
						True
					)
				end

		in
			(check_if_length_proper key)
				andalso
			(check_chars key)
		end;
end;

val _ = 
    Exception.add_exn_name_printer 
        (fn e => 
            case e of 
                StateComputerNoAccount _ => "StateComputerNoAccount"
			  | StateComputerSignaturesInvalid _ _ => "StateComputerSignaturesInvalid"
			  | StateComputerNonceMismatch _ _ => "StateComputerNonceMismatch"
			  | StateComputerAccountAlreadyExists _ => "StateComputerAccountAlreadyExists"
			  | StateComputerAccountNotFonfirmed _ => "StateComputerAccountNotFonfirmed"
			  | StateComputerExpectedNotEmptyList => "StateComputerExpectedNotEmptyList"
			  | StateComputerInvalidValue => "StateComputerInvalidValue"
			  | StateComputerInvalidAccountId => "StateComputerInvalidAccountId"
			  | StateComputerInvalidPublicKey _ => "StateComputerInvalidPublicKey"
			  | StateComputerDuplicatedPublicKey => "StateComputerDuplicatedPublicKey"
			  | StateComputerMismatchPublicKeys _ _ => "StateComputerMismatchPublicKeys"
			  | StateComputerVersionMismatch _ _ => "StateComputerVersionMismatch"
			  | StateComputerInvalidCommitChain => "StateComputerInvalidCommitChain"
			  | StateComputerBlockNotExists _ => "StateComputerBlockNotExists"
			  | StateComputerMissingNode _ => "StateComputerMissingNode"
			  | StateComputerMissingState _ => "StateComputerMissingState"
			  | StateComputerMissingAccumRoot => "StateComputerMissingAccumRoot"
			  | StateComputerAccumMismatch _ _ => "StateComputerAccumMismatch"
			  | StateComputerUnexpectedVersion _ => "StateComputerUnexpectedVersion"
			  | StateComputerUnexpectedLedgerInfo _ => "StateComputerUnexpectedLedgerInfo"
			  | StateComputerUnexpectedGenesisAccounts _ => "StateComputerUnexpectedGenesisAccounts"
              | _ => raise Exception.Unknown
        )
val _ = 
    Exception.add_exn_message_printer
        (fn e =>
            case e of
                StateComputerNoAccount v1 => 
					"StateComputerNoAccount" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerSignaturesInvalid v1 v2 => 
			  		"StateComputerSignaturesInvalid" ^ " " ^ Hex.bytes_to_hex v1 ^ "\n" ^
					Formatter.set_to_string ("  " ^ "  " ^ "  " ^ "  " ^ "  " ^ "  ") Hex.bytes_to_hex v2
			  | StateComputerNonceMismatch v1 v2 => 
			  		"StateComputerNonceMismatch" ^ " " ^ Int.toString v1 ^ " " ^ Int.toString v2
			  | StateComputerAccountAlreadyExists v1 => 
			  		"StateComputerAccountAlreadyExists" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerAccountNotFonfirmed v1 => 
			  		"StateComputerAccountNotFonfirmed" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerExpectedNotEmptyList => 
			  		"StateComputerExpectedNotEmptyList"
			  | StateComputerInvalidValue => 
			  		"StateComputerInvalidValue"
			  | StateComputerInvalidAccountId => 
			  		"StateComputerInvalidAccountId"
			  | StateComputerInvalidPublicKey v1 => 
			  		"StateComputerInvalidPublicKey" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerDuplicatedPublicKey => 
			  		"StateComputerDuplicatedPublicKey"
			  | StateComputerMismatchPublicKeys (public_key_list_0) (public_key_list_1) => 
			  		"StateComputerMismatchPublicKeys" ^ " "
			  | StateComputerVersionMismatch v1 v2 => 
			  		"StateComputerVersionMismatch" ^ " " ^ Int.toString v1 ^ " " ^ Int.toString v2
			  | StateComputerInvalidCommitChain => 
			  		"StateComputerInvalidCommitChain"
			  | StateComputerBlockNotExists v1 => 
			  		"StateComputerBlockNotExists" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerMissingNode v1 => 
			  		"StateComputerMissingNode" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerMissingState v1 => 
			  		"StateComputerMissingState" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerMissingAccumRoot => 
			  		"StateComputerMissingAccumRoot"
			  | StateComputerAccumMismatch v1 v2 => 
			  		"StateComputerAccumMismatch" ^ " " ^ Hex.bytes_to_hex v1 ^ " " ^ Hex.bytes_to_hex v2
			  | StateComputerUnexpectedVersion v1 => 
			  		"StateComputerUnexpectedVersion" ^ " " ^ Int.toString v1
			  | StateComputerUnexpectedLedgerInfo v1 => 
			  		"StateComputerUnexpectedLedgerInfo" ^ " " ^ Int.toString v1
			  | StateComputerUnexpectedGenesisAccounts block => 
			  		"StateComputerUnexpectedGenesisAccounts" ^ " "
              | _ => raise Exception.Unknown
        )
datatype query_result = QuerySuccess byte_array | QueryFailure string;

structure QueryResult = 
struct
	fun to_string prefix query =
		case query of
		   QuerySuccess result => (prefix ^ "QuerySuccess: " ^ (Hex.bytes_to_hex result) ^ "\n")
		 | QueryFailure error =>  (prefix ^ "QueryFailure: " ^ error ^ "\n")

	fun serialize enum = 
		case enum of
		   QuerySuccess result => ByteArray.concat (Serialization.encode_int8 0) result
		 | QueryFailure error =>  ByteArray.concat (Serialization.encode_int8 1) (Serialization.encode_string error)

	fun deserialize bytes = 
		case (Word8.toInt (Word8Array.sub bytes 0)) of
		   0 =>
		   		let
					val bytes_list = ByteArray.to_list bytes
					val len = List.length bytes_list
					val result = (ByteArray.from_list (List.drop bytes_list 1))
				in
					(QuerySuccess result, len)
				end
		 | 1 => 
		 		let
					val (error, len) = Serialization.decode_string (ByteArray.from_list (List.drop (ByteArray.to_list bytes) 1))
				in
					((QueryFailure error), (len + 1))
				end

	fun isSuccess query_result = 
		case query_result of
		   QuerySuccess _ => True
		 | QueryFailure _ => False
end;datatype execution_results = TxExecResults state_tree (transaction_status list) (transaction_info list);
datatype execution_result = TxExecResult state_tree transaction_status transaction_info;

structure TxExecResults = 
struct
	fun get_tree (TxExecResults tree _ _) = tree;
	fun get_statuses (TxExecResults _ statuses _) = statuses;
	fun get_info_list (TxExecResults _ _ info_list) = info_list;
end

exception StateComputerInvalidContractOrParams (int option) (SCvalue list option);
exception StateComputerInvalidFunctionName string;
exception StateComputerInvalidStorageKey;

structure TxExecution = 
struct
	fun extract_result result = 
		if Option.isNone (get_err result) then
			if Option.isSome (get_ret_state result) then
				get_ret_state result
			else   
				get result
		else 
			None

	fun tx_create_contract tx tree storage = 
		let
			fun fun_name_toInt name = 
				case name of 
					SCString "constructor" => Some 1
					| n => None 

			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx
			val data = TransactionPayload.get_data payload
			val scValue_list = Option.map (fn data => fst (Serialization.decode_list SCvalue.deserialize data)) data
			
			val function_number = Option.mapPartial fun_name_toInt (Option.map List.hd scValue_list)

			val params = Option.map List.tl scValue_list 

			(* Validate sender account *)
			val guid_from = TransactionPayload.get_from payload
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account guid_from version tree storage
			val _ = TxExecutionCheck.ensure_nonce sender tx
			val _ = TxExecutionCheck.ensure_signatures sender tx

			(*validate new account id*)
			val guid_to = (TransactionPayload.get_to payload)
			val _ = TxExecutionCheck.ensure_valid_account_id (Option.valOf guid_to)
			val _ = TxExecutionCheck.ensure_no_account (Option.valOf guid_to) tree storage

			val blockNum = version
			val msg_sender = BigEndian.bytes_to_int guid_from

			val context = Context msg_sender blockNum []
			val result = if (Option.isSome function_number) andalso (Option.isSome params) 
				then ContractRuntime.call (Option.valOf function_number) context (Option.valOf params)
				else raise StateComputerInvalidContractOrParams function_number params

			val empty_map = Map.empty (String.compare)
			val new_state = extract_result result
			val new_storage = Map.insert empty_map (Account.state_key()) (Option.valOf new_state)

			(*create new account*)
			val account = Account.create_contract (Option.valOf guid_to) (Set.empty ByteArray.compare)
			val account = Account.set_storage account (Map.toAscList new_storage)

			val sender = Account.inc_nonce sender

			(*save account*)
			val new_tree = StateTree.upgrade tree storage [sender,account]

		in
			if (Option.isSome function_number) andalso (Option.isSome new_state) then 
				TxExecResult new_tree Success (TxExecutionUtil.create_info tx new_tree storage)
			else
				TxExecResult tree Failure (TxExecutionUtil.create_info tx tree storage)
		end

	fun tx_contract_call tx tree storage = 
		let
			fun fun_name_toInt name = 
				case name of 
					SCString "constructor" => Some 1
					| SCString "getAgreement" => Some 2
					| SCString "rejectAgreement" => Some 3
					| SCString "approveAgreement" => Some 4
					| SCString "changeAgreementDetails" => Some 5
					| SCString "getPriceChangeWithNumber" => Some 6
					| SCString "getPriceChangesLength" => Some 7
					| SCString "rejectPrice" => Some 8
					| SCString "approvePrice" => Some 9
					| SCString "declinePrice" => Some 10
					| SCString "createPriceChange" => Some 11
					| SCString "getTask" => Some 12
					| SCString "approveTask" => Some 13
					| SCString "rejectTask" => Some 14
					| SCString "acceptTask" => Some 15
					(* function 16 has been removed from smart contract *)
					| SCString "addTask" => Some 17
					| SCString "readyToPerformTask" => Some 18
					| SCString "requestGas" => Some 19
					| SCString "paymentCompleted" => Some 20
					| SCString "performTask" => Some 21
					| SCString "taskCompleted" => Some 22
					| SCString "confirmTask" => Some 23
					| n => None 

			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx
			val data = TransactionPayload.get_data payload
			val scValue_list = Option.map (fn data => fst (Serialization.decode_list SCvalue.deserialize data)) data
		
			val function_number = Option.mapPartial fun_name_toInt (Option.map List.hd scValue_list)

			val params = Option.map List.tl scValue_list

			val guid_from = TransactionPayload.get_from payload

			(* Validate sender account *)
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account guid_from version tree storage
			val _ = TxExecutionCheck.ensure_nonce sender tx
			val _ = TxExecutionCheck.ensure_signatures sender tx

			val guid_to = Option.valOf (TransactionPayload.get_to payload)
			val (StateFetchResult contract tree) = TxExecutionCheck.fetch_existing_account guid_to version tree storage
			val contract_storage = Account.get_storage contract
			val storage_map = Map.fromList String.compare contract_storage
			val state = Map.lookup storage_map (Account.state_key())

			val blockNum = version
			val msg_sender = BigEndian.bytes_to_int guid_from

			val context = Context msg_sender blockNum (ByteArray.to_list (Option.valOf state))

			val result = if (Option.isSome function_number) andalso (Option.isSome params) 
				then ContractRuntime.call (Option.valOf function_number) context (Option.valOf params)
				else raise StateComputerInvalidContractOrParams function_number params

			val new_state = extract_result result
			val new_storage = Map.insert storage_map (Account.state_key()) (Option.valOf new_state)

			val new_account = Account.set_storage contract (Map.toAscList new_storage)

			val sender = Account.inc_nonce sender
			val new_tree = StateTree.upgrade tree storage [sender, new_account]

		in
			if (Option.isSome function_number) andalso (Option.isSome new_state) then 
				TxExecResult new_tree Success (TxExecutionUtil.create_info tx new_tree storage)
			else
				TxExecResult tree Failure (TxExecutionUtil.create_info tx tree storage)
		end

	fun tx_create_user_account tx tree storage = 
		let
			val payload = SignedTransaction.get_payload tx

			(*make sure no meaning fields are not set*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_to payload)
			val _ = TxExecutionCheck.ensure_value (Int.compare) (TransactionPayload.get_nonce payload) 0

			(*validate new account id*)
			val from = TransactionPayload.get_from payload
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val _ = TxExecutionCheck.ensure_no_account from tree storage

			(*decode public keys and validate*)
			val data = Option.valOf (TransactionPayload.get_data payload)
			val (pkeys, _) = Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) data
			val _ = TxExecutionCheck.ensure_not_empty pkeys
			val _ = TxExecutionCheck.ensure_valid_public_keys pkeys

			(*create new account*)
			val account = Account.create_user from (Set.from_list (ByteArray.compare) pkeys)
			val _ = TxExecutionCheck.ensure_signatures account tx
			val account = Account.inc_nonce account

			(*save account*)
			val tree = StateTree.upgrade tree storage [account]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end;

	fun tx_approve_user_account tx tree storage =
		let
			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx

			(*validate that no meaning fields are not passed*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_data payload)

			(*fetch and validate tx sender*)
			val from = (TransactionPayload.get_from payload)
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account from version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed sender
			val _ = TxExecutionCheck.ensure_signatures sender tx
			val _ = TxExecutionCheck.ensure_master sender
			val _ = TxExecutionCheck.ensure_nonce sender tx

			(*fetch and validate target account*)
			val to = Option.valOf (TransactionPayload.get_to payload)
			val _ = TxExecutionCheck.ensure_valid_account_id to
			val (StateFetchResult target tree) = TxExecutionCheck.fetch_existing_account to version tree storage
			val _ = TxExecutionCheck.ensure_value (Bool.compare) (Account.get_is_confirmed target) False
			val _ = TxExecutionCheck.ensure_user target

			(*change state*)
			val target = Account.set_is_confirmed target True
			val sender = Account.inc_nonce sender

			(*save state*)
			val tree = StateTree.upgrade tree storage [sender, target]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end;
	
	fun tx_block_user_account tx tree storage =
		let
			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx

			(*validate that no meaning fields are not passed*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_data payload)

			(*fetch and validate tx sender*)
			val from = (TransactionPayload.get_from payload)
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account from version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed sender
			val _ = TxExecutionCheck.ensure_signatures sender tx
			val _ = TxExecutionCheck.ensure_master sender
			val _ = TxExecutionCheck.ensure_nonce sender tx

			(*fetch and validate target account*)
			val to = Option.valOf (TransactionPayload.get_to payload)
			val _ = TxExecutionCheck.ensure_valid_account_id to
			val (StateFetchResult target tree) = TxExecutionCheck.fetch_existing_account to version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed target
			val _ = TxExecutionCheck.ensure_user target

			(*change state*)
			val target = Account.set_is_confirmed target False
			val sender = Account.inc_nonce sender

			(*save state*)
			val tree = StateTree.upgrade tree storage [sender, target]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end;

	fun tx_set_storage tx tree storage =
		let
			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx

			(*validate that no meaning fields are not passed*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_to payload)

			(*fetch and validate tx sender*)
			val from = (TransactionPayload.get_from payload)
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account from version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed sender
			val _ = TxExecutionCheck.ensure_signatures sender tx
			val _ = TxExecutionCheck.ensure_nonce sender tx

			(*decode storage updates*)
			val (updates, _) = Serialization.decode_list 
									(Serialization.decode_tuple2 
										(Serialization.decode_string) 
                                        (Serialization.decode_byte_array_as_list)) 
                                    (Option.valOf (TransactionPayload.get_data payload))

            (*change state*)
            val _ = List.app (fn (key, value) => 
								if not (TxExecutionCheck.check_account_storage_key key) then
									raise StateComputerInvalidStorageKey
								else
									()
								) updates
            val sender = Account.update_storage sender updates
            val sender = Account.inc_nonce sender

            (*save state*)
            val tree = StateTree.upgrade tree storage [sender]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end

	fun tx_set_public_keys tx tree storage =
		let
			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx

			(*validate that no meaning fields are not passed*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_to payload)

			(*fetch and validate tx sender*)
			val from = (TransactionPayload.get_from payload)
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account from version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed sender
			val _ = TxExecutionCheck.ensure_signatures sender tx
			val _ = TxExecutionCheck.ensure_nonce sender tx

			(*decode storage updates*)
			val data = Option.valOf (TransactionPayload.get_data payload)
			val (pkeys, _) = Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) data
			val _ = TxExecutionCheck.ensure_not_empty pkeys
			val _ = TxExecutionCheck.ensure_valid_public_keys pkeys

            (*change state*)
            val sender = Account.set_public_keys sender (Set.from_list (ByteArray.compare) pkeys)
            val sender = Account.inc_nonce sender

            (*save state*)
            val tree = StateTree.upgrade tree storage [sender]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end

	fun tx_add_public_keys tx tree storage =
		let
			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx

			(*validate that no meaning fields are not passed*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_to payload)

			(*fetch and validate tx sender*)
			val from = (TransactionPayload.get_from payload)
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account from version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed sender
			val _ = TxExecutionCheck.ensure_signatures sender tx
			val _ = TxExecutionCheck.ensure_nonce sender tx

			(*decode storage updates*)
			val data = Option.valOf (TransactionPayload.get_data payload)
			val (pkeys, _) = Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) data
			val _ = TxExecutionCheck.ensure_not_empty pkeys
			val _ = TxExecutionCheck.ensure_valid_public_keys pkeys

            (*change state*)
            val sender = Account.add_public_keys sender pkeys
            val sender = Account.inc_nonce sender

            (*save state*)
            val tree = StateTree.upgrade tree storage [sender]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end

	fun tx_remove_public_keys tx tree storage =
		let
			val version = StateTree.get_version tree
			val payload = SignedTransaction.get_payload tx

			(*validate that no meaning fields are not passed*)
			val _ = TxExecutionCheck.ensure_none (TransactionPayload.get_to payload)

			(*fetch and validate tx sender*)
			val from = (TransactionPayload.get_from payload)
			val _ = TxExecutionCheck.ensure_valid_account_id from
			val (StateFetchResult sender tree) = TxExecutionCheck.fetch_existing_account from version tree storage
			val _ = TxExecutionCheck.ensure_account_confirmed sender
			val _ = TxExecutionCheck.ensure_signatures sender tx
			val _ = TxExecutionCheck.ensure_nonce sender tx

			(*decode storage updates*)
			val data = Option.valOf (TransactionPayload.get_data payload)
			val (pkeys, _) = Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) data
			val _ = TxExecutionCheck.ensure_not_empty pkeys
			val _ = TxExecutionCheck.ensure_valid_public_keys pkeys
			val _ = TxExecutionCheck.ensure_public_keys_exist_in_account sender pkeys

            (*change state*)
            val sender = Account.remove_public_keys sender pkeys
            val _ = TxExecutionCheck.ensure_not_empty (Set.to_list (Account.get_public_keys sender))
            val sender = Account.inc_nonce sender

            (*save state*)
            val tree = StateTree.upgrade tree storage [sender]
		in
			TxExecResult tree Success (TxExecutionUtil.create_info tx tree storage)
		end

	fun execute_transaction tx tree storage =
		(case (TransactionPayload.get_type (SignedTransaction.get_payload tx)) of
			0 => tx_create_contract tx tree storage
			| 1 => tx_contract_call tx tree storage
			| 2 => tx_create_user_account tx tree storage
			| 3 => tx_approve_user_account tx tree storage
			| 4 => tx_block_user_account tx tree storage
			| 5 => tx_set_storage tx tree storage
			| 6 => tx_set_public_keys tx tree storage
			| 7 => tx_add_public_keys tx tree storage
			| 8 => tx_remove_public_keys tx tree storage
			| _ => TxExecResult tree Failure (TxExecutionUtil.create_info tx tree storage))
		handle _ => TxExecResult tree Failure (TxExecutionUtil.create_info tx tree storage);
		
	fun execute_call account_id state_tree storage params = 
		let
			fun fun_name_toInt name = 
				case name of 
					  SCString "getAgreement" => Some 2
					| SCString "getPriceChangeWithNumber" => Some 6
					| SCString "getPriceChangesLength" => Some 7
					| SCString "getTask" => Some 12
					| n => None 

			val version = StateTree.get_version state_tree 

			val scValue_list = fst (Serialization.decode_list SCvalue.deserialize params)
		
			val function_name = List.hd scValue_list
			val function_number = fun_name_toInt function_name

			val params = List.tl scValue_list

			val guid_from = account_id
			val msg_sender = BigEndian.bytes_to_int guid_from
			val guid_to = account_id

			val (StateFetchResult contract tree) = TxExecutionCheck.fetch_existing_account guid_to version state_tree storage
			val contract_storage = Account.get_storage contract
			val storage_map = Map.fromList String.compare contract_storage
			val state = Map.lookup storage_map (Account.state_key())

			val blockNum = version

			val context = Context msg_sender blockNum (ByteArray.to_list (Option.valOf state))

			val result = if (Option.isSome function_number) 
				then ContractRuntime.call (Option.valOf function_number) context params
				else raise StateComputerInvalidFunctionName (Option.valOf (scvalue_to_string function_name))
		
		in
			if Option.isSome (get_ret_val result) then
				QueryResult.serialize (QuerySuccess (Option.valOf (get_ret_val result)))
			else
				QueryResult.serialize (QueryFailure (Option.valOf (get_err result)))
		end
end;

val _ = Exception.add_exn_name_printer
	(fn e =>
		case e of
            StateComputerInvalidContractOrParams _ _ => "StateComputerInvalidContractOrParams"
          | StateComputerInvalidFunctionName _ => "StateComputerInvalidFunctionName"
		  | StateComputerInvalidStorageKey => "StateComputerInvalidStorageKey"
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer 
	(fn e => 
		case e of 
            StateComputerInvalidContractOrParams v1 v2 => 
				(* TODO: add formatter for SCValue structure and use it in the handler *)
				"StateComputerInvalidContractOrParams" ^ " " ^ Formatter.option_to_string "" Int.toString v1
          | StateComputerInvalidFunctionName v1 => "StateComputerInvalidFunctionName" ^ " " ^ v1
		  | StateComputerInvalidStorageKey => "StateComputerInvalidStorageKey"
		  | _ => raise Exception.Unknown
	)
datatype state_computer = StateComputer block_info 
										hash_value
										((hash_value, state_computer_node) map) 
										((hash_value, computed_state) map);

datatype persistent_state_computer = PersistentStateComputer state_computer storage;
datatype persistent_state_compute_result = PersistentStateComputeResult state_computer storage state_compute_result;

exception StateComputerNoParent hash_value;
exception StateComputerNoSignedLedgerInfo;
exception StateComputerNoTree hash_value;

structure PersistentComputeResult = 
struct
	fun get_computer (PersistentStateComputeResult computer _ _) = computer;
	fun get_storage (PersistentStateComputeResult _ storage _) = storage;
	fun get_persisted_computer (PersistentStateComputeResult computer storage _) = PersistentStateComputer computer storage;
	fun get_result (PersistentStateComputeResult _ _ result) = result;
end;

structure StateComputerPrivate =
struct
	fun get_nodes (StateComputer _ _ nodes _) = nodes;
	fun set_nodes (StateComputer commit_info state_id _ states) nodes = StateComputer commit_info state_id nodes states

	fun insert_node state_computer node =
		let
			val nodes = get_nodes state_computer
			val block_id = Hashing.from_executed_block (StateComputerNode.get_block node)
		in
			set_nodes state_computer (Map.insert nodes block_id node)
		end;

	fun get_states (StateComputer _ _ _ states) = states;
	fun set_states (StateComputer commit_info state_id nodes _) states = StateComputer commit_info state_id nodes states

	fun insert_state state_computer state_id state =
		set_states state_computer (Map.insert (get_states state_computer) state_id state);

	fun get_commit_state_id (StateComputer _ state_id _ _) = state_id;

	fun get_commit_block_id (StateComputer commit_info _ _ _) = BlockInfo.get_id commit_info;

	fun get_commit_block_version (StateComputer commit_info _ _ _) = BlockInfo.get_version commit_info;

	fun get_state_id_and_version_by_block_id state_computer block_id =
		if ByteArray.equal block_id (get_commit_block_id state_computer) then
			Some (get_commit_state_id state_computer, get_commit_block_version state_computer)
		else
			case Map.lookup (get_nodes state_computer) block_id of
				Some node => Some (StateComputerNode.get_state_id node, StateComputerNode.get_version node)
				| None => None

	fun get_extending_state (StateComputer root root_state_id nodes states) block = 
		let
			fun get_state_with_key key parent_version =
				let
					val state = Option.valOf (Map.lookup states key)
				in
					if (StateTree.get_version (ComputedState.get_state_tree state)) = parent_version then
						(state, key)
					else
						let
							val new_state = ComputedState.reduce state parent_version
						in
							(new_state, (Hashing.from_block block))
						end
				end

			val parent_id = Block.get_parent_hash block
		in
			if ByteArray.equal parent_id (BlockInfo.get_id root) then
				get_state_with_key root_state_id (BlockInfo.get_version root)
			else
				case (Map.lookup nodes parent_id) of
					Some node => get_state_with_key (StateComputerNode.get_state_id node) (StateComputerNode.get_version node)
					| None => raise (StateComputerNoParent parent_id)
		end;

	fun get_account_by_state_id (PersistentStateComputer state_computer storage) account_id state_id version = 
		let
			fun get_account tree account_id version =
				let
					val (StateFetchResult account _) = StateTree.get_account tree storage account_id version
				in
					account
				end

			val states = get_states state_computer
		in
			Option.mapPartial
				(fn state => get_account (ComputedState.get_state_tree state) account_id version)
				(Map.lookup states state_id)
		end;

	fun execute_transactions (PersistentStateComputer state_computer storage) transactions state =
		let
			fun execute tx (TxExecResults tree statuses info_list) =
				let
					val (TxExecResult tree status info) = TxExecution.execute_transaction tx tree storage
				in
					TxExecResults tree (statuses @ [status]) (info_list @ [info])
				end

			fun create_result (TxExecResults tree statuses info_list) prev_accum next_accum =
				let
					val hashes = List.map (fn info => Hashing.from_tx_info info) info_list
					val root = TxExecutionCheck.fetch_accum_root_or_raise next_accum
					val current_version = StateTree.get_version tree
					val parent_version = TxAccumulator.get_tr_number prev_accum
				in
					StateComputeResult root current_version parent_version statuses hashes
				end;

			fun update_accum accum statuses info_list =
				let
					val success_info_list = TxExecutionUtil.get_success_info_list info_list statuses
				in
					if List.null success_info_list then
						accum
					else
						TxAccumulator.recalculate_merkle_tree (TxAccumulator.insert_transactions accum success_info_list)
				end;

			val init = TxExecResults (ComputedState.get_state_tree state) [] []
			val exec_results = (List.foldl 
								(fn execution_state => (fn tx => (execute tx execution_state))) 
								init 
								transactions)
			val tx_accum = (ComputedState.get_tx_accum state)
			val next_accum = update_accum tx_accum (TxExecResults.get_statuses exec_results) (TxExecResults.get_info_list exec_results)
			val result = create_result exec_results tx_accum next_accum
			val new_state = ComputedState (TxExecResults.get_tree exec_results) next_accum
 		in
			(state_computer, storage, new_state, result)
		end;

	fun execute_not_existing_block (PersistentStateComputer state_computer storage) block =
		let
			val (state, state_id) = get_extending_state state_computer block
			val transactions = Block.get_transactions block
			val (state_computer, storage, next_state, result) = execute_transactions 
																	(PersistentStateComputer state_computer storage)
																	transactions 
																	state
			val node = StateComputerNode (ExecutedBlock block result) state_id
			val state_computer = insert_node state_computer node
			val state_computer = insert_state state_computer state_id next_state
		in
			PersistentStateComputeResult state_computer storage result
		end;

	fun move_to_commit state_computer new_commit_info new_commit_key state = 
		let
			fun is_reachable_from_root root_id block nodes =
				let
					val block_id = (ExecutedBlock.get_parent_hash block)
				in
					if (ByteArray.equal block_id root_id) then
						True
					else
						case Map.lookup nodes block_id of
							Some (StateComputerNode next_block _) => is_reachable_from_root root_id next_block nodes
							| None => False
				end;

			fun filter_block root_id block nodes =
				let
					val block_id = Hashing.from_executed_block block
				in
					(not (ByteArray.equal block_id root_id)) andalso
					is_reachable_from_root root_id block nodes
				end;

			fun insert_root_state_if_needed states =
				if not (Option.isSome (Map.lookup states new_commit_key)) then
					Map.insert states new_commit_key state
				else
					states

			fun filter_state state_id node_list =
				Option.isSome (List.find (fn (_, StateComputerNode _ id) => (ByteArray.equal state_id id)) node_list)

			val root_id = BlockInfo.get_id new_commit_info
			val nodes = get_nodes state_computer
			val states = get_states state_computer

			val new_node_list = List.filter 
									(fn (_, (StateComputerNode block _)) => filter_block root_id block nodes) 
									(Map.toAscList nodes)
			val new_states = insert_root_state_if_needed
								(Map.fromList 
									(ByteArray.compare) 	
									(List.filter
										(fn (state_id, _) => filter_state state_id new_node_list) 
										(Map.toAscList states)))
			val new_nodes = Map.fromList (ByteArray.compare) new_node_list
		in
			(StateComputer new_commit_info new_commit_key new_nodes new_states)
		end;

	fun persist_txs storage txs li_index version =
		let
			fun save_tx (version, storage) tx =
				let
					val storage = TransactionWriter.write_tx_version storage tx version
					val storage = TransactionWriter.write_tx storage version tx li_index
				in
					(version + 1, storage)
				end;

			val (_, storage) = List.foldl save_tx (version + 1, storage) txs
		in
			TransactionWriter.write_tx_count storage (version + (List.length txs))
		end;

	fun persist_li storage signed_ledger_info li_count =
		TransactionWriter.write_li_count 
			(TransactionWriter.write_li storage li_count signed_ledger_info) 
			(li_count + 1);

	fun persist_li_and_txs storage txs signed_ledger_info version =
		let
			val li_count = Option.getOpt (TransactionReader.read_li_count storage) 0
			val storage = persist_txs storage txs li_count version
			val storage = persist_li storage signed_ledger_info li_count
		in
			storage
		end

	fun persist_state storage state from_version =
		let
			val tree = ComputedState.get_state_tree state
			val accum = ComputedState.get_tx_accum state
			val cur_version = StateTree.get_version tree
			val storage = StateTreeWriter.write_tree storage tree from_version cur_version
			val storage = AccumulatorWriter.write_accumulator storage accum
		in
			storage
		end

	fun persist_commited_state (PersistentStateComputer state_computer storage) txs signed_ledger_info state = 
		let
			val version = TransactionReader.read_tx_count storage
			val cur_version = Option.getOpt version 0
			val storage = persist_li_and_txs storage txs signed_ledger_info cur_version
			val start_state_version = (Option.getOpt version ~1) + 1
			val storage = persist_state storage state start_state_version
		in
			(PersistentStateComputer state_computer storage)
		end

	fun read_computer storage =
		let
			fun read_accum_or_default version storage =
				if version > 0 then
					AccumulatorReader.read_full_accumulator storage
				else
					TxAccumulator.recalculate_merkle_tree (TxAccumulator.init ());

			val version = TxExecutionCheck.read_version_or_raise storage
			val ledger_info = TxExecutionCheck.read_last_li_or_raise storage
			val block_info = SignedLedgerInfo.get_commit_info ledger_info
			val block_id = BlockInfo.get_id block_info
			val tree = StateTree.preload storage version
			val tx_accum = read_accum_or_default version storage
			val states = Map.insert (Map.empty (ByteArray.compare)) block_id (ComputedState tree tx_accum)
			val computer = StateComputer block_info block_id (Map.empty (ByteArray.compare)) states
		in
			PersistentStateComputer computer storage
		end;

	fun create_computer_from_genesis storage genesis =
		let
			val accounts = TxExecutionCheck.fetch_accounts_from_block_or_raise genesis
			val state_tree = StateTree.init_accounts storage accounts
			val tx_accum = TxAccumulator.recalculate_merkle_tree (TxAccumulator.init ())
			val block_id = Hashing.from_block genesis
			val version =  StateTree.get_version state_tree
			val (StateFetchResult root_hash _) = StateTree.root_hash state_tree storage version
			val info = BlockInfo (Block.get_round genesis) block_id root_hash version (Block.get_timestamp genesis)
			val states = Map.insert (Map.empty (ByteArray.compare)) block_id (ComputedState state_tree tx_accum)
			val computer = StateComputer info block_id (Map.empty (ByteArray.compare)) states
		in
			PersistentStateComputer computer storage
		end;

	fun execute_above_commit (PersistentStateComputer state_computer storage) block =
		let
			val commit_block_id = get_commit_block_id state_computer
			val commit_state_id = get_commit_state_id state_computer
			val commit_version = get_commit_block_version state_computer
			val nodes = get_nodes state_computer
			val states = get_states state_computer

			(*fetch last commited state*)
			val (state_id, state) = TxExecutionCheck.fetch_state_or_raise 
												commit_block_id commit_version
												commit_block_id commit_state_id commit_version
												nodes states
			in
				if Block.is_genesis block then
					let
						val accounts = TxExecutionCheck.fetch_accounts_from_block_or_raise block
						val state_tree = StateTree.init_accounts storage accounts
						val genesis_version = StateTree.get_version state_tree
						val (StateFetchResult state_id _) = StateTree.root_hash state_tree storage genesis_version
					in
						StateComputeResult.create_from_genesis state_id genesis_version
					end
				else
					let
						val parent_version = Block.get_parent_version block
						val parent_state_id = Block.get_parent_state_id block

						val exec_state = if parent_version < commit_version then
											ComputedState.reduce state parent_version
										else if parent_version = commit_version then
												state
											else
												raise StateComputerUnexpectedVersion parent_version;

						val transactions = Block.get_transactions block

						val (state_computer, storage, new_state, result) = execute_transactions 
																		(PersistentStateComputer state_computer storage) 
																		transactions 
																		exec_state
					in
						result
					end
			end		

end;

structure StateComputer = 
struct
	fun commit_round (StateComputer commit_info _ _ _) = BlockInfo.get_round commit_info;

	(**
	 *	Fetches the hash of the latest committed block.
	 *
	 *	@param ```state_computer``` state computer to query.
	 *	
	 *	@return ```hash_value```.
	 *)
	fun commit_block_id (StateComputer commit_info _ _ _) = BlockInfo.get_id commit_info;

	(**
	 *	Fetches current version or total number of the committed transactions.
	 *
	 *	@param ```state_computer``` state computer to query.
	 *	
	 *	@return ```Int```.
	 *)
	fun commit_block_version (StateComputer commit_info _ _ _) = BlockInfo.get_version commit_info;

	(**
	 *	Extracts Merkle hash of the state: for genesis block it is the Merkle hash of the state tree
	 *	and for the following commits it the Merkle hash of the transaction accumulator.
	 *)
	fun commit_state_id (StateComputer commit_info _ _ _) = BlockInfo.get_executed_state_id commit_info
end;

structure PersistentStateComputer = 
struct
	(**
	 *	Fetches state computer.
	 *
	 *	@param ```persisted_state_computer``` persisted state computer to query.
	 *
	 *	@return ```state_computer```.
	 *)
	fun get_computer (PersistentStateComputer computer _) = computer;

	(**
	 *	Fetches storage.
	 *
	 *	@param ```persisted_state_computer``` persisted state computer to query.
	 *
	 *	@return ```storage```.
	 *)
	fun get_storage (PersistentStateComputer _ storage) = storage;

	(** 
	 *	Creates new state computer that either load last commit from the storage
	 *	or starts from scratch using genesis block.
	 *
	 *	@param ```storage``` Storage that allows to load commited transactions and state
	 *		from the database.
	 *	@param ```genesis``` Genesis block specifies initial state by providing list
	 *		of initial accounts.
	 *
	 *	@return newly created ```persisted_state_computer```.
	 *
	 *	@note If state computer starts from genesis block then the initial
	 *		version will be 0, state will contain account from the genesis block
	 *		and transaction accumulator will be empty (since there were no
	 * 		transactions applied yet).
	 *
	 *	@raises ```StateComputerUnexpectedVersion``` in case of inconsistent number of transactions found in storage.
	 *	@raises ```StateComputerUnexpectedLedgerInfo``` if last ledger info is missing or invalid. 
	 *	@raises ```StateComputerUnexpectedGenesisAccounts``` if initial account can't be fetched from the genesis
	 *)
	fun create storage genesis =
		let
			val li_count = Option.getOpt (TransactionReader.read_li_count storage) 0
		in
			if li_count > 0 then
				StateComputerPrivate.read_computer storage
			else
				StateComputerPrivate.create_computer_from_genesis storage genesis
		end;

	(**
	 *	Tries to execute transactions from the block and extend of of the existing chains
	 *	providing new state. Can execute new blocks and return result for previously 
	 *	executed pending or commited blocks.
	 *
	 *	@param ```persisted_state_computer``` computer which is in charge to execute the block.
	 *	@param ```block`` block to be executed.
	 *
	 *	@return ```persistent_state_compute_result``` containing updated persisted state computer
	 *		together with execution result.
	 *
	 *	@raises ```StateComputerNoParent``` in case provided block doesn't extend any existing chain.
	 *	@raises ```StateComputerMissingAccumRoot``` when root of the transaction accumulator can't be calculated.
	 *)
	fun execute_block (PersistentStateComputer state_computer storage) block =
		if ByteArray.equal (Hashing.from_block block) (StateComputer.commit_block_id state_computer) then
			let
				val result = StateComputerPrivate.execute_above_commit (PersistentStateComputer state_computer storage) block
			in
				PersistentStateComputeResult state_computer storage result
			end
		else
			let
				val opt_result = Option.map 
					(fn node => (PersistentStateComputeResult state_computer storage (StateComputerNode.get_result node)))
					(Map.lookup (StateComputerPrivate.get_nodes state_computer) (Hashing.from_block block))
			in
				case opt_result of
					Some result => result
					| None => StateComputerPrivate.execute_not_existing_block (PersistentStateComputer state_computer storage) block
			end
	(**
	 *	Tries to commit blocks by updating state and list of persisted transactions with proofs. Note
	 *	that new commit round must be greater than current commit round otherwise function does nothing.
	 *
	 *	Verification of the commit correctness consists of the following checks:
	 *	1) List of blocks is not empty;
	 *	2) Each block from the list was executed previously;
	 *	3) List of blocks correponds to the valid chain starting from root in the block tree;
	 *	4) Consensus signatures from ledger info are valid and correspond to existing accounts
	 *		from the state in latest commit block.
	 *	
	 *	@param ```persisted_state_computer``` computer which is in charge to commit blocks.
	 *	@param ```executed_block list``` list of executed blocks to commit.
	 *	@param ```signed_ledger_info``` proof that the blocks were correctly proccessed by consensus protocol.
	 *
	 *	@return ```persistent_state_computer``` updated state computer.
	 *
	 *	@raises ```StateComputerExpectedNotEmptyList``` in case empty block list is provided.
	 *	@raises ```StateComputerBlockNotExists``` in case any of the blocks wasn't executed before commit.
	 *	@raises ```StateComputerInvalidCommitChain``` in case blocks are not consequtive starting right after the last
	 *		commited block.
	 *	@raises ```StateComputerSignaturesInvalid``` in case there is an invalid signature in the signed_ledger_info.
	 *	@raises ```StateComputerNoAccount``` in case there is no account found in the last committed state corresponding
	 *		to account id in the signed ledger info.
	 *	@raises ```StateComputerMissingNode``` in case internal error occured while resolving state to persist for the commit.
	 *	@raises ```StateComputerMissingState``` in case state tree coresponding to the commit info from signed ledger
	 *		can't be retrieved.
	 *	@raises ```StateComputerAccumMismatch``` in case state id in the ledger info doesn't match one stored in the
	 *		state computer.
	 *
	 *)
	fun commit (PersistentStateComputer state_computer storage) blocks signed_ledger_info =
		let
			val current_round = StateComputer.commit_round state_computer
		 	val new_round = BlockInfo.get_round (SignedLedgerInfo.get_commit_info signed_ledger_info)
		in
			if new_round > current_round then
				let
					(*data needed for validation*)
					val commit_block_id = StateComputerPrivate.get_commit_block_id state_computer
					val commit_state_id = StateComputerPrivate.get_commit_state_id state_computer
					val commit_version = StateComputer.commit_block_version state_computer
					val nodes = StateComputerPrivate.get_nodes state_computer
					val states = StateComputerPrivate.get_states state_computer
					
					(*performing validation*)
					val _ = TxExecutionCheck.ensure_not_empty blocks
					val _ = TxExecutionCheck.ensure_blocks_exist commit_block_id nodes blocks
					val _ = TxExecutionCheck.ensure_valid_chain_from_root commit_block_id blocks
					val _ = TxExecutionCheck.ensure_valid_ledger_info commit_state_id commit_version states storage signed_ledger_info
					
					(*fetching state to save*)
					val new_commit_block_id = SignedLedgerInfo.get_commit_id signed_ledger_info
					val new_commit_info = SignedLedgerInfo.get_commit_info signed_ledger_info
					val new_commit_block_version = BlockInfo.get_version new_commit_info
					val (state_id, state) = TxExecutionCheck.fetch_state_or_raise 
														new_commit_block_id new_commit_block_version 
														commit_block_id commit_state_id commit_version
														nodes states
					val transactions = TxExecutionUtil.get_success_txs blocks

					(*validate final state before saving*)
					val _ = TxExecutionCheck.ensure_final_state state signed_ledger_info
					
					(*persisting new transactns, proof and state*)
					val (PersistentStateComputer state_computer storage) = StateComputerPrivate.persist_commited_state 
																				(PersistentStateComputer state_computer storage) 
																				transactions 
																				signed_ledger_info
																				state

					(*updating in memory state by removing not needed alternative states*)
					val state_computer = StateComputerPrivate.move_to_commit state_computer new_commit_info state_id state
				in
					(PersistentStateComputer state_computer storage)
				end
			else
		 		(PersistentStateComputer state_computer storage)
		end;

	(**
	 *	Tries to execute and persist a list of transaction verifying the consensus proof first. Note
	 *	that new commit round must be greater than current commit round otherwise function does nothing.
	 *
	 *	Verification of the commit correctness consists of the following checks:
	 *	1) Consensus signatures from ledger info are valid and correspond to existing accounts
	 *		from the state in the latest commit block.
	 *	2) State id after applying transactions to the latest commit block is the same as
	 *		in signed ledger info.
	 *
	 *	@param ```persisted_state_computer``` computer which is in charge to commit transactions;
	 *	@param ```transactions``` list of transactions to commit;
	 *	@param ```signed_ledger_info``` proof of transactions acceptance in consensus protocol;
	 *	
	 *	@return ```persistent_state_computer``` updated state computer.
	 *)
	fun commit_transactions (PersistentStateComputer state_computer storage) transactions signed_ledger_info =
		let
		 	val current_round = StateComputer.commit_round state_computer
		 	val new_round = BlockInfo.get_round (SignedLedgerInfo.get_commit_info signed_ledger_info)
		in
		 	if new_round > current_round then
		 		let
					(*data needed for validation*)
					val commit_block_id = StateComputerPrivate.get_commit_block_id state_computer
					val commit_state_id = StateComputerPrivate.get_commit_state_id state_computer
					val commit_version = StateComputer.commit_block_version state_computer
					val nodes = StateComputerPrivate.get_nodes state_computer
					val states = StateComputerPrivate.get_states state_computer

					(*performing validation*)
					val _ = TxExecutionCheck.ensure_valid_ledger_info commit_state_id commit_version states storage signed_ledger_info

					(*execute transactions*)
					val (state_id, state) = TxExecutionCheck.fetch_state_or_raise 
														commit_block_id commit_version
														commit_block_id commit_state_id commit_version
														nodes states
					val (state_computer, storage, new_state, result) = StateComputerPrivate.execute_transactions 
																			(PersistentStateComputer state_computer storage) 
																			transactions 
																			state

					(*validate final state before saving*)
					val _ = TxExecutionCheck.ensure_final_state new_state signed_ledger_info;

					(*persisting new transactns, proof and state*)
					val (PersistentStateComputer state_computer storage) = StateComputerPrivate.persist_commited_state 
																				(PersistentStateComputer state_computer storage) 
																				transactions 
																				signed_ledger_info
																				new_state

					(*updating in memory state by removing not needed alternative states*)
					val new_commit_info = SignedLedgerInfo.get_commit_info signed_ledger_info
					val state_computer = StateComputerPrivate.move_to_commit state_computer new_commit_info state_id new_state
				in
					(PersistentStateComputer state_computer storage)
				end
		 	else
		 		(PersistentStateComputer state_computer storage)
		end 
		

	fun get_account_by_block_id (PersistentStateComputer state_computer storage) account_id block_id =
		if ByteArray.equal (StateComputerPrivate.get_commit_block_id state_computer) block_id then
			let
				val state_id = StateComputerPrivate.get_commit_state_id state_computer
				val version = StateComputer.commit_block_version state_computer
			in
				StateComputerPrivate.get_account_by_state_id 
					(PersistentStateComputer state_computer storage) 
					account_id 
					state_id
					version
			end
		else
			case Map.lookup (StateComputerPrivate.get_nodes state_computer) block_id of
				Some node => StateComputerPrivate.get_account_by_state_id 
								(PersistentStateComputer state_computer storage) 
								account_id 
								(StateComputerNode.get_state_id node)
								(StateComputerNode.get_version node)
				| None => None

	fun get_account (PersistentStateComputer state_computer storage) account_id =
		get_account_by_block_id (PersistentStateComputer state_computer storage) account_id (StateComputerPrivate.get_commit_block_id state_computer)

	(**
	 *	Obtains transactions and corresponding signed_ledger_info from persistent_state_computer from (version + 1) 
	 *	to version where li_index changes.
	 *
	 *	@param ```persistent_state_computer``` computer which contains transactions.
	 *	@param ```version``` version of transactions which are wanted to get from storage.
	 *
	 *	@raises ```StateComputerNoSignedLedgerInfo``` when transaction of (version + 1) isn't None, but
	 *	corresponding signed_ledger_info doesn't exist. 
	 *
	 *	@return ```(signed_transaction list, signed_ledger_info)``` list of transactions and
	 *	signed_ledger_info from db or ```None``` if there are no transactions.
	 *)
	fun get_transactions (PersistentStateComputer state_computer storage) version =
		let
			val tuple = TransactionReader.read_tx storage (version + 1)
		in
			if Option.isNone tuple then
				None
			else
				let
					val (tx, li_index) = Option.valOf tuple
					val signed_ledger_info = TransactionReader.read_li storage li_index
					val initial_tx_list = [tx]
					
					fun get_txs tx_list new_version =
						let
							val new_tuple = TransactionReader.read_tx storage (new_version + 1)
							val result = Option.map (fn (new_tx, new_li_index) => if li_index = new_li_index then
													     	get_txs (new_tx :: tx_list) (new_version + 1)
													     else
													     	tx_list) new_tuple
						in
							if Option.isNone result then
								tx_list
							else
								Option.valOf result
						end
				in
					if Option.isNone signed_ledger_info then
						raise StateComputerNoSignedLedgerInfo
					else
						Some (List.rev (get_txs initial_tx_list (version + 1)), (Option.valOf signed_ledger_info))
				end	
		end;

	(**
	 *	Fetches signed ledger info for given ledger index.
	 *
	 *	@param ```persistent_state_computer``` computer which contains transactions.
	 *	@param ```li_index``` ledger index to search info by.
	 *
	 *	@return ```signed_ledger_info``` if found or ```None``` otherwise.
	 *)
	fun get_commit_proof (PersistentStateComputer state_computer storage) li_index =
		TransactionReader.read_li storage li_index

	(**
	 *	Fetches commits count.
	 *
	 *	@param ```persistent_state_computer``` computer which contains transactions.
	 *
	 *	@return ```int``` if there any commit and ```None``` otherwise.
	 *)
	fun get_commits_count (PersistentStateComputer state_computer storage) =
		TransactionReader.read_li_count storage


	fun query_contract (PersistentStateComputer state_computer storage) account_id block_id params =
		(let
			fun fetch_state states state_id =
				case Map.lookup states state_id of
					Some state => state
					| None => raise StateComputerMissingState state_id

			fun fetch_state_id () =
				let
					val target_block_id = Option.getOpt block_id (StateComputer.commit_block_id state_computer)
	  				val opt_state_info = StateComputerPrivate.get_state_id_and_version_by_block_id state_computer target_block_id
				in
					case opt_state_info of
						Some (state_id, version) => (state_id, version)
						| None => raise StateComputerNoTree target_block_id
				end	

			val (state_id, version) = fetch_state_id ()
			
			val states = StateComputerPrivate.get_states state_computer 
			val state = fetch_state states state_id
			val state_tree = StateTree.reduce (ComputedState.get_state_tree state) version
		in
			TxExecution.execute_call account_id state_tree storage params
		end)
		handle StateComputerMissingState _ => QueryResult.serialize (QueryFailure "StateComputer state missing")
			 | StateComputerNoTree _ => QueryResult.serialize (QueryFailure "StateComputer does not have such a tree")
			 | StateComputerNoAccount _ =>  QueryResult.serialize (QueryFailure "StateComputer does not have such account")
			 | StateComputerInvalidFunctionName name =>  QueryResult.serialize (QueryFailure ("Wrong function name: "^name))
			 | _ =>  QueryResult.serialize (QueryFailure "Unknown exception") ;	
end;

val _ = 
    Exception.add_exn_name_printer 
        (fn e => 
            case e of 
              StateComputerNoParent _ => "StateComputerNoParent"
			  | StateComputerNoSignedLedgerInfo => "StateComputerNoSignedLedgerInfo"
			  | StateComputerNoTree _ => "StateComputerNoTree"
              | _ => raise Exception.Unknown
        )
val _ = 
    Exception.add_exn_message_printer
        (fn e =>
            case e of
              StateComputerNoParent v1 => "StateComputerNoParent" ^ " " ^ Hex.bytes_to_hex v1
			  | StateComputerNoSignedLedgerInfo => "StateComputerNoSignedLedgerInfo"
			  | StateComputerNoTree v1 => "StateComputerNoTree" ^ " " ^ Hex.bytes_to_hex v1
              | _ => raise Exception.Unknown
        )
(**
 *	Type represents a node in the block tree.
 *	
 *	@param executed_block: ```executed_block``` Executed block storing in the node.
 *	@param children: ```hash_value list``` List of hashes of the blocks corresponding 
 *	to child nodes in the block tree.
 *)
datatype linkable_block = LinkableBlock executed_block (hash_value set) ;

(**
 *	Type represents in memory storage for pending executed blocks and dependencies between them.
 *
 *	@param root: ```hash_value``` Hash value of the block which is stored in the root node of the block tree.
 *	@param nodes: ```(hash_value, linkable_block) map``` Map between hashes and nodes that store corresponding blocks. 
 *)
datatype block_tree = BlockTree hash_value ((hash_value, linkable_block) map);

(**
 *	Exception that is raised when there is an attempt to insert block with existing hash
 *	into the block tree.
 *
 *	@param hash: ```hash_value``` Duplicated hash value.
 *)
exception BlockTreeBlockAlreadyExists hash_value;

(**
 *	Exception that is raised when a node is missing in the block tree.
 *
 *	@param hash: ```hash_value``` Hash value of the block which is missing.
 *)
exception BlockTreeNodeMissing hash_value;

(**
 *	Exception that is raised when a parent node is missing, for example, when
 *	a new block is being inserted into the block tree.
 *
 *	@param hash: ```hash_value``` Hash value of the block for which a parent can't be found.
 *)
exception BlockTreeParentBlockMissing hash_value;


structure LinkableBlock =
struct    

    fun init() = LinkableBlock (ExecutedBlock.init()) (Set.empty (ByteArray.compare));
    fun create(block, children) = LinkableBlock block children;

    (*TODO rewrite comparation*)
    fun compare value1 value2 = Greater;

    fun get_block (LinkableBlock block _) = block

    fun get_child_hashes (LinkableBlock _ hashes) = hashes
    
    fun serialize (LinkableBlock executed_block hash_value) =
    	ByteArray.from_list(
			    ByteArray.to_list(ExecutedBlock.serialize executed_block) @
			    ByteArray.to_list(Serialization.encode_set Serialization.encode_byte_array hash_value)
			)

    fun deserialize bytes =
    	let
    		val (executed_block, executed_block_len) = ExecutedBlock.deserialize bytes
		val (hash_value, hash_value_len) = Serialization.decode_set (Serialization.decode_byte_array (HashFunction.size())) (ByteArray.compare) (ByteArray.suffix bytes executed_block_len)
    	in
    		(LinkableBlock executed_block hash_value, executed_block_len + hash_value_len)
    	end;   
end;

(**
 *	The structrure defines helper functions for internal usage to process block tree.
 *	For public interface consider ```BlockTree``` structure.
 *)
structure BlockTreePrivate = 
struct
	fun get_mapping (BlockTree _ mapping) = mapping

	fun append_child optionalBlock child = 
		case optionalBlock of
			Some (LinkableBlock block set) => LinkableBlock block (Set.add set child)
			| None => raise BlockTreeParentBlockMissing child;

	fun build_path_for_node tree h1 h2 =
		if (ByteArray.equal h1 h2) then Some (h1 :: [])
		else
			case Map.lookup tree h1 of
				Some (LinkableBlock _ (Set comparator children)) => (Option.map (fn path => h1 :: path) (build_path_for_children tree children h2))
				| None => raise BlockTreeNodeMissing h1

	and build_path_for_children tree children h = 
		case children of
			[] => None
			| x::xs => let 
							val option_path = build_path_for_node tree x h
						in
							case option_path of
								Some path => Some path
								| None => (build_path_for_children tree xs h)
						end;

	fun build_tree new_tree old_tree items =
		case items of
			[] => new_tree
			| x::xs => let
							val node = Map.lookup old_tree x
						in
							case node of
								Some (LinkableBlock block (Set comparator children)) => build_tree (Map.insert new_tree x (LinkableBlock block (Set comparator children))) old_tree (xs @ children)
								| None => raise BlockTreeNodeMissing x
						end;
end;

(**
 *	Structure defines public functions to query or modify in block tree.
 *)
structure BlockTree = 
struct

	(**
	 *	Creates block tree from a single root block.
	 *
	 *	@param block: ```executed_block``` Block to make root.
	 *	@return ```block_treee``` New block tree.
	 *)
	fun from_single block = 	
		let 
			val root_hash = Hashing.from_executed_block block
			val nodes = Map.insert 
							(Map.empty ByteArray.compare) 
							root_hash
							(LinkableBlock block (Set.empty(ByteArray.compare)))
		in
			BlockTree root_hash nodes
		end;

	(**
	 *	Queries hash of the block corresponding to the root node.
	 *	
	 *	@param block_tree: ```block_tree``` Block tree to query.
	 *
	 *	@return ```hash_value```.
	 *)
	fun get_root_id (BlockTree root_id _) = root_id;

	(**
	 *	Inserts executed block into the block tree.
	 *
	 *	@param block_tree: ```block_tree``` Block tree to modify.
	 *	@param block: ```executed_block``` Executed block that is being inserted.
	 *
	 *	@return ```block_tree``` Modified block tree.
	 *
	 *	@raises ```BlockTreeBlockAlreadyExists``` if a block with the same hash already exists.
	 *	@raises ```BlockTreeParentBlockMissing``` if the parent block is missing.
	 *)
	fun insert_block (BlockTree root_id tree) block =
		let
			val block_hash = Hashing.from_executed_block block
			val parent_hash = ExecutedBlock.get_parent_hash block
		in
			if Option.isSome (Map.lookup tree block_hash) then
				raise BlockTreeBlockAlreadyExists block_hash
			else
				BlockTree root_id (
					Map.insert (
						Map.insert 
							tree 
							parent_hash 
							(BlockTreePrivate.append_child (Map.lookup tree parent_hash) block_hash)
					) 
					block_hash 
					(LinkableBlock block (Set.empty(ByteArray.compare)))
				)
		end;

	(**
	 *	Queries block from the block tree by hash.
	 *
	 *	@param block_tree: ```block_tree``` Block tree to query.
	 *	@param hash: ```hash_value``` Hash of the block to return.
	 *
	 *	@return ```executed_block option``` Executed block in case it was found and None otherwise.
	 *)
	fun get_block (BlockTree _ tree) hash = 
		Option.map (fn (LinkableBlock executed_block _) => executed_block)
		 (Map.lookup tree hash);		

	(**
	 *	Queries a path which is a list of all blocks between two defined by input hashes.
	 *
	 *	@param block_tree: ```block_tree``` Block tree to query.
	 *	@param hash1: ```hash_value``` Hash of the first block in the path.
	 *	@param hash2: ```hash_value``` Hash of the last block in the path.
	 *
	 *	@return ```executed_block list option``` List of blocks if the path is found and None otherwise.
	 *)
	fun get_blocks_from_path (BlockTree root_id tree) hash1 hash2 = 
		Option.map
			(fn hash_list => 
				List.map 
					(fn hash => Option.valOf (get_block (BlockTree root_id tree) hash)) 
					hash_list
			)
			(BlockTreePrivate.build_path_for_node tree hash1 hash2);

	(**
	 *	Queries a path which is a list of all blocks between two defined 
	 *	by a parent hash of the first block and hash of the last block.
	 *
	 *	@param block_tree: ```block_tree``` Block tree to query.
	 *	@param opt_parent_hash: ```hash_value``` Optional hash of the parent of the first block in the path. Pass None
	 *	to start from the root.
	 *	@param waypoint_hash: ```hash_value``` Hash of the last block in the path.
	 *
	 *	@return ```executed_block list option``` List of blocks if the path is found and None otherwise.
	 *)
	fun get_sync_blocks tree opt_parent_hash waypoint_hash =
		let
			fun first_path_from_hashes tree hashes waypoint_hash =
				if List.null hashes then
					None
				else
					case get_blocks_from_path tree (List.hd hashes) waypoint_hash of
						Some path => Some path
						| None => first_path_from_hashes tree (List.tl hashes) waypoint_hash
			
			fun get_from_root_block tree waypoint_hash =
				let
					val root_id = get_root_id tree
				in
					first_path_from_hashes tree [root_id] waypoint_hash
				end

			fun get_from_root_parent tree parent_hash waypoint_hash =
				let
					val root_id = get_root_id tree
					val maybe_root = get_block tree root_id
				in
					case maybe_root of
						Some executed_block => 
							if ByteArray.equal parent_hash (ExecutedBlock.get_parent_hash executed_block) then
								first_path_from_hashes tree [root_id] waypoint_hash
							else
								None
						| None => raise (BlockTreeNodeMissing root_id)
				end

			fun get_sync_blocks_with_parent_hash tree parent_hash waypoint_hash =
				let
					val maybe_hashes = Option.map (fn (LinkableBlock _ hashes) => hashes) (Map.lookup (BlockTreePrivate.get_mapping tree) parent_hash)
				in
					case maybe_hashes of
						Some hashes => first_path_from_hashes tree (Set.to_list hashes) waypoint_hash
						| None => get_from_root_parent tree parent_hash waypoint_hash
				end				
		in
			case opt_parent_hash of
				Some parent_hash => get_sync_blocks_with_parent_hash tree parent_hash waypoint_hash
				| None => get_from_root_block tree waypoint_hash	
		end

	(**
	 *	Replaces root of the block tree and removes all nodes which are not reachable from the new root.
	 *
	 *	@param block_tree: ```block_tree``` Block tree to modify.
	 *	@param new_root_id: ```hash_value``` Hash of the block which is stored in the new root node.
	 *
	 *	@return ```block_tree``` Modified block tree.
	 *
	 *	@raises ```BlockTreeNodeMissing``` if there is no node corresponding to the new root hash.
	 *)
	fun prune (BlockTree root_id tree) new_root_id = 
		BlockTree new_root_id (BlockTreePrivate.build_tree (Map.empty ByteArray.compare) tree [new_root_id]);

    fun print_block_tree (BlockTree root_id tree) =
        (
            print "Block tree:\nID:";
			print (Hex.bytes_to_hex root_id)
        );

    (**
     *	Converts tree of block to string representation for logging.
     *
     *	@param block_tree: ```block_tree``` Block tree to convert.
     *
     *	@return ```String``` representing the tree.
     *)
    fun to_string (BlockTree root_id tree) =
		let
			fun append tree node_hash result prefix =
				let
					val new_result = result ^ prefix ^ (Hex.bytes_to_hex node_hash) ^ "\n"
				in
					Option.getOpt (
						Option.map (
							fn (LinkableBlock _ children_set) => 
								List.foldl (fn result => fn child_hash => append tree child_hash new_result (prefix ^ " ")) new_result (Set.to_list children_set)
						) 
						(Map.lookup tree node_hash)
					) new_result
				end
		in
			append tree root_id "" ""
		end
    
    fun serialize (BlockTree root_id tree) =
    	   ByteArray.from_list(
			    ByteArray.to_list(root_id) @
			    ByteArray.to_list(Serialization.encode_list (Serialization.encode_tuple2 Serialization.encode_byte_array LinkableBlock.serialize) (Map.toAscList tree))
			)
    
    fun deserialize bytes =
    	let 
    		val (root_id, root_id_len) = Serialization.decode_byte_array (HashFunction.size()) bytes
		val (tree_list, tree_len) = Serialization.decode_list
							 (Serialization.decode_tuple2 (Serialization.decode_byte_array (HashFunction.size()))
							 (LinkableBlock.deserialize))
							 (ByteArray.suffix bytes root_id_len)
		val tree = Map.fromList ByteArray.compare tree_list 
    	in
    		(BlockTree root_id tree, root_id_len + tree_len)
    	end;
end;


val _ = 
    Exception.add_exn_name_printer 
        (fn e => 
            case e of 
                BlockTreeBlockAlreadyExists _ => "BlockTreeBlockAlreadyExists"
              | BlockTreeNodeMissing _ => "BlockTreeNodeMissing"
			  | BlockTreeParentBlockMissing _ => "BlockTreeParentBlockMissing"
              | _ => raise Exception.Unknown
        )
val _ = 
    Exception.add_exn_message_printer
        (fn e =>
            case e of
                BlockTreeBlockAlreadyExists v1 => 
					"BlockTreeBlockAlreadyExists" ^ " " ^ Hex.bytes_to_hex v1
              | BlockTreeNodeMissing v1 => 
			  		"BlockTreeNodeMissing" ^ " " ^ Hex.bytes_to_hex v1
			  | BlockTreeParentBlockMissing v1 => 
			  		"BlockTreeParentBlockMissing" ^ " " ^ Hex.bytes_to_hex v1
              | _ => raise Exception.Unknown
        )
datatype block_store_db_info = BlockStoreDbInfo block_tree quorum_cert quorum_cert (timeout_cert option);

structure BlockStoreDbInfo = 
struct
	fun get_block_tree (BlockStoreDbInfo tree _ _ _) = tree

	fun get_highest_commit_cert (BlockStoreDbInfo _ cc _ _) = cc

	fun get_highest_quorum_cert (BlockStoreDbInfo _ _ qc _) = qc

	fun get_highest_timeout_cert (BlockStoreDbInfo _ _ _ tc) = tc

	fun serialize (BlockStoreDbInfo block_tree commit_cert quorum_cert timeout_cert) =
			ByteArray.from_list(
			    ByteArray.to_list(BlockTree.serialize block_tree) @
			    ByteArray.to_list(QuorumCert.serialize commit_cert) @
			    ByteArray.to_list(QuorumCert.serialize quorum_cert) @
			    ByteArray.to_list(Serialization.encode_option TimeoutCert.serialize timeout_cert)
			)

	fun deserialize bytes = 
		let
		    val (block_tree, block_tree_len) = BlockTree.deserialize bytes
		    val (commit_cert, commit_cert_len) = QuorumCert.deserialize (ByteArray.suffix bytes block_tree_len)       
		    val (quorum_cert, quorum_cert_len) = QuorumCert.deserialize (ByteArray.suffix bytes (block_tree_len + commit_cert_len))
		    val (timeout_cert, timeout_cert_len) = Serialization.decode_option TimeoutCert.deserialize (ByteArray.suffix bytes (block_tree_len + commit_cert_len + quorum_cert_len)) 
		in
		    (BlockStoreDbInfo block_tree commit_cert quorum_cert timeout_cert, 
		        (block_tree_len + commit_cert_len + quorum_cert_len + timeout_cert_len))
		end; 

	fun db_key () = "consensus_block_store";
end;
structure BlockStoreReader = 
struct
	fun read storage = 
		case (Storage.get storage (BlockStoreDbInfo.db_key ())) of
			Some block_store_db_info => Some (fst (BlockStoreDbInfo.deserialize block_store_db_info))
			| None => None;
end;  
structure BlockStoreWriter = 
struct
	fun write storage info = 
		let
			val bytes = BlockStoreDbInfo.serialize info
		in
			if (Storage.get_has_batch storage) then 
				Storage.batch_put storage (BlockStoreDbInfo.db_key ()) bytes
			else
				Storage.put storage (BlockStoreDbInfo.db_key ()) bytes True
		end;
end;
(**
 *	Type that represents block store responsible for pending blocks and certificates management.
 *
 *	@param block_tree: ```block_tree``` Block tree to store blocks and dependencies between them in memory.
 *	@param highest_commit_cert: ```quorum_cert``` Certificate of the highest commit block.
 *	@param highest_quorum_cert: ```quorum_cert``` Certificate for the block with maximum round.
 *	@param timeout_cert: ```timeout_cert```
 *)
datatype block_store = BlockStore block_tree quorum_cert quorum_cert (timeout_cert option);

(* Type that is used in functions which modify and persist block store *)
datatype persistent_block_store = PersistentBlockStore block_store storage;

(* Type that is used in functions which modify and persist block store and state computer *)
datatype persistent_block_store_computer = PersistentBlockStoreComputer block_store storage state_computer;

(**
 * Exception that is raised when certificate is inserting to the block store,
 * but corresponding block hasn't be inserted yet.
 * @param quorum_cert QuorumCert that is attempted to be inserted to the block store.
 *)
exception BlockStoreQCBlockMissing quorum_cert;

(**
 *	Exception that is raised when block store's commit block (first arg) inconsistent with
 *	state computer's one (second arg).
 *)
exception BlockStoreInconsistentCommit hash_value hash_value;

(**
 *	Exception that is raised when block store's state id (first arg) inconsistent with
 *	state computer's one (second arg).
 *)
exception BlockStoreInconsistentState hash_value hash_value;

(**
* Exception that is raised when there is no expected block in block_tree while trying to get 
* block by it's hash_value.
*)
exception BlockStoreBlockMissing hash_value

(**
 *	Exception is raised when no way to construct block store from scratch: either not enough blocks
 * 	to above the commit or commit cert is missiing.
 *)
exception BlockStoreSyncInitialDataMissing

(**
 *	Exception is raised when provided synch blocks don't form a valid chain.
 *)
 exception BlockStoreSyncInvalidChain hash_value

(**
 *	The structrure defines helper functions for internal usage to process block store.
 *	For public interface consider ```BlockStore``` structure.
 *)
structure BlockStorePrivate = 
struct

	fun ensure_valid_chain_from_parent parent_id blocks =
		let
			fun ensure_extension prev_id block =
				let
					val block_id = Hashing.from_block block
					val parent_id = Block.get_parent_hash block
				in
					if (ByteArray.equal parent_id prev_id) then
						block_id
					else
						raise BlockStoreSyncInvalidChain parent_id
				end
		in
			(List.foldl ensure_extension parent_id blocks; ())
		end;

	fun get_block_tree (BlockStore block_tree _ _ _) = block_tree;

	fun set_block_tree (BlockStore _ highest_cc highest_qc highest_tc) block_tree = 
		BlockStore block_tree highest_cc highest_qc highest_tc;

	fun get_highest_commit_cert (BlockStore _ cc _ _) = cc;

	fun set_highest_commit_cert (BlockStore block_tree _ highest_qc highest_tc) highest_cc = 
		BlockStore block_tree highest_cc highest_qc highest_tc;

	fun get_highest_quorum_cert (BlockStore _ _ qc _) = qc;

	fun set_highest_quorum_cert (BlockStore block_tree highest_cc _ highest_tc) highest_qc = 
		BlockStore block_tree highest_cc highest_qc highest_tc;

	fun get_highest_timeout_cert (BlockStore _ _ _ tc) = tc;

	fun set_highest_timeout_cert (BlockStore block_tree highest_cc highest_qc _) highest_tc = 
		BlockStore block_tree highest_cc highest_qc highest_tc;

	fun insert_quorum_cert block_store qc = 
		let
			val old_qc_round = QuorumCert.get_proposed_round (get_highest_quorum_cert block_store)
			val qc_round = QuorumCert.get_proposed_round qc
		in
			if qc_round > old_qc_round then
				let
					val block_result = BlockTree.get_block (get_block_tree block_store) (QuorumCert.get_proposed_hash qc)
				in
					case block_result of
						Some _ => Some (set_highest_quorum_cert block_store qc)
                        (*| None => None*)
						| None => raise (BlockStoreQCBlockMissing qc)
				end
			else
				None
		end;

	fun insert_timeout_cert block_store tc = 
		let
            fun replace_tc block_store old_tc =
                let
                    val old_tc_round = TimeoutCert.get_round old_tc
                    val tc_round = TimeoutCert.get_round tc
                in
                    if tc_round > old_tc_round then
                        Some (set_highest_timeout_cert block_store (Some tc))
                    else
                        None
                end
		in
            Option.getOpt (Option.map (replace_tc block_store) 
                                      (get_highest_timeout_cert block_store)) 
                          (Some (set_highest_timeout_cert block_store (Some tc)))
		end;

	fun check_commit (PersistentBlockStoreComputer block_store storage state_computer) = 
		let
			val block_tree = get_block_tree block_store
			val highest_qc = get_highest_quorum_cert block_store
			val qc_hash = QuorumCert.get_proposed_hash highest_qc
			val root_hash = BlockTree.get_root_id block_tree
			val signed_ledger_info = QuorumCert.get_signed_ledger_info highest_qc 
			fun map_adjacent_round block = 
				Option.mapPartial
						(
							fn parent => 
								if (ExecutedBlock.get_round parent) + 1 = (ExecutedBlock.get_round block) 
									andalso not (ByteArray.equal root_hash (Hashing.from_executed_block parent)) then
									Some parent
								else
									None
						)
						(BlockTree.get_block block_tree (ExecutedBlock.get_parent_hash block));

			fun commit blocks =
				let
					val (PersistentStateComputer new_state_computer new_storage) = 
						PersistentStateComputer.commit (PersistentStateComputer state_computer storage) blocks signed_ledger_info
					val new_block_tree = BlockTree.prune block_tree (Hashing.from_executed_block (List.last blocks))
					val new_highest_commit_cert = highest_qc
					val new_block_store = set_highest_commit_cert (set_block_tree block_store new_block_tree) new_highest_commit_cert
				in
					(PersistentBlockStoreComputer new_block_store new_storage new_state_computer)
				end;


		in
			Option.getOpt
				(Option.map
					(fn blocks => commit (List.tl blocks))
					(Option.mapPartial 
						(fn block => 
							BlockTree.get_blocks_from_path block_tree (BlockTree.get_root_id block_tree) (Hashing.from_executed_block block)
						)
						(Option.mapPartial
							map_adjacent_round
							(Option.mapPartial map_adjacent_round (BlockTree.get_block block_tree qc_hash)))))
				(PersistentBlockStoreComputer block_store storage state_computer)
		end;
	
	fun create_from_info persistent_computer block_store_info =
		let
			val block_tree = BlockStoreDbInfo.get_block_tree block_store_info
			
			fun get_children_blocks block =
				let
					val (BlockTree root_id tree) = block_tree
					val hash_set_option = Option.map (fn (LinkableBlock _ hash_set) => hash_set)
								(Map.lookup tree (Hashing.from_executed_block block))
					val hash_list = if Option.isNone hash_set_option then
										[]
									else
										Set.to_list (Option.valOf hash_set_option)
					val block_list = List.map (fn hash =>   if Option.isNone (BlockTree.get_block block_tree hash) then	
																raise BlockStoreBlockMissing hash
															else
																Option.valOf (BlockTree.get_block block_tree hash)
												) hash_list
				in
					block_list
				end

			fun apply_block (applied_block_tree, persistent_computer) block =
				let
					val current_state_id = StateComputeResult.get_hash_value (ExecutedBlock.get_state_compute_result block)
					val exec_node = PersistentStateComputer.execute_block persistent_computer (ExecutedBlock.get_block block)
					val state_computer = PersistentComputeResult.get_computer exec_node
					val storage = PersistentComputeResult.get_storage exec_node
					val result = PersistentComputeResult.get_result exec_node
					val state_id = StateComputeResult.get_hash_value result
				in
					if ByteArray.equal current_state_id state_id then
						(BlockTree.insert_block applied_block_tree block, PersistentStateComputer state_computer storage)
					else
						raise BlockStoreInconsistentState current_state_id state_id
				end
			
			fun apply_blocks (applied_block_tree, persistent_computer) block_list =
				let
					fun get_children_blocks_and_apply_block (tree, computer) block =
						let
							val children = get_children_blocks block
							val result = apply_block (tree, computer) block
						in
							apply_blocks result children
						end 
				in
					List.foldl get_children_blocks_and_apply_block (applied_block_tree, persistent_computer) block_list
				end

			val root_hash = BlockTree.get_root_id block_tree
			val root_block = Option.valOf (BlockTree.get_block block_tree root_hash)
			val root_result = (ExecutedBlock.get_state_compute_result root_block)
			val root_version = StateComputeResult.get_current_version root_result
			val root_state_id = StateComputeResult.get_hash_value root_result
			val computer = PersistentStateComputer.get_computer persistent_computer
			val commit_state_id = StateComputer.commit_state_id computer
			val commit_block_version = StateComputer.commit_block_version computer

			val (block_tree, persistent_computer) = if commit_block_version = root_version then
														if ByteArray.equal root_state_id commit_state_id then
															let
																val init_block_tree = BlockTree.from_single root_block
															in
																apply_blocks (init_block_tree, persistent_computer) (get_children_blocks root_block)
															end
														else
															raise BlockStoreInconsistentState root_state_id commit_state_id
													else
														if commit_block_version > root_version then
															(block_tree, persistent_computer)
														else
															raise BlockStoreInconsistentCommit root_state_id (StateComputer.commit_block_id computer)
			val block_store = BlockStore 
									block_tree 
									(BlockStoreDbInfo.get_highest_commit_cert block_store_info)
									(BlockStoreDbInfo.get_highest_quorum_cert block_store_info)
									(BlockStoreDbInfo.get_highest_timeout_cert block_store_info)
		in
			PersistentBlockStoreComputer block_store (PersistentStateComputer.get_storage persistent_computer) (PersistentStateComputer.get_computer persistent_computer)
		end

	fun create_from_genesis persistent_computer genesis =
		let
			val storage = (PersistentStateComputer.get_storage persistent_computer)
			val state_computer = (PersistentStateComputer.get_computer persistent_computer)
			val commit_block_id = StateComputer.commit_block_id state_computer
			val commit_version = StateComputer.commit_block_version state_computer
			val genesis_id =  Hashing.from_block genesis
			val state_id = StateComputer.commit_state_id state_computer
		in
			if ByteArray.equal genesis_id commit_block_id then
				let
					val compute_result = StateComputeResult.create_from_genesis state_id commit_version
					val executed_block = ExecutedBlock.create(genesis, compute_result)
					val commit_round = Block.get_round genesis
					val commit_timestamp = Block.get_timestamp genesis
					val commit_info = BlockInfo.create(commit_round, commit_block_id, state_id, commit_version, commit_timestamp)
					val vote_data = VoteData.create(commit_info, commit_info)
					val ledger_info = LedgerInfo.create(commit_info, Hashing.from_vote_data vote_data)
					val quorum_cert = QuorumCert.create(vote_data, SignedLedgerInfo.create(ledger_info, Map.empty ByteArray.compare))
					val block_store = BlockStore (BlockTree.from_single executed_block) quorum_cert quorum_cert None
				in
					PersistentBlockStoreComputer block_store storage state_computer
				end
			else
				raise BlockStoreInconsistentCommit genesis_id commit_block_id

		end

    fun validate_blocks block_store validate_fun =
        let
            val block_tree = get_block_tree block_store
            val BlockTree root_id blocks_map = block_tree
            val blocks = Map.toAscList blocks_map
            val blocks_valid = List.all (
                                        fn (_, LinkableBlock block _) => (
                                            ByteArray.equal (Hashing.from_executed_block block) root_id orelse
                                            validate_fun (ExecutedBlock.get_block block)
                                        )
                                    ) blocks
        in
            blocks_valid
        end
end;

(**
 *	Structure defines public functions to query or modify in memory data of the block store.
 *)
structure BlockStore = 
struct

	(*
	 * 	Constructs and returns `block_store` value from provided parameters.
	 *	@params block_tree: ```block_tree``` Block tree that represents in memory storage 
	 *		for pending executed blocks and dependencies between them.
	 *	@params highest_commit_cert: ```quorum_cert```
	 *	@params highest_quorum_cert: ```quorum_cert```
	 * 	@params timeout_cert: ```timeout_cert option```
	 *)
	fun init block_tree highest_commit_cert highest_quorum_cert timeout_cert =
		BlockStore block_tree highest_commit_cert highest_quorum_cert timeout_cert

	(**
	 *	Constructs and returns ```sync_info``` value matching current block store state.
	 *	@params block_store.
	 *	@param block_store: ```block_store``` Block store to fetch state from.
	 *	@return ```sync_info``` value.
	 *)
	fun get_sync_info (BlockStore _ highest_cc highest_qc highest_tc) = 
		SyncInfo highest_cc highest_qc highest_tc;

	(**
	 *	Searches for the block in the block store by the hash.
	 *	@param block_store: ```block_store``` Block store value to fetch block from.
	 *	@param hash: ```hash_value``` Block's hash to search by.
	 *	@return ```executed_block option``` Executed block in case it was found and None otherwise.
	 *)
	fun get_block block_store hash = 
		BlockTree.get_block (BlockStorePrivate.get_block_tree block_store) hash;

	(**
	 *	Constructs list of the blocks matching particular path in the block tree
	 *	defined by a pair of block hashes.
	 *
	 *	@param block_store: ```block_store``` Block store value to fetch path from.
	 *	@param hash1: ```hash_value``` Hash of the first block in the path.
	 *	@param hash2: ```hash_value``` Hash of the last block in the path.
	 *
	 *	@return ```executed_block list option``` list of executed block if a path is found and ```None``` otherwise.
	 *
	 *	@raises ```BlockTreeNodeMissing``` if a block corresponding to any of the hashes doesn't exist in the block store.
	 *)
	fun get_blocks_from_path block_store hash1 hash2 = 
		BlockTree.get_blocks_from_path (BlockStorePrivate.get_block_tree block_store) hash1 hash2;

	(**
	 *	Constructs a list of blocks that is sent by synchronization logic to the poor node. As a poor node might
	 *	not now the hash of the next block it sends the hash of the current block and the hash of the final block
	 *	in the chain.
	 *
	 *	@param block_store: ```block_store``` Block store value to fetch path from.
	 *	@param opt_parent_hash: ```hash_value``` Optional hash of the parent of the first block in the path. If None then
	 *	path starts from the root.
	 *	@param waypoint_hash: ```hash_value``` Hash of the last block in the path.
	 *
	 *	@return ```executed_block list option``` list of executed block if a path is found and ```None``` otherwise.
	 *
	 *	@raises ```BlockTreeNodeMissing``` if a block corresponding to any of the hashes doesn't exist in the block store.
	 *)
	fun get_sync_blocks block_store opt_parent_hash waypoint_hash =
		BlockTree.get_sync_blocks (BlockStorePrivate.get_block_tree block_store) opt_parent_hash waypoint_hash

	fun validate_blocks block_store validate_fun = 
		BlockStorePrivate.validate_blocks block_store validate_fun

	fun get_highest_quorum_cert block_store = 
		BlockStorePrivate.get_highest_quorum_cert block_store

	fun get_highest_commit_cert block_store =
		BlockStorePrivate.get_highest_commit_cert block_store
		
	fun get_highest_timeout_cert block_store =
		BlockStorePrivate.get_highest_timeout_cert block_store
end;

(**
 *	Structure defines public functions that modify and persist the block store into the storage.
 *)
structure PersistentBlockStore = 
struct

	(**
	 *	Extracts blockstore field.
	 *
	 *	@param persistent_block_store Persistent block store
	 *	that stores intrested field.
	 *
	 *	@return blockstore value.
	 *)
	fun get_blockstore (PersistentBlockStore blockstore _) = blockstore

	(**
	 *	Extracts storage field.
	 *
	 *	@param persistent_block_store Persistent block store
	 *	that stores intrested field.
	 *
	 *	@return storage value.
	 *)

	fun get_storage (PersistentBlockStore _ storage) = storage

	(**
	 *	Persist block store into the storage.
	 *
	 * 	@params persistent_block_store.
	 *	@param persistent_block_store: ```persistent_block_store``` Pair of the block store to persist and storage to modify.
	 *	@return ```persistent_block_store``` Pair of persisted block store and modified storage.
	 *	
	 *	NOTE: Execution of the function might have side effect that depends on implementation of the storage.
	 *)
	fun save_block_store (PersistentBlockStore (BlockStore tree highest_cc highest_qc highest_tc) storage) =
		let
			val new_storage = BlockStoreWriter.write storage (BlockStoreDbInfo tree highest_cc highest_qc highest_tc)
		in
			PersistentBlockStore (BlockStore tree highest_cc highest_qc highest_tc) new_storage
		end	

	(**
	 *	Updates current timeout certificate in case provided one is newer or local one is not set.
	 *
	 *	@params store, tc.
	 *	@param store: ```persistent_block_store``` Pair of the block store to persist and storage to modify.
	 *	@param tc: ```timeout_cert``` Timeout certificate to apply.
	 *	@return ```persistent_block_store``` Pair of persisted block store and modified storage.
	 *	
	 *	NOTE: Due to the fact that block store is persisted to the storage after modification, 
	 *	execution of the function might have side effect that depends on implementation of the storage.
	 *)
	fun insert_timeout_cert (PersistentBlockStore block_store storage) tc =
		let
			val result = BlockStorePrivate.insert_timeout_cert block_store tc
		in
			case result of
				Some new_block_store => save_block_store (PersistentBlockStore new_block_store storage)
				| None => PersistentBlockStore block_store storage
		end;
end;

(**
 *	Structure defines public functions that modify and persist 
 *	the block store and state computer into the storage.
 *)
structure PersistentBlockStoreComputer = 
struct
	(**
	 *	Extracts blockstore field.
	 *
	 *	@param persistent_block_store_computer Persistent block store computer
	 *	that stores intrested field.
	 *
	 *	@return blockstore value.
	 *)

	fun get_blockstore (PersistentBlockStoreComputer blockstore _ _) = blockstore;

	(**
	 *	Extracts storage field.
	 *
	 *	@param persistent_block_store_computer Persistent block store computer
	 *	that stores intrested field.
	 *
	 *	@return storage value.
	 *)

	fun get_storage (PersistentBlockStoreComputer _ storage _) = storage;

	(**
	 *	Extracts state computer field.
	 *
	 *	@param persistent_block_store_computer Persistent block store computer
	 *	that stores intrested field.
	 *
	 *	@return state_computer value.
	 *)

	fun get_state_computer (PersistentBlockStoreComputer _ _ state_computer) = state_computer;

	(**
	 *	Extracts persistent state computer field.
	 *
	 *	@param persistent_block_store_computer Persistent block store computer
	 *	that stores intrested field.
	 *
	 *	@return persistent_state_computer value.
	 *)

	fun get_persistent_computer (PersistentBlockStoreComputer _ storage state_computer) = PersistentStateComputer state_computer storage;

	(**
	 *	Creates new block store either loading last state from the storage or
	 *	creating initial one using genesis block. If the blockstore is initialized
	 *	from the storage persistent state computer is used to reexecute highest
	 * 	block chain to be able to handle receiving blocks from other nodes.
	 *	In case block store is initialized from genesis block it checks
	 *	that is matches state computer and raises exception if inconsistency detected.
	 *
	 *	@param persistent_computer ```persistent_state_computer``` persistent state computer 
	 *		is used to execute blocks loaded from the storage.
	 *	@param genesis ```block``` genesis block that is used when there is no state 
	 *		found in the storage.
	 *
	 *	@return ```persistent_block_store_computer``` newly created triple of block_storage, 
	 *		storage and state_computer
	 *	
	 *	@raises ```BlockStoreInconsistentCommit``` if state computer is initialized
	 *		with other existing commit or another genesis block.
	 *	@raises ```BlockStoreInconsistentState``` if state computer
	 *		has another state id then block loaded from block store's state.
	 *)
	fun create persistent_computer genesis =
		let
			val storage = PersistentStateComputer.get_storage persistent_computer
			val block_info = BlockStoreReader.read storage
			val opt_result = Option.map (fn info => BlockStorePrivate.create_from_info persistent_computer info) block_info
		in
			case opt_result of
				Some result => result
				| None => BlockStorePrivate.create_from_genesis persistent_computer genesis
		end;

	(**
	 *	Inserts a quorum certificate into the block store. In result, highest quorum certificate might be updated
	 *	if round value in new one is higher. Also this method might trigger commit of the blocks if
	 *	3-chain rule is met for a block: if there is a chain of blocks in the block tree, A --> B --> C, A is commited 
	 *	if there are quorum certificates for A, B and C, A.round + 1 = B.round, B.round + 1 = C.round.
	 *	Commit might include several blocks because there might be pending blocks between root (last commited block) 
	 *	and the block for which 3-chain rule is met. When a chain of blocks is commited the block tree is pruned: 
	 *	last commited block becomes the root and blocks which are not reachable from the root are removed.
	 *
	 *	@param persistent_block_store_computer: ```persistent_block_store_computer``` Triple of blockstore, storage and state computer.
	 *	@param qc: ```quorum_cert``` Quorum certificate to be inserted.
	 *	@return ```persistent_block_store_computer``` Updated triple of blockstore, storage and state computer.
	 *
	 *	@raises ```BlockStoreQCBlockMissing``` if corresponding block is not found in the block store.
	 *
	 *	NOTE: Due to the fact that block store and state computer is persisted to the storage after modification, 
	 *	execution of the function might have side effect that depends on implementation of the storage.
	 *)
	fun insert_quorum_cert (PersistentBlockStoreComputer block_store storage state_computer) qc =
		let
			val result = Option.map
							(fn (PersistentBlockStoreComputer block_store storage state_computer) => 
								let
									val (PersistentBlockStore new_block_store new_storage) = PersistentBlockStore.save_block_store (PersistentBlockStore block_store storage)
								in
									PersistentBlockStoreComputer new_block_store new_storage state_computer
							end)
							(Option.map 
								(fn new_block_store => BlockStorePrivate.check_commit (PersistentBlockStoreComputer new_block_store storage state_computer)) 
								(BlockStorePrivate.insert_quorum_cert block_store qc))
		in
			case result of
				Some persistent_block_store_computer => persistent_block_store_computer
				| None => (PersistentBlockStoreComputer block_store storage state_computer)
		end;

	(**
	 *	Executes provided block (if not already executed) using state computer and inserts the result 
     *  into the block store. Implementation calls to
	 *	```insert_quorum_cert``` for the certificate the block is carring 
     *  and thus might commit other blocks before inserting new one.
	 *
	 *	@param persistent_block_store_computer: ```persistent_block_store_computer``` 
     *         Triple of blockstore, storage and state computer.
	 *	@param block: ```block``` New block to be inserted.
	 *
	 *	@raises ```BlockStoreQCBlockMissing``` if the parent block is missing
     *          when inserting carried certificate.
	 *
	 *	NOTE: Due to the fact that block store and state computer is persisted
     *        to the storage after modification, execution of the function 
     *        might have side effect that depends on implementation of the storage.
	 *)
	fun execute_and_insert persistent_block_store_computer block = 
		let
			fun execute_and_insert_non_existing () =
				let 
					val (PersistentBlockStoreComputer updated_bs updated_st updated_sc) =
                		insert_quorum_cert persistent_block_store_computer (Block.get_quorum_cert block)
					val (PersistentStateComputeResult final_state_computer new_storage execution_result) =
                		PersistentStateComputer.execute_block (PersistentStateComputer updated_sc updated_st) block
					val executed_block = ExecutedBlock block execution_result
					val new_block_tree = BlockTree.insert_block (BlockStorePrivate.get_block_tree updated_bs) executed_block
					val new_block_store = BlockStorePrivate.set_block_tree updated_bs new_block_tree
					val (PersistentBlockStore final_block_store final_storage) =
                		PersistentBlockStore.save_block_store (PersistentBlockStore new_block_store new_storage)
				in 
            		((PersistentBlockStoreComputer final_block_store final_storage final_state_computer), executed_block)
				end

			val block_hash = Hashing.from_block block
			val block_tree = BlockStorePrivate.get_block_tree (get_blockstore persistent_block_store_computer)
		in
			case (BlockTree.get_block block_tree block_hash) of
				Some existing_block => (persistent_block_store_computer, existing_block)
				| None => execute_and_insert_non_existing ()
		end;

	(**
	 *	Changes the block tree either by adding new blocks to existing chain or builds a new
	 *	tree if the first block in the list doesn't match current root block but matches commit from
	 *	state computer. The last case is possible when state computer just received all transactions
	 *	but block store is out of sync.
	 *
	 *	@param persistent_block_store_computer: ```persistent_block_store_computer``` 
     *         Triple of blockstore, storage and state computer.
	 *	@param blocks: ```block list``` List of block received during sync.
	 *
	 *	@raises BlockStoreInconsistentCommit when first block is neither matches commit from
	 *	state computer nor parent of it exists.
	 *
	 *	@raises BlockStoreSyncInvalidChain when block list doesn't represent sequence of
	 *	consecutive blocks.
	 *
	 *	@raises BlockStoreSyncInitialDataMissing when either commit cert is missing or
	 *	number of blocks less than three (to satisfy 3-chain rule).
	 *
	 *)
	fun apply_sync_blocks persistent_block_store_computer blocks opt_commit_qc =
		if List.null blocks then
			persistent_block_store_computer
		else
			let
				fun apply_from_parent persistent_block_store_computer blocks =
					let
						val block_store = get_blockstore persistent_block_store_computer
						val persistent_state_computer = get_persistent_computer persistent_block_store_computer
						val (block_store, persistent_state_computer) = List.foldl (
								fn (block_store, persistent_state_computer) => fn block =>
									let
										val block_id = Hashing.from_block block
									in
										if Option.isNone (BlockStore.get_block block_store block_id) then
											let
												val (PersistentStateComputeResult state_computer storage result) = PersistentStateComputer.execute_block persistent_state_computer block
												val block_tree = BlockTree.insert_block (BlockStorePrivate.get_block_tree block_store) (ExecutedBlock.create(block, result))
												val block_store = BlockStorePrivate.set_block_tree block_store block_tree 
												val block_store = Option.getOpt (BlockStorePrivate.insert_quorum_cert block_store (Block.get_quorum_cert block)) block_store
											in
												(block_store, PersistentStateComputer state_computer storage)
											end
										else
											(block_store, persistent_state_computer)
									end
							) 
							(block_store, persistent_state_computer) blocks
					in
						PersistentBlockStoreComputer block_store (PersistentStateComputer.get_storage persistent_state_computer) (PersistentStateComputer.get_computer persistent_state_computer)
					end

				fun apply_from_root persistent_block_store_computer root_block others commit_qc =
					let
						val block_store = get_blockstore persistent_block_store_computer
						val first_hash = Hashing.from_block root_block
					in
						if ByteArray.equal (BlockTree.get_root_id (BlockStorePrivate.get_block_tree block_store)) first_hash then
								apply_from_parent persistent_block_store_computer others
							else
								let
									val persistent_state_computer = get_persistent_computer persistent_block_store_computer
									val (PersistentStateComputeResult state_computer storage exec_result) = PersistentStateComputer.execute_block persistent_state_computer root_block
									val block_tree = BlockTree.from_single (ExecutedBlock.create(root_block,exec_result))
									val block_store = BlockStore block_tree commit_qc commit_qc None
								in
									apply_from_parent (PersistentBlockStoreComputer block_store storage state_computer) others
								end
							
					end

				val block_store = get_blockstore persistent_block_store_computer
				val state_computer = get_state_computer persistent_block_store_computer
				val first_block = List.hd blocks
				val first_hash = Hashing.from_block first_block
				val others = List.tl blocks
				val _ = BlockStorePrivate.ensure_valid_chain_from_parent (Hashing.from_block first_block) others
				val current_commit_id = (StateComputer.commit_block_id state_computer)
			in
				if ByteArray.equal current_commit_id first_hash then
					if Option.isSome opt_commit_qc andalso ((List.length others) >= 2) then
						apply_from_root persistent_block_store_computer first_block others (Option.valOf opt_commit_qc)
					else
						raise BlockStoreSyncInitialDataMissing
				else
					let
						val maybe_parent = BlockStore.get_block block_store (Block.get_parent_hash first_block)
					in
						if Option.isSome maybe_parent then
							apply_from_parent persistent_block_store_computer blocks
						else
							raise BlockStoreInconsistentCommit first_hash current_commit_id
					end	
			end
end;

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
			BlockStoreQCBlockMissing _ => "BlockStoreQCBlockMissing"  
		  | BlockStoreInconsistentCommit _ _ => "BlockStoreInconsistentCommit" 
		  | BlockStoreInconsistentState _ _ => "BlockStoreInconsistentState" 
		  | BlockStoreBlockMissing _ => "BlockStoreBlockMissing"
		  | BlockStoreSyncInitialDataMissing => "BlockStoreSyncInitialDataMissing"
		  | BlockStoreSyncInvalidChain _ => "BlockStoreSyncInvalidChain"
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
			BlockStoreQCBlockMissing qc => 
				"BlockStoreQCBlockMissing" ^ " \n" ^ QuorumCert.to_string "  " qc
		  | BlockStoreInconsistentCommit h1 h2 => 
				"BlockStoreInconsistentCommit" ^ " " ^ Hex.bytes_to_hex h1 ^ " " ^ Hex.bytes_to_hex h2
		  | BlockStoreInconsistentState h1 h2 => 
				"BlockStoreInconsistentState" ^ " " ^ Hex.bytes_to_hex h1 ^ " " ^ Hex.bytes_to_hex h2
		  | BlockStoreBlockMissing v1 => 
		  		"BlockStoreBlockMissing" ^ " " ^ Hex.bytes_to_hex v1
		  | BlockStoreSyncInitialDataMissing => 
		  		"BlockStoreSyncInitialDataMissing"
		  | BlockStoreSyncInvalidChain v1 => 
		  		"BlockStoreSyncInvalidChain" ^ " " ^ Hex.bytes_to_hex v1
		  | _ => raise Exception.Unknown
	)
structure TxValidation =
struct
    (* Implementation of transactions validation according to specification
     * NOTE: there is special logic for account creation transaction(type=2)
    *)
    fun validate_transaction_timestamp (SignedTransaction transaction_payload signs) =
        let
            val day_diff = 24 * 60 * 60 * 1000 * 1000
            val transaction_timestamp = TransactionPayload.get_timestamp transaction_payload
            val current_time = Time.current ()
        in
            (transaction_timestamp + day_diff >= current_time) andalso
            (current_time >= transaction_timestamp)
        end;    
    
    fun validate_transaction_signs_using_keys author_keys (SignedTransaction transaction_payload signs) =
        let
            val transaction_signs = Set.to_list signs
            val serialized_payload = TransactionPayload.serialize transaction_payload
            fun pair_sign serialized_data sign (keys : sign list) =
                case keys of
                  [] => ((* is sign matched *) False, [])
                | hd::tl => 
                        if (SignatureVerifier.verify sign serialized_data hd)
                        then (True, tl)
                        else (
                                let
                                    val (result, upd_tl) = pair_sign serialized_data sign tl
                                in
                                    (result, hd::upd_tl)
                                end
                             )
            fun pair_all_signs serialized_data (signs : sign list) (keys : sign list) =
                case signs of
                  [] => ((* are signs empty *) True, keys)
                | hd::tl =>
                    (
                        let
                            val (is_matched, upd_keys) = pair_sign serialized_data hd keys
                        in
                            if is_matched
                            then pair_all_signs serialized_data tl upd_keys
                            else (False, upd_keys)
                        end
                    )
            val (are_matched, left_keys) = pair_all_signs serialized_payload transaction_signs author_keys
        in
            are_matched andalso
            ((List.length left_keys) = 0)
        end;

    (* Precondition - type <> 2 *)
    fun validate_transaction_signs account_opt signed_tx =
    	Option.getOpt (Option.map (fn account => (validate_transaction_signs_using_keys (Set.to_list (Account.get_public_keys account)) signed_tx)) account_opt) False
        
    (* Precondition - type = 2 *)
    fun validate_account_creation_signs (SignedTransaction transaction_payload signs) =
        let
            fun validate_using_payload payload_data =
            	validate_transaction_signs_using_keys (fst (Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size())) payload_data)) (SignedTransaction transaction_payload signs)
            	handle _ => False

            val is_valid = Option.getOpt (Option.map (validate_using_payload) (TransactionPayload.get_data transaction_payload))
                                          False
        in
            is_valid
        end

    (* Precondition - type <> 2 *)
    fun validate_transaction_nonce account_opt (SignedTransaction payload signs) =
    	Option.getOpt (Option.map (fn account => (TransactionPayload.get_nonce payload) >= (Account.get_nonce account)) account_opt) False

    (* Precondition - type = 2 *)
    fun validate_account_creation_nonce (SignedTransaction transaction_payload signs) =
    	(TransactionPayload.get_nonce transaction_payload) = 0

    (* mock *)
    fun validate_transaction_type (SignedTransaction transaction_payload signs) = 
        (
        case (TransactionPayload.get_type transaction_payload) of
            0 => True
          | 1 => True
          | 2 => True
          | 3 => True
          | 4 => True
          | 5 => True
          | 6 => True
          | 7 => True
          | 8 => True
          | _ => False
        );
    
    fun validate_types_in_transaction (SignedTransaction transaction_payload signs) =
        let
            val from = TransactionPayload.get_from transaction_payload
            val to = TransactionPayload.get_to transaction_payload
            val tx_type = TransactionPayload.get_type transaction_payload
            val data = TransactionPayload.get_data transaction_payload

            fun ensure_valid_pubkeys keys =
            	let
			         fun ensure_all_keys_of_valid_size () =
				        let
					       val invalid_key = List.find (fn key => not ((Word8Array.length key) = (Keypair.pub_size ()))) keys
				    in
					   case invalid_key of
						  Some key => False
						  | None => True
				    end
			
			         fun ensure_no_duplications () =
				        let
					       val keys_set = Set.from_list (ByteArray.compare) keys
				        in
					       if (Set.length keys_set) <> (List.length keys) then
						      False
					       else
						      True
				        end
		        in
			      (ensure_all_keys_of_valid_size ()) andalso (ensure_no_duplications ())
		        end
            
            val data_validity = case tx_type of
            	     0 => True
            	   | 1 => True
            	   | 2 => ensure_valid_pubkeys (fst (Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) (Option.valOf data)))
				   | 3 => Option.isNone data
				   | 4 => Option.isNone data
				   | 5 => True 
				   | 6 => ensure_valid_pubkeys (fst (Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) (Option.valOf data)))
				   | 7 => ensure_valid_pubkeys (fst (Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) (Option.valOf data)))
				   | 8 => ensure_valid_pubkeys (fst (Serialization.decode_list (Serialization.decode_byte_array (Keypair.pub_size ())) (Option.valOf data)))
				   | _ => False
 	
            val from_validity = Guid.isValid from
            
            val to_validity = case tx_type of
            			0 => Guid.isValid (Option.valOf to)
            			| 1 => Guid.isValid (Option.valOf to)
            			| 2 => Option.isNone to
            			| 3 => Guid.isValid (Option.valOf to)
            			| 4 => Guid.isValid (Option.valOf to)
            			| 5 => Option.isNone to
            			| 6 => Option.isNone to
            			| 7 => Option.isNone to
            			| 8 => Option.isNone to
                        | _ => False
         
            val create_user_signs_validity = if (TransactionPayload.is_user_creation transaction_payload) then
            				validate_account_creation_signs (SignedTransaction transaction_payload signs)
            			else
            				True		        	
        in
        	from_validity
    			andalso
    		to_validity
    			andalso
    		data_validity
    			andalso
    		create_user_signs_validity
        end
        handle _ => False;

    fun validate_transaction block_store_computer signed_transaction = 
        let
            val transaction_payload = SignedTransaction.get_payload signed_transaction
            val sender_id = TransactionPayload.get_from transaction_payload

            val block_store = PersistentBlockStoreComputer.get_blockstore block_store_computer
            val block_id = QuorumCert.get_proposed_hash (SyncInfo.get_highest_quorum_cert (BlockStore.get_sync_info block_store))
            val state_computer = PersistentBlockStoreComputer.get_persistent_computer block_store_computer

            val sender_account = PersistentStateComputer.get_account_by_block_id state_computer sender_id block_id

            val is_user_creation = TransactionPayload.is_user_creation transaction_payload

            val nonce_validity = if is_user_creation
                                 then validate_account_creation_nonce signed_transaction
                                 else validate_transaction_nonce sender_account signed_transaction

            val time_validity = validate_transaction_timestamp signed_transaction

            val signs_validity = if is_user_creation
                                 then validate_account_creation_signs signed_transaction
                                 else validate_transaction_signs sender_account signed_transaction

            val type_validity = validate_transaction_type signed_transaction

            val params_validity = validate_types_in_transaction signed_transaction
        in
            nonce_validity andalso 
            time_validity andalso
            signs_validity andalso 
            type_validity andalso
            params_validity
        end;
end;
structure Validating =
struct
    local 
        fun get_f n_validators =
            (n_validators - 1) div 3
    in
        fun check_voting_power n_validators voting_power =
            voting_power >= 2 * (get_f n_validators) + 1
    end

    fun check_signatures state_block_id_opt message signs psc validators =
        let
            val id_sign_list = Map.toAscList signs
            val is_sufficient_signs = check_voting_power (List.length validators) (List.length id_sign_list)
            fun check_signature account_id sign =
                let
                    val account_opt = case state_block_id_opt of 
                                        Some block_id => PersistentStateComputer.get_account_by_block_id psc account_id block_id
                                      | None => PersistentStateComputer.get_account psc account_id
                in
                    case account_opt of
                        Some account => AccountValidation.validate_signature account message sign
                        | None => False
                end
        in
            if List.null id_sign_list then
                False
            else
                is_sufficient_signs
                    andalso
                (List.all (fn (id, signture) => (List.exists (fn x => (ByteArray.compare x id) = Equal) validators)) id_sign_list)
                    andalso
                (List.all (fn (id, signture) => check_signature id signture) id_sign_list)
        end;

    fun validate_quorum_cert (qc: quorum_cert) (blsc: persistent_block_store_computer) validators =
        let
            val block_store = PersistentBlockStoreComputer.get_blockstore blsc
            val storage = PersistentBlockStoreComputer.get_storage blsc
            val state_computer = PersistentBlockStoreComputer.get_state_computer blsc

            val parent_round = QuorumCert.get_parent_round qc
            val parent_hash = QuorumCert.get_parent_hash qc
            val proposed_round = QuorumCert.get_proposed_round qc
            val proposed_hash = QuorumCert.get_proposed_hash qc

            val signed_ledger_info = QuorumCert.get_signed_ledger_info qc
            val message = LedgerInfo.serialize (SignedLedgerInfo.get_ledger_info signed_ledger_info)
            val signs = SignedLedgerInfo.get_signatures signed_ledger_info

            fun check_commit_info () =
                let
                    val commit_info = SignedLedgerInfo.get_commit_info signed_ledger_info
                in
                    if (Comparators.eq_block_info commit_info (BlockInfo.empty ())) then
                        True
                    else
                        (Option.isSome (BlockStore.get_block block_store (BlockInfo.get_id commit_info)))
                end

            fun check_blocks_exist () =
                (Option.isSome (BlockStore.get_block block_store proposed_hash))
                    andalso
                (Option.isSome (BlockStore.get_block block_store parent_hash))
                    andalso
                (check_commit_info ())
        in
            if (proposed_round = 0) then
                True
            else
                (parent_round < proposed_round)
                    andalso
                (check_blocks_exist ())
                    andalso
                (check_signatures (Some proposed_hash) message signs (PersistentStateComputer state_computer storage) validators)
        end

    fun validate_timeout_cert (tc: timeout_cert) (psc: persistent_state_computer) validators =
        let
            val signs = TimeoutCert.get_signatures tc
            val message = Serialization.encode_int_flex (TimeoutCert.get_round tc)
        in
            check_signatures None message signs psc validators
        end

    fun validate_quorum_cert_offchain (qc: quorum_cert) =
        let
            val proposed_round = QuorumCert.get_proposed_round qc
            val parent_round = QuorumCert.get_parent_round qc
        in
            if (proposed_round = 0) then
                True
            else
                (parent_round < proposed_round)
        end

    fun check_block_author_and_sign psc opt_logger block =
        let
            val parent_id = Block.get_parent_hash block
            val block_data = Block.get_block_data block
            val block_type = BlockData.get_block_type block_data
            fun check_sign account =
                let
                    val sign_opt = Block.get_sign block
                    val message = BlockData.serialize block_data
                in
                    case sign_opt of
                          Some sign => AccountValidation.validate_signature account message sign
                        | None => True (* TODO: Change this to False when block generator fixed *)
                end
        in
            case block_type of 
              Proposal author _ =>  (case PersistentStateComputer.get_account_by_block_id psc author parent_id of
                                      Some account => check_sign account
                                    | None => (
                                        Option.map (fn logger =>
                                            (
                                                Logger.info logger ("Account not found")
                                            )
                                        ) opt_logger;
                                        False
                                    ))
            | _ => True
        end

    fun validate_block (block: block) (blsc: persistent_block_store_computer) validators opt_logger =
        let
            val qc = Block.get_quorum_cert block
            val proposed_round = QuorumCert.get_proposed_round qc
            val block_author_valid = check_block_author_and_sign (PersistentBlockStoreComputer.get_persistent_computer blsc) opt_logger block
        in
            if (proposed_round = 0) then
                block_author_valid
            else
                let
                    val quorum_cert_valid = validate_quorum_cert qc blsc validators
                    val _ = Option.map (fn logger =>
                        (
                            Logger.info logger ("Block validation:");
                            Logger.info logger ("Quorum cert valid: " ^ (Bool.toString quorum_cert_valid));
                            Logger.info logger ("Block author valid: " ^ (Bool.toString block_author_valid))
                        )
                    ) opt_logger
                in
                    quorum_cert_valid andalso block_author_valid
                end
        end

    fun validate_vote_offchain (vote: vote) =
        let
            val vote_data = Vote.get_vote_data vote
            val ledger_info = Vote.get_ledger_info vote
            val consensus_data_hash = LedgerInfo.get_consensus_data_hash ledger_info
            val vote_data_hash = HashFunction.calculate_from_bytes (VoteData.serialize vote_data)
        in
            ByteArray.equal consensus_data_hash vote_data_hash
        end

    fun validate_vote (vote: vote) (blsc: persistent_block_store_computer) (opt_logger: logger option) =
        let
            fun timeout_sign_in_validate_proposed_round timeout_sign author_opt round =
                let
                    val proposed_round_ser = Serialization.encode_int_flex round
                in
                    Option.getOpt (Option.map (fn acc => AccountValidation.validate_signature acc
                                                                                          proposed_round_ser
                                                                                          timeout_sign) 
                                           author_opt) 
                              False
                end

            val vote_data = Vote.get_vote_data vote
            val parent_id = BlockInfo.get_id (VoteData.get_parent vote_data)

            val author_guid = Vote.get_author vote
            val persistent_computer = PersistentBlockStoreComputer.get_persistent_computer blsc
            val author_opt = PersistentStateComputer.get_account_by_block_id persistent_computer author_guid parent_id

            val account_found = Option.isSome author_opt

            val ledger_info = Vote.get_ledger_info vote
            val ledger_info_ser = LedgerInfo.serialize ledger_info
            val vote_sign = Vote.get_signature vote

            val sign_valid = Option.getOpt (Option.map (
                                    fn author => AccountValidation.validate_signature author ledger_info_ser vote_sign
                                ) author_opt
                            ) False

            val proposed_round = VoteData.get_proposed_round vote_data
            
            val timeout_sign_opt = Vote.get_timeout_signature vote
            val timeout_sign_valid = Option.getOpt (Option.map 
                    (fn timeout_sign => timeout_sign_in_validate_proposed_round timeout_sign author_opt proposed_round) timeout_sign_opt
                ) True

            val block_store = PersistentBlockStoreComputer.get_blockstore blsc
            val commit_info = LedgerInfo.get_commit_info ledger_info
            val commit_hash = BlockInfo.get_id commit_info
            val commit_block_opt = BlockStore.get_block block_store commit_hash
            val commit_exists = Option.isSome commit_block_opt
            val block_info_empty = Comparators.eq_block_info commit_info (BlockInfo.empty ())
            val _ = Option.map (fn logger =>
                (
                    Logger.info logger ("Vote validation:");
                    Logger.info logger ("Account found: " ^ (Bool.toString account_found));
                    Logger.info logger ("Sign valid: " ^ (Bool.toString sign_valid));
                    Logger.info logger ("Timeout valid: " ^ (Bool.toString timeout_sign_valid));
                    Logger.info logger ("Commit exists: " ^ (Bool.toString commit_exists));
                    Logger.info logger ("Block Info empty: " ^ (Bool.toString block_info_empty))
                )
            ) opt_logger
        in
            account_found andalso
            sign_valid andalso
            timeout_sign_valid andalso
            (commit_exists orelse block_info_empty)
        end

    fun validate_blockstore (blsc: persistent_block_store_computer) validators (opt_logger: logger option) =
        let
            val psc = PersistentBlockStoreComputer.get_persistent_computer blsc
            val block_store = PersistentBlockStoreComputer.get_blockstore blsc
            val blocks_valid = BlockStore.validate_blocks block_store (check_block_author_and_sign psc opt_logger)

            val _ = Option.map (fn logger =>
                (
                    Logger.info logger ("BlockStore validation:");
                    Logger.info logger ("Blocks are valid: " ^ (Bool.toString blocks_valid))
                )
            ) opt_logger

            fun validate_certificates (blsc: persistent_block_store_computer) validators (opt_logger: logger option) =
                let
                    val block_store = PersistentBlockStoreComputer.get_blockstore blsc
                    val psc = PersistentBlockStoreComputer.get_persistent_computer blsc
                    val quorum_cert = BlockStore.get_highest_quorum_cert block_store
                    val commit_cert = BlockStore.get_highest_commit_cert block_store
                    val timeout_cert = BlockStore.get_highest_timeout_cert block_store
                    val quorum_cert_valid = validate_quorum_cert_offchain quorum_cert andalso 
                                            validate_quorum_cert quorum_cert blsc validators
                    val commit_cert_valid = validate_quorum_cert_offchain commit_cert andalso
                                            validate_quorum_cert commit_cert blsc validators
                    val timeout_cert_valid = Option.getOpt (Option.map (fn tc => validate_timeout_cert tc psc validators) timeout_cert) True

                    val _ = Option.map (fn logger =>
                        (
                            Logger.info logger ("Quorum certs are valid: " ^ (Bool.toString quorum_cert_valid));
                            Logger.info logger ("Commit certs are valid: " ^ (Bool.toString commit_cert_valid));
                            Logger.info logger ("Timeout certs are valid: " ^ (Bool.toString timeout_cert_valid))
                        )
                    ) opt_logger
                in
                    quorum_cert_valid andalso
                    commit_cert_valid andalso
                    timeout_cert_valid
                end

            val certs_valid = validate_certificates blsc validators opt_logger

            val _ = Option.map (fn logger =>
                    (
                        Logger.info logger ("Certs are valid: " ^ (Bool.toString certs_valid))
                    )
                ) opt_logger
        in
            blocks_valid andalso certs_valid
        end
end;
datatype transaction_pool = TransactionPool (signed_transaction list)

structure TransactionPool = 
struct
    (****************************** BASE *************************************)
    fun init () =
        TransactionPool []

    fun get_transaction_list (TransactionPool transaction_list) =
        transaction_list

    (****************************** UTILS *************************************)
    
    fun are_account_and_transaction_nonces_equal persistent_block_store_computer (SignedTransaction payload _) =
        let
            val is_user_creation = TransactionPayload.is_user_creation payload
            val transaction_nonce = TransactionPayload.get_nonce payload

            val result = if is_user_creation
                         then transaction_nonce = 0
                         else
                            let
                                val account_id = TransactionPayload.get_from payload
                                val block_store = PersistentBlockStoreComputer.get_blockstore persistent_block_store_computer
                                val block_id = QuorumCert.get_proposed_hash (SyncInfo.get_highest_quorum_cert (BlockStore.get_sync_info block_store))
                                val persistent_state_computer = PersistentBlockStoreComputer.get_persistent_computer persistent_block_store_computer
                                val account = PersistentStateComputer.get_account_by_block_id persistent_state_computer account_id block_id
                            in 
                                Option.getOpt 
                                    (Option.map (fn account => (Account.get_nonce account) = transaction_nonce) account) 
                                    False
                            end
        in
            result
        end

    (* use bigger validation than in spec. note we use only filter and no sort *)
    fun delete_deprecated_transactions persistent_block_store_computer (TransactionPool transaction_list) =
        TransactionPool (List.filter (TxValidation.validate_transaction persistent_block_store_computer) transaction_list)


    (****************************** CUSTOM VALIDATION *************************************)

    (* without nonce validation *)
    fun validate_fetch_transaction (seen : (hash_value set)) signed_transaction =
        let
            val payload = SignedTransaction.get_payload signed_transaction
            val transaction_hash = HashFunction.calculate_from_bytes (TransactionPayload.serialize payload)
            val is_seen = Set.member seen transaction_hash
            val time_validity = TxValidation.validate_transaction_timestamp signed_transaction
        in
            (not is_seen) andalso
            time_validity
        end

    (****************************** ADD *************************************)

    (* sorted list required *)
    fun delete_repetetive_nonce_from_list (signed_transactions : signed_transaction list) =
        let
            (* account_id -> nonce *)
            val max_seen_nonces = Map.empty Guid.compare

            fun iterate_nonce (max_seen_nonces : (guid, int) map) (SignedTransaction payload signs) = 
                let
                    val sender = TransactionPayload.get_from payload
                    val transaction_nonce = TransactionPayload.get_nonce payload
                    val opt_current_nonce = Map.lookup max_seen_nonces sender
                    val are_nonces_same = if (Option.isSome opt_current_nonce)
                                          then transaction_nonce = (Option.valOf opt_current_nonce)
                                          else False
                    (* nonces for account grow *)
                    val upd_max_seen_nonces = Map.insert max_seen_nonces sender transaction_nonce
                in
                    ((not are_nonces_same), upd_max_seen_nonces)
                end

            fun filter_nonces max_seen_nonces signed_transactions =
                case signed_transactions of
                  [] => []
                | hd::tl => (
                                let
                                    val (hd_correct, upd_max_seen) = iterate_nonce max_seen_nonces hd
                                    val validated_tl = filter_nonces upd_max_seen tl
                                in
                                    if hd_correct
                                    then hd::validated_tl
                                    else validated_tl
                                end
                            )
        in
            filter_nonces max_seen_nonces signed_transactions
        end

    (* Problems with optimization. We need queue. *)

    fun sort_transaction_list (transaction_list : signed_transaction list) =
        let
            val accounts_transactions = Map.empty Guid.compare

            fun map_transaction accounts_transactions tx_list = 
                case tx_list of
                    [] => accounts_transactions
                    | hd::tl =>
                        (
                            let
                                val payload = SignedTransaction.get_payload hd
                                val account = TransactionPayload.get_from payload
                                val opt_cur_list = Map.lookup accounts_transactions account
                                val accounts_transactions = Map.insert accounts_transactions
                                                                       account 
                                                                       (hd :: (Option.getOpt opt_cur_list []))
                            in
                                map_transaction accounts_transactions tl
                            end
                        )

            fun comparator (SignedTransaction left_payload _) (SignedTransaction right_payload _) =
                if (TransactionPayload.get_nonce left_payload) = (TransactionPayload.get_nonce right_payload)
                then (TransactionPayload.get_timestamp left_payload) < (TransactionPayload.get_timestamp right_payload)
                else (TransactionPayload.get_nonce left_payload) < (TransactionPayload.get_nonce right_payload)

            fun sort_fun (account, transaction_list) =
                (account, List.sort comparator transaction_list)

            (* filling accounts_transactions *)
            val accounts_transactions = map_transaction accounts_transactions transaction_list

            (* sorting transactions for every account *)
            val accounts_transactions = Map.fromList (Guid.compare) (List.map (sort_fun) (Map.toAscList accounts_transactions))

            (* Probably very ineffective *)
            fun piece_back accounts_transactions tx_list =
                case tx_list of
                  [] => []
                | hd::tl =>
                    (
                        let
                            val payload = SignedTransaction.get_payload hd
                            val account = TransactionPayload.get_from payload 
                            val cur_list = Option.valOf (Map.lookup accounts_transactions account)
                            val result_transaction = List.hd cur_list
                            val upd_accounts_transactions = Map.insert accounts_transactions account (List.drop cur_list 1)
                        in
                            result_transaction::(piece_back upd_accounts_transactions tl)
                        end
                    )
        in
            piece_back accounts_transactions transaction_list
        end
    
    fun add_to_list persistent_block_store_computer (base_transactions : (signed_transaction list)) (new_transactions : signed_transaction list) =
        let
            val filtered_new_transactions = List.filter (TxValidation.validate_transaction persistent_block_store_computer) new_transactions
            val extended_transactions = base_transactions @ filtered_new_transactions
            val sorted_transactions = sort_transaction_list extended_transactions
            val result_transactions = delete_repetetive_nonce_from_list sorted_transactions
        in
            result_transactions
        end

    fun add persistent_block_store_computer transaction_pool (new_transactions : (signed_transaction list)) =
        let
            val updated_transaction_pool = delete_deprecated_transactions persistent_block_store_computer transaction_pool
            val txpool = TransactionPool (add_to_list persistent_block_store_computer 
                                         (get_transaction_list updated_transaction_pool) 
                                          new_transactions)
        in
            txpool
        end

    (****************************** REMOVE *************************************)

    fun remove_from_list (transactions : (signed_transaction list)) (filter : (hash_value set)) =
        let
            val comparator = Set.get_comparator filter
        in
            case transactions of
              [] => ([], Set.empty comparator)
            | hd::tl => 
                let
                    val (upd_transactions, deleted) = remove_from_list tl filter
                    val hd_payload = SignedTransaction.get_payload hd
                    val hd_bytes = TransactionPayload.serialize hd_payload
                    val hd_hash_value = HashFunction.calculate_from_bytes hd_bytes
                    val is_hd_in_filter = Set.member filter hd_hash_value
                in
                    if is_hd_in_filter
                    then (upd_transactions, Set.add deleted hd_hash_value)
                    else (hd::upd_transactions, deleted)
                end
        end

    fun remove persistent_block_store_computer transaction_pool (filter : (hash_value set)) =
        let
            val updated_transaction_pool = delete_deprecated_transactions persistent_block_store_computer transaction_pool
            val (result_transaction_list, deleted) = remove_from_list (get_transaction_list updated_transaction_pool) filter
        in
            (TransactionPool result_transaction_list, deleted)
        end

    (****************************** FETCH *************************************)

    (* copypaste from repetetive deletion *)
    fun fetch_from_filtered_list persistent_block_store_computer transaction_list limit = 
        let
            (* account_id -> nonce *)
            val max_seen_nonces = Map.empty Guid.compare

            fun iterate_nonce max_seen_nonces signed_transaction = 
                let
                    val payload = SignedTransaction.get_payload signed_transaction
                    val sender = TransactionPayload.get_from payload
                    val transaction_nonce = TransactionPayload.get_nonce payload
                    val opt_current_state = Map.lookup max_seen_nonces sender
                    val if_correct_as_first = are_account_and_transaction_nonces_equal persistent_block_store_computer signed_transaction
                    val (was_valid, current_nonce) = Option.getOpt opt_current_state (if_correct_as_first, transaction_nonce - 1(* patch *))
                    val is_next_nonce = (transaction_nonce = current_nonce + 1)
                    val is_valid = was_valid andalso is_next_nonce
                    (* nonces for account grow *)
                    val upd_max_seen_nonces = Map.insert max_seen_nonces sender (is_valid, transaction_nonce)
                in
                    (is_valid, upd_max_seen_nonces)
                end

            fun filter_nonces max_seen_nonces signed_transactions limit =
                if limit <= 0
                then []
                else (
                        case signed_transactions of
                          [] => []
                        | hd::tl => (
                                        let
                                            val (hd_valid, upd_max_seen) = iterate_nonce max_seen_nonces hd
                                        in
                                            if hd_valid
                                            then hd::(filter_nonces upd_max_seen tl (limit - 1))
                                            else filter_nonces upd_max_seen tl limit
                                        end
                                    )
                     )
        in
            filter_nonces max_seen_nonces transaction_list limit
        end

    fun fetch persistent_block_store_computer transaction_pool (limit : int) (seen : (hash_value set)) =
        let
            val updated_transaction_pool = delete_deprecated_transactions persistent_block_store_computer transaction_pool
            val transaction_list = get_transaction_list updated_transaction_pool
            val relevant_transactions = List.filter (validate_fetch_transaction seen) transaction_list
            val fetched_transactions = fetch_from_filtered_list persistent_block_store_computer relevant_transactions limit
        in
            (updated_transaction_pool, fetched_transactions)
        end

end;
(* *
 *  Is raised when given round is lower than highest quorum certificate round
 *
 *  @param round: ```int``` Given round
 *  @param hqc_round: ```int``` The highest quorum certificate round
 *)
exception BlockGeneratorInvalidRound int int;

exception BlockGeneratorPathNotFound;

structure BlockGenerator =
struct
    local
        fun ensure_highest_quorum_cert (sync_info : sync_info) (round : int) =
            let
                val hqc = SyncInfo.get_highest_quorum_cert sync_info
                val hqc_round = QuorumCert.get_proposed_round hqc
            in
                if hqc_round < round then hqc else raise BlockGeneratorInvalidRound round hqc_round
            end
    in
        fun generate_nil_proposal (PersistentBlockStoreComputer blockstore storage state_computer) (round : int) =
            let
                val sync_info = BlockStore.get_sync_info blockstore
                val hqc = ensure_highest_quorum_cert (sync_info) round

                val timestamp = BlockInfo.get_timestamp_usecs (
                    VoteData.get_proposed (
                        QuorumCert.get_vote_data (hqc)
                    )
                )
                val block_data = BlockData.create(round, timestamp, hqc, NilBlock)
                val block = Block.create(block_data, None)
            in
                PersistentBlockStoreComputer.execute_and_insert 
                    (PersistentBlockStoreComputer blockstore storage state_computer) 
                    (block)
            end
        
        fun generate_proposal (PersistentBlockStoreComputer blockstore storage state_computer) 
            (transaction_pool) (block_size : int) (author : guid) (round : int) =
            let
                val sync_info = BlockStore.get_sync_info blockstore
                val hqc = ensure_highest_quorum_cert (sync_info) round
                val hcc = SyncInfo.get_highest_commit_cert sync_info
                
                val root_hash = QuorumCert.get_proposed_hash hcc
                val hqc_proposed_hash = QuorumCert.get_proposed_hash hqc
                val pending_blocks = 
                    case BlockStore.get_blocks_from_path blockstore root_hash hqc_proposed_hash of
                        None => (raise BlockGeneratorPathNotFound)
                      | Some b => b

                val (exclude_signed_transactions : signed_transaction list list) = (
                    List.map 
                    (
                        fn x => case BlockData.get_block_type (Block.get_block_data (ExecutedBlock.get_block x)) of
                            Proposal author payload => payload
                          | _ => []
                    ) 
                    pending_blocks)
                val (exclude_payload : hash_value set) = 
                    List.foldl 
                        (fn set => fn st_lst => Set.add_list set (
                            List.map (fn st => TransactionPayload.hash (SignedTransaction.get_payload st)) st_lst
                        ))
                        (Set.empty ByteArray.compare) 
                        exclude_signed_transactions

                val (updated_transaction_pool, payload) = TransactionPool.fetch (PersistentBlockStoreComputer blockstore storage state_computer) transaction_pool block_size exclude_payload

                val timestamp = Time.current ();
                val block_data = BlockData.create(round, timestamp, hqc, Proposal author payload)
                val block = Block.create(block_data, None)

                val (persistent_block_store_computer', executed_block) = 
                    PersistentBlockStoreComputer.execute_and_insert 
                        (PersistentBlockStoreComputer blockstore storage state_computer) 
                        (block)
            in
                (persistent_block_store_computer', updated_transaction_pool, executed_block)
            end
    end

end;

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
			BlockGeneratorInvalidRound _ _ => "BlockGeneratorInvalidRound"
		  | BlockGeneratorPathNotFound => "BlockGeneratorPathNotFound"
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
			BlockGeneratorInvalidRound v1 v2 => 
				"BlockGeneratorInvalidRound" ^ " " ^ Int.toString v1 ^ " " ^ Int.toString v2
		  | BlockGeneratorPathNotFound => 
				"BlockGeneratorPathNotFound"
		  | _ => raise Exception.Unknown
	)
datatype user_key = UserKey guid keypair

structure UserKey =
struct
    
    fun init id k = UserKey id k

    fun get_id (UserKey id _) = id

    fun get_keys (UserKey _ k) = k

    fun update_id (UserKey _ k) id = UserKey id k

    fun update_keys (UserKey id _) k = UserKey id k

end;
exception SafetyLastVotedRoundTooHigh

structure Safety =
struct

    fun sign_timeout round (UserKey author keys) = Signer.sign (Serialization.encode_int_flex round) keys

    fun sign_block_data (block_data : block_data) (UserKey author keys) = Signer.sign (BlockData.serialize block_data) keys

    fun get_safety_data storage =
        SafetyReader.read storage

    local
        fun construct_ledger_info(quorum_cert, vote_round, vote_data, safety_data) =
            let
                val consensusHash = HashFunction.calculate_from_bytes(VoteData.serialize(vote_data))
                val one_chain_round = QuorumCert.get_parent_round(quorum_cert)
                val two_chain_round = QuorumCert.get_proposed_round(quorum_cert)
            in
                if ((one_chain_round + 1) = two_chain_round) andalso ((two_chain_round + 1) = vote_round) then
                    (
                        LedgerInfo.create(VoteData.get_parent(QuorumCert.get_vote_data(quorum_cert)), consensusHash), 
                        (SafetyData.set_preferred_round safety_data one_chain_round)
                    )
                else
                    (LedgerInfo.create(BlockInfo.empty (), consensusHash), safety_data)
            end
    in 
        fun vote (PersistentBlockStoreComputer block_store storage state_computer) (b : block) (execution_result : state_compute_result) (UserKey author keys) =
            let 
                val safety_data = get_safety_data storage
                val vote_round = Block.get_round(b)

                fun check_if_voted () =
                    if vote_round = SafetyData.get_last_voted_round(safety_data) then
                        SafetyData.get_last_vote safety_data
                    else
                        None

                fun create_vote () =
                    let
                        val cert_round = QuorumCert.get_proposed_round(Block.get_quorum_cert(b));
                    in
                        (
                            if (cert_round >= SafetyData.get_preferred_round(safety_data) andalso 
                                vote_round > SafetyData.get_last_voted_round(safety_data)) then
                                let
                                    val block_info = BlockInfo.create(
                                            vote_round,
                                            (Hashing.from_block b),
                                            (StateComputeResult.get_hash_value(execution_result)),
                                            (StateComputeResult.get_current_version(execution_result)), 
                                            (BlockData.get_timestamp(Block.get_block_data(b)))
                                    )

                                    val vote_data = VoteData.create(
                                            block_info,                
                                            VoteData.get_proposed(QuorumCert.get_vote_data(Block.get_quorum_cert(b)))
                                    )

                                    val (ledger_info, safety_data) = construct_ledger_info(
                                        Block.get_quorum_cert(b), vote_round, vote_data, safety_data
                                    )

                                    val author_sign = Signer.sign (LedgerInfo.serialize(ledger_info)) keys
                                    val res_vote = Some(Vote.create(vote_data, author, ledger_info, author_sign, None))
                                    val storage = SafetyWriter.write storage (
                                                    SafetyData.set_last_voted_round
                                                        (SafetyData.set_last_vote safety_data res_vote)
                                                        vote_round
                                                )
                                in 
                                    (
                                        PersistentBlockStoreComputer block_store storage state_computer,
                                        res_vote
                                    )
                                end
                            else
                                (PersistentBlockStoreComputer block_store storage state_computer, None)
                        )
                    end
            in
                case check_if_voted () of
                    Some vote => (PersistentBlockStoreComputer block_store storage state_computer, Some vote)
                    | None => create_vote ()
            end

        fun process_timeout pbsc (current_round : int) user_key =
            let
                val (PersistentBlockStoreComputer block_store storage state_computer) = pbsc 

                val safety_data = get_safety_data storage
                val last_voted_round = SafetyData.get_last_voted_round safety_data

                fun process_last_vote pbsc safety_data last_vote =
                    if 
                        Vote.get_timeout_signature last_vote <> None
                    then 
                        (pbsc, Some last_vote)
                    else
                        let
                            val timeout_sig = sign_timeout current_round user_key

                            val updated_vote = 
                                Vote.create (
                                    (Vote.get_vote_data last_vote), (Vote.get_author last_vote),
                                    (Vote.get_ledger_info last_vote), (Vote.get_signature last_vote),
                                    (Some timeout_sig)
                                )

                            val updated_safety_data = SafetyData.set_last_vote safety_data (Some updated_vote)
                            val updated_storage = SafetyWriter.write storage updated_safety_data
                        in
                            (PersistentBlockStoreComputer block_store updated_storage state_computer, Some updated_vote)
                        end
            in
                case Int.compare last_voted_round current_round of
                    (* The last vote was created in a previous round. 
                     * RoundManager will generate a nil-block and will vote for it. *)
                    Less => (pbsc, None)
                    (* The last vote was created in some future round.
                     * It must be impossible, but if that occurs some critical
                     * error in the logic occurred. The exception is thrown. *)
                  | Greater => raise SafetyLastVotedRoundTooHigh
                    (* The last vote was created in the same round. If timeout signature
                     * was generated for the vote, timeout already occurred at least once 
                     * and saved vote should be returned. Otherwise, it is the first timeout
                     * in the current round and timeout signature should be added to existing
                     * vote. *)
                  | Equal => (
                        case SafetyData.get_last_vote safety_data of
                            (* TODO: it seems that such situation is impossible to occur, and 
                             *       if we are here there are some errors in the implementation
                             *       logic. So consider raising some exception here. *)
                            None => (pbsc, None)
                            (* There was a vote in the round which we may process and update. *)
                          | Some last_vote => process_last_vote pbsc safety_data last_vote
                  )
            end
    end
end

local
    fun exn_printer e =
        case e of
            SafetyLastVotedRoundTooHigh => "SafetyLastVotedRoundTooHigh"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
datatype synchronization_retrieval_request = TransactionRetrievalRequest int
                                           | BlockRetrievalRequest (hash_value option) hash_value;

datatype synchronizer = Synchronizer logger (guid list) (*sync-commits-size*) int  (*sync-blocks-size*)int;

structure SynchronizerPrivate =
struct
	fun get_logger (Synchronizer logger _ _ _) = logger
	fun get_validators (Synchronizer _ validators _ _) = validators
    fun get_sync_commits_size (Synchronizer _ _ sync_commits_size _) = sync_commits_size
    fun get_sync_blocks_size (Synchronizer _ _ _ sync_blocks_size) = sync_blocks_size
end

structure Synchronizer =
struct
	fun insert_certificates persistent_state sync_info validators logger =
		let
			val highest_quorum_cert = SyncInfo.get_highest_quorum_cert (sync_info)

			val _ = Logger.info
            			logger
            			("Synchronizer.insert_certificates: Inserting quorum_cert.\n")

			val new_persistent_state = PersistentBlockStoreComputer.insert_quorum_cert persistent_state highest_quorum_cert
			val _ = Logger.info
            			logger
            			("Synchronizer.insert_certificates: Validating blockstore.\n")
			val blockstore_valid = Validating.validate_blockstore new_persistent_state validators (Some logger)
		in
			if not blockstore_valid then
				(
				Logger.info
            		logger
            		("Synchronizer.insert_certificates: Blockstore invalid. Returning old PersistentBlockStoreComputer.\n");
				persistent_state
				)
			else
				let
					val _ = Logger.info
								logger
								("Synchronizer.insert_certificates: Blockstore valid. Inserting timeout_cert.\n")
					val highest_timeout_cert = SyncInfo.get_timeout_cert (sync_info)
					val _ = (
						case highest_timeout_cert of 
							None => Logger.info
										logger
										("Synchronizer.insert_certificates: timeout_cert is None. Nothing to insert.\n")
							| Some _ => Logger.info
											logger
											("Synchronizer.insert_certificates: timeout_cert is not None.\n")
					)
					val block_store = (PersistentBlockStoreComputer.get_blockstore new_persistent_state)
					val storage = (PersistentBlockStoreComputer.get_storage new_persistent_state)
					val persistent_block_store = Option.getOpt 
								(Option.map 
									(fn highest_timeout_cert => PersistentBlockStore.insert_timeout_cert (PersistentBlockStore block_store storage) highest_timeout_cert) 
									highest_timeout_cert
									)
								(PersistentBlockStore  block_store storage);
				in
					(PersistentBlockStoreComputer 
						(PersistentBlockStore.get_blockstore persistent_block_store)
						(PersistentBlockStore.get_storage persistent_block_store)
						(PersistentBlockStoreComputer.get_state_computer new_persistent_state)
					)
				end
		end

	fun sync_up_txs_or_blocks persistent_state sync_info logger =
		let
			val _ = Logger.info
            			logger
            			("Synchronizer.sync_up_txs_or_blocks: BlockStoreQCBlockMissing exception occurred while incerting certificates in sync_up. Request transactions or blocks.\n")
			val remote_hcc = SyncInfo.get_highest_commit_cert sync_info
			val remote_commit_info = QuorumCert.get_commit_info remote_hcc
			val remote_round =  BlockInfo.get_round remote_commit_info
			val local_round = StateComputer.commit_round (PersistentBlockStoreComputer.get_state_computer persistent_state)
			val local_version = StateComputer.commit_block_version (PersistentBlockStoreComputer.get_state_computer persistent_state)

			val request = (
				if
					local_round < remote_round
				then
					(Logger.info
						logger
						("Synchronizer.sync_up_txs_or_blocks: Request transactions:\n  version=" ^ Int.toString local_version ^ "\n");
					Some (TransactionRetrievalRequest local_version))
				else
					let
						val remote_hqc = SyncInfo.get_highest_quorum_cert sync_info
						val waypoint = QuorumCert.get_proposed_hash remote_hqc
					in
						(Logger.info
            				logger
            				("Synchronizer.sync_up_txs_or_blocks: Request blocks:\n  parent=None\n  waypoint=" ^ Hex.bytes_to_hex waypoint ^ "\n");	
						Some (BlockRetrievalRequest None waypoint))
					end
			)
		in
			(persistent_state, request)
		end

	fun sync_up persistent_state sync_info synchronizer =
		let
			val logger = SynchronizerPrivate.get_logger synchronizer
			val _ = Logger.info
            			logger
            			("Synchronizer.sync_up: Inserting certificates\n")
			val validators = SynchronizerPrivate.get_validators synchronizer
			val pbsc = insert_certificates persistent_state sync_info validators logger
		in
			(pbsc, None)
		end
		handle (BlockStoreQCBlockMissing _) => sync_up_txs_or_blocks persistent_state sync_info (SynchronizerPrivate.get_logger synchronizer)

	fun process_transactions_retrieval_response persistent_state sync_commits sync_info synchronizer =
		let
			val logger = SynchronizerPrivate.get_logger synchronizer
			val state_computer = PersistentBlockStoreComputer.get_state_computer persistent_state
			val storage = PersistentBlockStoreComputer.get_storage persistent_state
			val _ = Logger.info
            			logger
            			("Synchronizer.process_transactions_retrieval_response: Commit transactions.\n")
			val new_computer = List.foldl (fn persistent_computer => fn (SyncCommit transactions signed_ledger_info) =>
				(	
					Logger.info
            			logger
            			(SignedLedgerInfo.to_string "" signed_ledger_info);
					PersistentStateComputer.commit_transactions persistent_computer transactions signed_ledger_info
				)
			) (PersistentStateComputer state_computer storage) sync_commits

			val local_commit_id = StateComputer.commit_block_id (PersistentStateComputer.get_computer new_computer)
									
			val remote_hcc = SyncInfo.get_highest_commit_cert (sync_info)
			val remote_commit_info = QuorumCert.get_commit_info remote_hcc
			val remote_commit_id = BlockInfo.get_id remote_commit_info

			val _ = Logger.info
            			logger
            			("Synchronizer.process_transactions_retrieval_response: Prepare new PersistentBlockStoreComputer.\n")
			val new_persistent_state = (PersistentBlockStoreComputer 
							(PersistentBlockStoreComputer.get_blockstore persistent_state) 
							(PersistentStateComputer.get_storage new_computer) 
							(PersistentStateComputer.get_computer new_computer)
			)
		in
			if
				ByteArray.equal local_commit_id remote_commit_id
			then
				let
					val _ = Logger.info
            					logger
            					("Synchronizer.process_transactions_retrieval_response: local commit_id is equal to remote commit_id.\n")
					val waypoint = QuorumCert.get_proposed_hash (SyncInfo.get_highest_quorum_cert sync_info)
					val _ = Logger.info
            					logger
            					("Synchronizer.process_transactions_retrieval_response: Request blocks:\n  parent=None\n  waypoint=" ^ Hex.bytes_to_hex waypoint ^ "\n")
				in	
					(new_persistent_state, Some (SyncRequestBlock None waypoint))
				end
			else
				let
					val _ = Logger.info
            					logger
            					("Synchronizer.process_transactions_retrieval_response: local commit_id is not equal to remote commit_id.\n")
            		val _ = Logger.info
            					logger
            					("Local commit_id: " ^ (Hex.bytes_to_hex local_commit_id))
            		val _ = Logger.info
            					logger
            					("Remote commit_id: " ^ (Hex.bytes_to_hex remote_commit_id))
					val remote_round = BlockInfo.get_round remote_commit_info
					val local_round = StateComputer.commit_round (PersistentStateComputer.get_computer new_computer)
				in
					if local_round < remote_round then
						let
							val local_version = StateComputer.commit_block_version (PersistentStateComputer.get_computer new_computer)
						in
							Logger.info
            				logger
            				("Synchronizer.process_transactions_retrieval_response: Request transactions:\n  version=" ^ Int.toString local_version ^ "\n");
							(new_persistent_state, Some (SyncRequestTx local_version))
						end
					else
						(
						Logger.info
            				logger
            				("Synchronizer.process_transactions_retrieval_response: Do not request blocks or transactions.\n");
						(new_persistent_state, None)
						)
				end
		end
		handle exp => (
			let
				val exc_name = Exception.exnName exp
			in
				Logger.warn
            	(SynchronizerPrivate.get_logger synchronizer)
            	("Synchronizer.process_transactions_retrieval_response: An exception " ^ exc_name ^ " occurred, fall back to the previous persistent_state.\n");
			(persistent_state, None)
			end
		)

	fun process_block_retrieval_response persistent_state certed_blocks sync_info synchronizer =
		let
			val logger = SynchronizerPrivate.get_logger synchronizer
			val blocks = List.map (fn (block, opt_cert) => block) certed_blocks
			val remote_hcc = SyncInfo.get_highest_commit_cert sync_info
			val _ = Logger.info
            			logger
            			("Synchronizer.process_block_retrieval_response: Run apply_sync_blocks.\n")
			val new_persistent_state = PersistentBlockStoreComputer.apply_sync_blocks persistent_state blocks (Some remote_hcc)
			val validators = SynchronizerPrivate.get_validators synchronizer
			val _ = Logger.info
            			logger
            			("Synchronizer.process_block_retrieval_response: Validating blockstore.\n")
			val blockstore_valid = Validating.validate_blockstore new_persistent_state validators (Some logger)
		in
			if not blockstore_valid then
				(
				Logger.info
            		logger
            		("Synchronizer.process_block_retrieval_response: Blockstore invalid.\n");
				(persistent_state, None)
				)
			else
				let
					val _ = Logger.info
            					logger
            					("Synchronizer.process_block_retrieval_response: Blockstore valid.\n")
					val local_sync_info = BlockStore.get_sync_info (PersistentBlockStoreComputer.get_blockstore new_persistent_state)
					val local_round = SyncInfo.get_highest_round local_sync_info
					val remote_round = SyncInfo.get_highest_round sync_info
					val remote_hqc = SyncInfo.get_highest_quorum_cert sync_info
					val maybe_remote_block = BlockStore.get_block 
							(PersistentBlockStoreComputer.get_blockstore new_persistent_state) (QuorumCert.get_proposed_hash remote_hqc)
				in
					if local_round < remote_round andalso (Option.isNone maybe_remote_block) then
						let
							val local_hqc = SyncInfo.get_highest_quorum_cert local_sync_info
							val parent_hash = QuorumCert.get_proposed_hash local_hqc
											
							val remote_hqc = SyncInfo.get_highest_quorum_cert sync_info
							val waypoint_hash = QuorumCert.get_proposed_hash remote_hqc
							val _ = Logger.info
            							logger
            							("Synchronizer.process_block_retrieval_response: Request blocks:\n  parent=" ^ Hex.bytes_to_hex parent_hash ^ "\n  waypoint=" ^ Hex.bytes_to_hex waypoint_hash ^ "\n")
						in
							(new_persistent_state, Some (SyncRequestBlock (Some parent_hash) waypoint_hash))
						end
					else
						let
							val _ = Logger.info
            							logger
            							("Synchronizer.process_block_retrieval_response: Inserting certificates.\n")
							val new_persistent_state = insert_certificates new_persistent_state sync_info validators logger
						in
							(new_persistent_state, None)	
						end
						handle _ => (
							Logger.warn
            					logger
            					("Synchronizer.process_block_retrieval_response: An exception occurred.\n");
							(new_persistent_state, None)
						)
				end
		end
		handle exp => (
			let
				val exc_name = Exception.exnName exp
			in
				Logger.warn
            	(SynchronizerPrivate.get_logger synchronizer)
            	("Synchronizer.process_block_retrieval_response: An exception occurred " ^ exc_name);
				(persistent_state, None)
			end
		)

	fun process_transactions_retrieval_request (PersistentBlockStoreComputer block_store storage state_computer) version synchronizer =
		let
			val logger = SynchronizerPrivate.get_logger synchronizer
			val sync_commits_size = SynchronizerPrivate.get_sync_commits_size synchronizer
			val last_commit_block_id = StateComputer.commit_block_id state_computer

			fun include_last_commit_if_needed persistent_computer sync_commits =
				let
					val opt_li_count = PersistentStateComputer.get_commits_count persistent_computer
					val opt_signed_ledger = Option.mapPartial (fn li_count =>
						if li_count > 0 then
							PersistentStateComputer.get_commit_proof persistent_computer (li_count - 1)
						else
							None
					) opt_li_count
				in
					case opt_signed_ledger of
						Some signed_ledger_info => sync_commits @ [(SyncCommit [] signed_ledger_info)]
						| None => sync_commits
				end

			fun collect_commits sync_commits new_version =
				if (List.length sync_commits >= sync_commits_size) then
					sync_commits
				else
					let
						val opt_commit = PersistentStateComputer.get_transactions (PersistentStateComputer state_computer storage) new_version
					in
						if Option.isNone opt_commit then
							include_last_commit_if_needed (PersistentStateComputer state_computer storage) sync_commits
						else
							let
								val (transactions, signed_ledger_info) = Option.valOf opt_commit
								val new_commits = sync_commits @ [(SyncCommit transactions signed_ledger_info)]
								val commit_block_id = BlockInfo.get_id (SignedLedgerInfo.get_commit_info signed_ledger_info)
							in
								if ByteArray.equal last_commit_block_id commit_block_id then
									new_commits
								else
									collect_commits new_commits (new_version + (List.length transactions))
							end
					end

			val commits = collect_commits [] version
			val _ = (
				if (List.null commits) then
					(
						Logger.info
							logger
							("Synchronizer.process_transactions_retrieval_request: No commits to get from version " ^ (Int.toString version) ^ ".\n")
					)
				else
					(
						Logger.info
							logger
							("Synchronizer.process_transactions_retrieval_request: Got commits from version " ^ (Int.toString version) ^ ".\n")
					)
			)
		in
			SyncDataTx commits (BlockStore.get_sync_info block_store)
		end

	fun process_block_retrieval_request (PersistentBlockStoreComputer block_store storage state_computer) opt_parent waypoint synchronizer =
		let
			val logger = SynchronizerPrivate.get_logger synchronizer
			val parent = Option.getOpt (Option.map (Hex.bytes_to_hex) opt_parent) "None"
			val _ = Logger.info
            			logger
            			("Synchronizer.process_block_retrieval_request:\n  waypoint: " ^ Hex.bytes_to_hex waypoint ^ "\n  parent:" ^ parent ^ "\n")
			val sync_info = BlockStore.get_sync_info block_store
		in
			case (BlockStore.get_sync_blocks block_store opt_parent waypoint) of
				Some exec_blocks => SyncDataBlock (List.map (fn exec_block => (ExecutedBlock.get_block exec_block, None)) exec_blocks) sync_info
			  | None => SyncDataBlock [] sync_info
		end
end; (**
 *  @param li_digest_to_votes: ```(hash_value, signed_ledger_info) map``` 
 *    Maps LedgerInfo digest to associated signatures (contained in a partial SignedLedgerInfo).
 *    This might keep multiple LedgerInfos for the current round: either due to different proposals (byzantine behavior)
 *    or due to different NIL proposals (clients can have a different view of what block to extend).
 *  @param maybe_partial_tc: ```(timeout_cert option)``` 
 *    Tracks all the signatures of the votes for the given round.
 *    In case we succeed to aggregate 2f+1 signatures a TimeoutCertificate is formed.
 *  @param author_to_vote: ```(guid, vote) map``` 
 *    Map from author to the vote. This is useful to discard multiple votes.
 *)
datatype pending_votes = PendingVotes ((hash_value, signed_ledger_info) map) (timeout_cert option) ((guid, vote) map);

(**
 *  Type representing a result for insert operation into pending_votes
 *)
datatype pending_votes_insert_result =
    PendingVotes_VoteAdded int | PendingVotes_DuplicateVote | PendingVotes_EquivocateVote |
    PendingVotes_QC quorum_cert | PendingVotes_TC timeout_cert;

structure PendingVotesPrivate =
struct
    fun get_li_digest_to_votes (PendingVotes li_digest_to_votes _ _) = li_digest_to_votes

    fun get_maybe_partial_tc (PendingVotes _ maybe_partial_tc _) = maybe_partial_tc

    fun get_author_to_vote (PendingVotes _ _ author_to_vote) = author_to_vote
end;

structure PendingVotes =
struct
    fun init () = PendingVotes (Map.empty ByteArray.compare) None (Map.empty ByteArray.compare)

    local
        fun get_f n_validators =
            (n_validators - 1) div 3

        fun get_li_digest (vote : vote) =
            let
              val ledger_info = Vote.get_ledger_info vote
              val commit_info_id = BlockInfo.get_id (LedgerInfo.get_commit_info ledger_info)
              val consensus_data_hash = LedgerInfo.get_consensus_data_hash ledger_info
            in
              HashFunction.calculate_from_bytes (ByteArray.concat commit_info_id consensus_data_hash)
            end

    in
        fun check_voting_power n_validators voting_power =
            voting_power >= 2 * (get_f n_validators) + 1

        fun process_vote (PendingVotes li_digest_to_votes maybe_partial_tc author_to_vote) (n_validators : int) (vote : vote) (logger: logger) =
            let
                val author = Vote.get_author vote
                val li_digest = get_li_digest vote

                val _ = Logger.info logger ("PV: start inserting vote from author " ^ (Hex.bytes_to_hex author) ^ "\n")
                val _ = Logger.info logger ("PV: digest to votes length before vote " ^ (Int.toString (List.length (Map.toAscList li_digest_to_votes))) ^ "\n")
                val _ = Logger.info logger ("PV: vote's li_digest " ^ (Hex.bytes_to_hex li_digest) ^ "\n")

                val ledger_info = Vote.get_ledger_info vote
                val commit_info_id = BlockInfo.get_id (LedgerInfo.get_commit_info ledger_info)
                val consensus_data_hash = LedgerInfo.get_consensus_data_hash ledger_info

                val vote_data = Vote.get_vote_data vote
                
                val li_with_signs =
                    case Map.lookup li_digest_to_votes li_digest of
                        None => SignedLedgerInfo.create (ledger_info, Map.empty ByteArray.compare)
                    | Some signs => signs
                val signs = SignedLedgerInfo.get_signatures li_with_signs

                val _ = Logger.info logger ("PV: number of signatures before vote " ^ (Int.toString (List.length (Map.toAscList signs))) ^ "\n")

                val sign = Vote.get_signature vote

                val updated_author_to_vote = Map.insert author_to_vote author vote

                val _ = Logger.info logger ("PV: number of authors after vote applied " ^ (Int.toString (List.length (Map.toAscList updated_author_to_vote))) ^ "\n")

                val updated_signs = Map.insert signs author sign

                val _ = Logger.info logger ("PV: number of signatures after vote " ^ (Int.toString (List.length (Map.toAscList updated_signs))) ^ "\n")

                val updated_li_with_signs = SignedLedgerInfo.set_signatures li_with_signs updated_signs
                val updated_li_digest_to_votes = Map.insert li_digest_to_votes li_digest updated_li_with_signs

                val _ = Logger.info logger ("PV: digest to votes length after vote " ^ (Int.toString (List.length (Map.toAscList updated_li_digest_to_votes))) ^ "\n")

                val voting_power = List.length (Map.toAscList updated_signs)

                val _ = Logger.info logger ("PV: checking cert with validators " ^ (Int.toString n_validators) ^ " current votes " ^ (Int.toString voting_power) ^ "\n")
            in
                if (* Check if we have enough signatures to create a QC *)
                    check_voting_power n_validators voting_power
                then
                    (
                        Logger.info logger ("PV: quorum cert formed\n");
                        ( 
                            PendingVotes updated_li_digest_to_votes maybe_partial_tc updated_author_to_vote, 
                            PendingVotes_QC (QuorumCert.create(vote_data, updated_li_with_signs))
                        )
                    )
                else (* We couldn't form a QC, let's check if we can create a TC *)
                    (
                        Logger.info logger ("PV: no quorum but let's check for timeout cert\n");
                        case Vote.get_timeout_signature vote of
                            (* Vote does not contain timeout signature. No TC could be formed *)
                            None => (PendingVotes updated_li_digest_to_votes maybe_partial_tc updated_author_to_vote, PendingVotes_VoteAdded voting_power)
                            | Some timeout_sign => (
                                let
                                val round = VoteData.get_proposed_round vote_data

                                val _ = Logger.info logger ("PV: timeout signature found for round " ^ (Int.toString round) ^ "\n")

                                val partial_timeout_signs = 
                                    Option.getOpt 
                                        (Option.map (fn tc => TimeoutCert.get_signatures tc) maybe_partial_tc)
                                        (Map.empty ByteArray.compare)

                                val _ = Logger.info logger ("PV: timeout sigs length before vote " ^ (Int.toString (List.length (Map.toAscList partial_timeout_signs))) ^ "\n")

                                val updated_partial_timeout_signs = Map.insert partial_timeout_signs author timeout_sign
                                val updated_partial_tc = TimeoutCert.create (round, updated_partial_timeout_signs)
                                val updated_maybe_partial_tc = Some updated_partial_tc
                                val timeout_voting_power = (List.length (Map.toAscList updated_partial_timeout_signs))
                                val _ = Logger.info logger ("PV: timeout sigs length after vote " ^ (Int.toString timeout_voting_power) ^ "\n")

                                in
                                if
                                    check_voting_power n_validators timeout_voting_power
                                then (* A quorum of signature was reached, a new TC was formed! *)
                                    (
                                        PendingVotes updated_li_digest_to_votes updated_maybe_partial_tc updated_author_to_vote,
                                        PendingVotes_TC updated_partial_tc
                                    )
                                else (* Not enough votes *)
                                    (PendingVotes updated_li_digest_to_votes updated_maybe_partial_tc updated_author_to_vote, PendingVotes_VoteAdded voting_power)
                                end
                            )
                    )
                end

        fun insert (PendingVotes li_digest_to_votes maybe_partial_tc author_to_vote) (n_validators : int) (vote : vote) (logger: logger) = 
        let
            val author = Vote.get_author vote
            val _ = Logger.info logger ("PV: checking existing vote from " ^ (Hex.bytes_to_hex author))
        in
            case Map.lookup author_to_vote author of
                (* Author has already voted for this round *)
                Some previously_seen_vote => (
                    if 
                        ByteArray.compare (get_li_digest vote) (get_li_digest previously_seen_vote) = Equal
                    then
                        (* We've already seen an equivalent vote before *)
                        let
                            fun is_timeout vote = Option.isSome (Vote.get_timeout_signature vote)
                        in
                            if 
                                is_timeout vote andalso not (is_timeout previously_seen_vote)
                            then
                                (* It is a new timeout vote *)
                                process_vote (PendingVotes li_digest_to_votes maybe_partial_tc author_to_vote) (n_validators) (vote) logger
                            else
                                (* It is not a new timeout vote *)
                                (PendingVotes li_digest_to_votes maybe_partial_tc author_to_vote, PendingVotes_DuplicateVote)
                        end
                    else
                        (* We have seen a different vote for the same round *)
                        (PendingVotes li_digest_to_votes maybe_partial_tc author_to_vote, PendingVotes_EquivocateVote)
                )
              | None => (
                    process_vote (PendingVotes li_digest_to_votes maybe_partial_tc author_to_vote) (n_validators) (vote) logger
                )
        end
    end
end;
datatype round_state = RoundState logger Word64.word Word64.word int pending_votes

(**
 *  Type representing a result for process vote function
 *)
datatype process_vote_result = QC quorum_cert | TC timeout_cert;

structure RoundState =
struct

    (**
     *  Query logger from round state
     *
     *  @param round_state: ```round_state``` Round state to be queried
     *
     *  @return ```logger```
     *)
    fun get_logger (RoundState logger _ _ _ _) = logger

    (**
     *  Query init_delay from round state
     *
     *  @param round_state: ```round_state``` Round state to be queried
     *
     *  @return ```Word64.word```
     *)
    fun get_init_delay (RoundState _ init_delay _ _ _ ) = init_delay


    (**
     *  Query base_exp from round state
     *
     *  @param round_state: ```round_state``` Round state to be queried
     *
     *  @return ```Word64.word```
     *)
    fun get_base_exp (RoundState _ _ base_exp _ _ ) = base_exp

    (**
     *  Query current round from round state
     *
     *  @param round_state: ```round_state``` Round state to be queried
     *
     *  @return ```int```
     *)
    fun get_current_round (RoundState _ _ _ current_round _ ) = current_round

    (**
     *  Query pending votes from round state
     *
     *  @param round_state: ```round_state``` Round state to be queried
     *
     *  @return ```pending_votes```
     *)
    fun get_pending_votes (RoundState _ _ _ _ pending_votes) = pending_votes

    (**
     *  Process coming certificates and updates local timer
     *  StartNewRound should be called in the RoundManager module
     *
     *  @param round_state: ```round_state``` Round state to query
     *  @param sync_info: ```sync_info``` Synchronization information that is used to get new round
     *
     *  @returns ```round_state``` Updated round state
     *)
    fun process_certificates (round_state : round_state) (sync_info : sync_info) = 
        let
            val init_delay = get_init_delay round_state
            val base_exp = get_base_exp round_state
            val current_round = get_current_round (round_state)
            val new_round = (SyncInfo.get_highest_round sync_info) + 1
        in
            if 
                new_round <= current_round 
            then
                (round_state, False)
            else
                let
                    val logger = get_logger round_state
                    val round_state' = RoundState logger init_delay base_exp new_round (PendingVotes.init())
                in
                    (round_state', True)
                end
        end

    (**
     *  Process coming votes. 
     *  Generates quorum or timeout certificates if enough votes are accumulated
     *
     *  @param round_state: ```round_state``` Round state to be used in vote processing
     *  @param n_validators: ```int``` Number of validators participating in the consensus
     *  @param v: ```vote``` Vote to be processed
     *
     *  @return ```(round_state, process_vote_result)```
     *)
    fun process_vote (round_state : round_state) (n_validators : int) (v : vote) = 
        let
            val v_data = Vote.get_vote_data v
            val proposed_round = VoteData.get_proposed_round v_data

            val current_round = get_current_round round_state

            val logger = get_logger round_state
            val _ = Logger.info logger ("RoundState: Start processing vote for proposed round " ^ (Int.toString proposed_round))
            val _ = Logger.info logger ("RoundState: current round " ^ (Int.toString current_round))

            val init_delay = get_init_delay round_state
            val base_exp = get_base_exp round_state
        in
            if 
                proposed_round = current_round 
            then
                let
                    val (pending_votes', result) =
                        PendingVotes.insert (get_pending_votes round_state) n_validators v logger

                    val process_vote_result = (
                        case result of
                            PendingVotes_QC quorum_cert => Some (QC quorum_cert)
                          | PendingVotes_TC timeout_cert => Some (TC timeout_cert)
                          | _ => None
                    )
                in
                    ((RoundState logger init_delay base_exp current_round pending_votes'), process_vote_result)
                end
            else (
                (round_state, None)
            )
        end

    (**
     *  Calculates duration of the current round
     *
     *  @param round_state: ```round_state``` Round state to be used when getting current round number
     *  @param sync_info: ```sync_info``` Synchronization information for the current blockstore.
     *   Is used to get the latest commit round
     *
     *  @return ```int``` Duration of given round in microseconds
     *)
    fun get_round_duration (round_state : round_state) (sync_info : sync_info) =
        let
            val init_delay = get_init_delay round_state
            val base_exp = get_base_exp round_state
            val c = get_current_round round_state
            val h = BlockInfo.get_round (
                        LedgerInfo.get_commit_info (SignedLedgerInfo.get_ledger_info (
                            QuorumCert.get_signed_ledger_info (
                                SyncInfo.get_highest_commit_cert sync_info
                            )
                        ))
                    )
            val max_exp = 6

            val delta = 
                    if 
                        h = 0
                    then (* Genesis doesn't require the 3-chain rule for commit, hence start the index at the round after genesis. *)
                        c - 1
                    else
                        if 
                            c - h < 3
                        then 
                            0
                        else
                            c - h - 3
            
            val duration_sec = Double.* init_delay (Math.power_double base_exp (min delta max_exp))
            val duration_mcsec = Double.* duration_sec (Double.fromString "1000000")
        in
            Math.ceil duration_mcsec
        end
end;
(** 
 *  Type represents in memory storage for validators
 *  
 *  @param node_id: ```guid``` Id of current node to be used in consensus
 *  @param validators: ```guid list``` List of peers that are participating in consensus
    @param max_block_size: ```int```
 *)
datatype round_manager = RoundManager logger guid keypair (guid list) int;

(* For integration test purposes only *)
type round_manager_state = (persistent_block_store_computer * transaction_pool * round_state * round_manager);

(**
 *	The structrure defines helper functions for internal usage.
 *	For public interface consider ```RoundManager``` structure.
 *)
structure RoundManagerPrivate =
struct
    fun get_logger (RoundManager logger _ _ _ _) = logger

    fun get_node_id (RoundManager _ node_id _ _ _) = node_id

    fun get_node_key (RoundManager _ _ key _ _) = key

    fun get_validators (RoundManager _ _ _ validators _) = validators

    fun get_max_block_size (RoundManager _ _ _ _ max_block_size) = max_block_size

    fun generate_proposal_msg persistent_block_store_computer transaction_pool (block_size : int) userkey (round : int) logger =
        let
            val ((PersistentBlockStoreComputer block_store' storage' state_computer'), transaction_pool', executed_proposal) = 
                    (BlockGenerator.generate_proposal persistent_block_store_computer transaction_pool block_size (UserKey.get_id userkey) round)

            val proposal = ExecutedBlock.get_block executed_proposal
            val sign = Safety.sign_block_data (Block.get_block_data proposal) userkey
            val signed_proposal = Block.set_sign proposal (Some sign)
            val sync_info = BlockStore.get_sync_info block_store'
            
            val proposal_msg = (ProposalMsg.create (signed_proposal, sync_info))
            
            val _ = Logger.info
            		logger
            		("Generated block for proposal message: \n" ^ (Block.to_string "" proposal) ^ "\n")
        in
            ((PersistentBlockStoreComputer block_store' storage' state_computer'), transaction_pool', proposal_msg)
        end
end;

fun exit status = 
    let
        val result = Word8Array.array 1 (Word8.fromInt status)
    in
        #(exit) "" result
    end;	

fun print_msg round_manager msg = (
    print "  ";
    print "*";
    print (Hex.bytes_to_hex (RoundManagerPrivate.get_node_id round_manager));
    print "* "; print msg; print "\n"
)

structure RoundManager =
struct

    fun get_node_id round_manager = RoundManagerPrivate.get_node_id round_manager

    (**
     *  Queries leader id given round
     *
     *  @param round_manager: ```round_manager``` Round manager
     *  @param round: ```int``` Round number which leader is requested
     *
     *  @return ```int``` Identificator of round leader
     *)
    fun get_leader round_manager round = 
        let
            val validators = RoundManagerPrivate.get_validators round_manager  
        in
            List.nth validators (round mod List.length (validators))
        end

    (**
     *  Query duration of the round.
     *  Wrapper to call corresponding function from 'RoundState' module
     *
     *  @param round: ```int``` Round number which duration is queried
     *
     *  @return ```int``` Duration of given round
     *)
    fun get_round_duration round = RoundState.get_round_duration round
        
    (**
     *  Starts a next round. 
     *  If the node is a leader of the round, proposes a new block to other nodes
     *
     *  @param persistent_block_store_computer_round_state_manager: ```persistent_block_store_computer * round_state * round_manager```
     *      Triple of (blockstore, storage, state computer), round state and round manager
     *
     *  @returns ```persistent_block_store_computer * round_state * round_manager```
     *      Updataed triple of (blockstore, storage, state computer), round state and round manager
     *)
    fun start_new_round 
            ((PersistentBlockStoreComputer block_store storage state_computer), transaction_pool, round_state, round_manager) =
        let
            val storage = Storage.batch_prepare storage
            val persistent_block_store_computer = (PersistentBlockStoreComputer block_store storage state_computer)

            val current_round = RoundState.get_current_round round_state

            val logger = RoundManagerPrivate.get_logger round_manager

            val (((PersistentBlockStoreComputer block_store storage state_computer), transaction_pool, round_state, round_manager), request) =
                if 
                    ByteArray.compare 
                        (RoundManagerPrivate.get_node_id round_manager) 
                        (get_leader round_manager current_round) 
                    <> Equal
                then (
                    Logger.info 
                        logger 
                        ("RoundManager.start_new_round: Round=" ^ Int.toString current_round ^ 
                         " started. The node is not a leader.");
                    ((persistent_block_store_computer, transaction_pool, round_state, round_manager), None)
                )
                else
                    let
                        val (PersistentBlockStoreComputer block_store' storage' state_computer', transaction_pool', proposal_msg) = (
                            RoundManagerPrivate.generate_proposal_msg 
                                persistent_block_store_computer
                                transaction_pool
                                (RoundManagerPrivate.get_max_block_size round_manager)
                                (UserKey.init
                                    (RoundManagerPrivate.get_node_id round_manager)
                                    (RoundManagerPrivate.get_node_key round_manager)
                                )
                                current_round
                                logger
                        )
                    in
                        Logger.info
                            logger
                            ("RoundManager.start_new_round: Round=" ^ Int.toString current_round ^
                             " started. A proposal block has been generated.");
                        (
                            (PersistentBlockStoreComputer block_store' storage' state_computer', transaction_pool', round_state, round_manager),
                            Some (BroadcastEvent (ConsensusProposal proposal_msg))
                        )
                    end
                        
            val storage = Storage.batch_write storage True
        in
            (((PersistentBlockStoreComputer block_store storage state_computer), transaction_pool, round_state, round_manager), request)
        end

    (**
     *  Wrapper to call corresponding function from 'RoundState' module&& npm run test
     *   and update the state of 'round_state'. 
     *  Starts new round instead of RoundState module
     *
     *  @param persistent_block_store_computer_round_state_manager: ```persistent_block_store_computer * round_state * round_manager```
     *      Triple of (blockstore, storage, state computer), round state and round manager
     *  @param sync_info: ```sync_info``` Structure with synchronization information
     *
     *  @returns ```persistent_block_store_computer * round_state * round_manager```
     *      Updataed triple of (blockstore, storage, state computer), round state and round manager
     *)
    fun process_certificates 
            (PersistentBlockStoreComputer block_store storage state_computer, transaction_pool, round_state, round_manager) = 
        let
            val sync_info = BlockStore.get_sync_info block_store
            val (new_round_state, should_new_round_start) = RoundState.process_certificates (round_state) sync_info
            
            val _ = Logger.info
                        (RoundManagerPrivate.get_logger round_manager)
                        ("RoundManager.process_certificates: processing certificates.\n")	

            val updated_state =  (PersistentBlockStoreComputer block_store storage state_computer, transaction_pool, new_round_state, round_manager)
        in
            if 
                should_new_round_start
            then
                let
                    val logger = RoundManagerPrivate.get_logger round_manager

                    val duration = RoundState.get_round_duration new_round_state sync_info
                in
                    Logger.info
                        logger
                        ("RoundManager.process_certificates: the new round with Duration=" ^ Int.toString duration ^
                         " ms should be started.");
                    (updated_state, Some (SetRoundTimer duration))
                end
            else
                (updated_state, None)
        end

    (**
     *  Process proposal message and votes if the proposal is valid.
     *
     *  @param persistent_block_store_computer_round_state_manager: ```persistent_block_store_computer * round_state * round_manager```
     *      Triple of (blockstore, storage, state computer), round state and round manager
     *  @param message: ```proposal_msg``` Proposal message to be processed
     *
     *  @returns ```persistent_block_store_computer * round_state * round_manager```
     *      Updataed triple of (blockstore, storage, state computer), round state and round manager
     *)
    fun process_proposal_msg 
            (message : proposal_msg) 
            (synchronizer : synchronizer)
            ((PersistentBlockStoreComputer block_store storage state_computer), transaction_pool, round_state, round_manager) =
        let
            val storage = Storage.batch_prepare storage

            val logger = RoundManagerPrivate.get_logger round_manager

            val msg_proposal = ProposalMsg.get_proposal message
            
            val _ = Logger.info
            		logger
            		("RoundManage.process_proposal_msg: proposal message fetched: \n" ^ (ProposalMsg.to_string "" message) ^ "\n")
            
            val msg_sync_info = ProposalMsg.get_sync_info message
            
            val msg_proposal_data = Block.get_block_data msg_proposal
            val msg_proposal_round = BlockData.get_round msg_proposal_data

            fun validate_proposal_msg_offchain () =
                let
                    val qc = Block.get_quorum_cert msg_proposal 
                in
                    Validating.validate_quorum_cert_offchain qc andalso
                    Block.is_proposal msg_proposal
                end

            fun validate_proposal_msg (blsc: persistent_block_store_computer) validators =
                let
                    val proposal_signature_validity = 
                        Validating.validate_block msg_proposal blsc validators (Some logger)

                    val proposal_data_quorum_cert_validity =
                        Validating.validate_quorum_cert (BlockData.get_quorum_cert msg_proposal_data) blsc validators
                in
                    proposal_signature_validity andalso 
                    proposal_data_quorum_cert_validity
                end

            fun execute_and_vote 
                    (persistent_block_store_computer, transaction_pool, round_state, round_manager) 
                    (proposal : block) (current_round : int) (msg_proposal_author : guid) = 
                let
                    val (PersistentBlockStoreComputer block_store _ _) = persistent_block_store_computer

                    val ((persistent_block_store_computer', executed_block), _) =
                        ((PersistentBlockStoreComputer.execute_and_insert
                            persistent_block_store_computer
                            proposal),
                         (Logger.info
                    		logger
                    		("RoundManager.process_proposal_msg: message proposal From=" ^ Hex.bytes_to_hex msg_proposal_author ^
                     		 " for Round=" ^ Int.toString msg_proposal_round ^ ". Execution of proposal message block succeeded."))
                        )
                       handle BlockTreeBlockAlreadyExists block_hash =>
                            ((persistent_block_store_computer, Option.valOf (BlockStore.get_block block_store block_hash)),
                            (Logger.warn
                            	logger
                            	("RoundManager.process_proposal_msg: message proposal From=" ^ Hex.bytes_to_hex msg_proposal_author ^
                     		 " for Round=" ^ Int.toString msg_proposal_round ^ ". Execution of proposal message block failed."))
                     	    )

                    val ((PersistentBlockStoreComputer block_store'' storage'' state_computer''), vote) = 
                        Safety.vote 
                            persistent_block_store_computer' 
                            proposal 
                            (ExecutedBlock.get_state_compute_result executed_block)
                            (UserKey.init
                                 (RoundManagerPrivate.get_node_id round_manager)
                                 (RoundManagerPrivate.get_node_key round_manager)
                            )

                  val (request, _) =
                        case vote of
                            None => (None, (Logger.info
                    				logger
                    					("RoundManager.process_proposal_msg: no voting - vote is None \n")))
                          | Some vote =>
                                let
                                    val final_sync_info = BlockStore.get_sync_info block_store''
                                    val vote_msg = VoteMsg.create (vote, final_sync_info)
                                    val vote_aggregator = get_leader round_manager (current_round + 1)
                                    val req = Some ( DirectMsgEvent vote_aggregator (ConsensusVote vote_msg), False )
                                in
                                    (req, (Logger.info
                    		logger
                    		("RoundManager.process_proposal_msg: voting for proposal message block: \n" ^ (VoteMsg.to_string "" vote_msg) ^ "\n")))
                                end
                in
                    ((PersistentBlockStoreComputer block_store'' storage'' state_computer'', transaction_pool, round_state, round_manager), request)
                end

            val ((PersistentBlockStoreComputer block_store' storage' state_computer', transaction_pool', round_state', round_manager'), request) =
                if 
                    not (validate_proposal_msg_offchain ())
                then (
                    Logger.warn
                        logger
                        ("RoundManager.process_proposal_msg: message proposal " ^
                          (
                            if Block.is_proposal msg_proposal 
                            then "From=" ^ Hex.bytes_to_hex (Option.valOf (BlockData.get_author msg_proposal_data))
                            else "without author"
                          ) ^
                         " for Round=" ^ Int.toString msg_proposal_round ^ ". Offchain Validation of QuorumCert failed.");
                    (
                        (* The validation has failed. Return to the Runloop. No further action is required. *)
                        (PersistentBlockStoreComputer block_store storage state_computer, transaction_pool, round_state, round_manager),
                        None
                    )
                ) else
                    let
                        val msg_proposal_author = Option.valOf (BlockData.get_author msg_proposal_data)
                        val validators = RoundManagerPrivate.get_validators round_manager
                        val (synced_persistent_block_store_computer, sync_up_request) =
                            Synchronizer.sync_up (PersistentBlockStoreComputer block_store storage state_computer) 
                                msg_sync_info synchronizer
                    in
                        case sync_up_request of
                            Some (TransactionRetrievalRequest version) => (
                                (* Synchronization of transactions is required. Return the request to Runloop. 
                                    Runloop should recall the proposal message processing when required date arrive. *)
                                (synced_persistent_block_store_computer, transaction_pool, round_state, round_manager),
                                Some ( RpcRequestEvent msg_proposal_author (SyncRequestTx version) None, True )
                            )
                        | Some (BlockRetrievalRequest opt_parent waypoint) => (
                                (* Synchronization of blocks is required. Return the request to Runloop. 
                                    Runloop should recall the proposal message processing when required date arrive. *)
                                (synced_persistent_block_store_computer, transaction_pool, round_state, round_manager),
                                Some ( RpcRequestEvent msg_proposal_author (SyncRequestBlock opt_parent waypoint) None, True )
                            )
                        | None => 
                                let
                                    val ((processed_persistent_block_store_computer, processed_transaction_pool, processed_round_state, processed_round_manager), timer_request) = 
                                        process_certificates (synced_persistent_block_store_computer, transaction_pool, round_state, round_manager)
                                in
                                    case timer_request of
                                        Some timer_data => (
                                            (* New round should be started. Return the request to Runloop. 
                                                Processing of the proposal message will be continued by Runloop. *)
                                                Logger.info
                                            logger
                                            ("RoundManager.process_proposal_msg: timer_request is Some (timer_data), new round should be started.\n");
                                                    ((processed_persistent_block_store_computer, processed_transaction_pool, processed_round_state, processed_round_manager),
                                            Some ( InternalTimerDataEvent timer_data, True ))
                                        )
                                    | None =>
                                        if not (validate_proposal_msg synced_persistent_block_store_computer validators) then
                                            (
                                                Logger.warn
                                                    logger
                                                    ("RoundManager.process_proposal_msg: message proposal From=" ^ Hex.bytes_to_hex msg_proposal_author ^
                                                    " for Round=" ^ Int.toString msg_proposal_round ^ ". Validation failed.");
                                            (
                                            (* The validation has failed. Return to the Runloop. No further action is required. *)
                                            (PersistentBlockStoreComputer block_store storage state_computer, transaction_pool, round_state, round_manager),
                                            None
                                            )
                                            )
                                        else 
                                            let
                                                val _ = Logger.info
                                                    logger
                                                    ("RoundManager.process_proposal_msg: message proposal From=" ^ Hex.bytes_to_hex msg_proposal_author ^
                                                    " for Round=" ^ Int.toString msg_proposal_round ^ ". Validation succeeded.")                                 
                                                val current_round = RoundState.get_current_round processed_round_state
                                            in
                                                if
                                                    current_round <> msg_proposal_round
                                                then (
                                                    Logger.info
                                            logger
                                            ("RoundManager.process_proposal_msg: timer_request is None, current_round is not equal to msg_proposal_round, round timeout event.\n");
                                                        ((processed_persistent_block_store_computer, processed_transaction_pool, processed_round_state, processed_round_manager),
                                                    None)
                                                )
                                                else (
                                                    Logger.info
                                                logger
                                                ("RoundManager.process_proposal_msg: timer_request is None, current_round is equal to msg_proposal_round, execute_and_vote starting.\n");
                                                        execute_and_vote 
                                                        (processed_persistent_block_store_computer, processed_transaction_pool, processed_round_state, processed_round_manager) 
                                                        msg_proposal current_round msg_proposal_author
                                                )
                                            end
                                end
                    end

            val storage'' = Storage.batch_write storage' True
        in
            ((PersistentBlockStoreComputer block_store' storage'' state_computer', transaction_pool', round_state', round_manager'), request)
        end

    (**
     *  Process vote incoming vote message
     *
     *  @param persistent_block_store_computer_round_state_manager: ```persistent_block_store_computer * round_state * round_manager```
     *      Triple of (blockstore, storage, state computer), round state and round manager
     *  @param message: ```vote_msg``` Vote to be processed
     *
     *  @returns ```persistent_block_store_computer * round_state * round_manager```
     *      Updataed triple of (blockstore, storage, state computer), round state and round manager
     *)
    fun process_vote_msg 
            (message : vote_msg) 
            (synchronizer : synchronizer)
            ((PersistentBlockStoreComputer block_store storage state_computer), transaction_pool, round_state, round_manager) = 
        let
            val storage = Storage.batch_prepare storage

            val logger = RoundManagerPrivate.get_logger round_manager

            val msg_vote = VoteMsg.get_vote message
            
             val _ = Logger.info
            		logger
            		("RoundManage.process_vote_msg: vote message fetched: \n" ^ (VoteMsg.to_string "" message) ^ "\n")
            
            val msg_sync_info = VoteMsg.get_sync_info message

            val msg_vote_author = Vote.get_author msg_vote
            
            val msg_vote_data = Vote.get_vote_data msg_vote
            val msg_vote_round = VoteData.get_proposed_round msg_vote_data

            fun process_vote_result (PersistentBlockStoreComputer block_store storage state_computer) (qc : process_vote_result option) =
                case qc of
                    None => (
                        (PersistentBlockStoreComputer block_store storage state_computer)
                    )
                  | Some (QC quorum_cert) => (
                      let
                        val (PersistentBlockStoreComputer block_store' storage' state_computer') = 
                            PersistentBlockStoreComputer.insert_quorum_cert
                                (PersistentBlockStoreComputer block_store storage state_computer) quorum_cert
                      in
                        (PersistentBlockStoreComputer block_store' storage' state_computer')
                      end
                      handle BlockStoreQCBlockMissing _ => (PersistentBlockStoreComputer block_store storage state_computer)
                    )
                  | Some (TC timeout_cert) => (
                      let
                        val (PersistentBlockStore block_store' storage') =
                            PersistentBlockStore.insert_timeout_cert
                                (PersistentBlockStore block_store storage) timeout_cert
                      in
                        (PersistentBlockStoreComputer block_store' storage' state_computer)
                      end
                    )

            val ((PersistentBlockStoreComputer block_store storage state_computer, final_transaction_pool, final_round_state, final_round_manager), request) = 
                if 
                    not (Validating.validate_vote_offchain msg_vote)
                then (
                    Logger.warn
                        logger
                        ("RoundManager.process_vote_msg: vote From=" ^ Hex.bytes_to_hex msg_vote_author ^
                         " for Round=" ^ Int.toString msg_vote_round ^ ". Offchain Validation failed.");
                    (* The validation has failed. Return to the Runloop. No further action is required. *)
                    ((PersistentBlockStoreComputer block_store storage state_computer, transaction_pool, round_state, round_manager), None)
                ) else
                    let
                        val validators = RoundManagerPrivate.get_validators round_manager
                        val (synced_persistent_block_store_computer, sync_up_request) =
                            Synchronizer.sync_up (PersistentBlockStoreComputer block_store storage state_computer) 
                                msg_sync_info synchronizer
                    in
                            case sync_up_request of
                                Some (TransactionRetrievalRequest version) => (
                                    (* Synchronization of transactions is required. Return the request to Runloop. 
                                        Runloop should recall the proposal message processing when required date arrive. *)
                                    (synced_persistent_block_store_computer, transaction_pool, round_state, round_manager),
                                    Some ( RpcRequestEvent msg_vote_author (SyncRequestTx version) None, True )
                                )
                            | Some (BlockRetrievalRequest opt_parent waypoint) => (
                                    (* Synchronization of blocks is required. Return the request to Runloop. 
                                        Runloop should recall the proposal message processing when required date arrive. *)
                                    (synced_persistent_block_store_computer, transaction_pool, round_state, round_manager),
                                    Some ( RpcRequestEvent msg_vote_author (SyncRequestBlock opt_parent waypoint) None, True )
                                )
                            | None =>
                                    let
                                        val ((processed_persistent_block_store_computer, processed_transaction_pool, processed_round_state, processed_round_manager), timer_request) = 
                                            process_certificates (synced_persistent_block_store_computer, transaction_pool, round_state, round_manager)
                                    in
                                        case timer_request of
                                            Some timer_data => (
                                                (* New round should be started. Return the request to Runloop. 
                                                    Processing of the vote message will be continued by Runloop. *)
                                                Logger.info
                                                    logger
                                                    ("RoundManager.process_proposal_msg: timer_request is Some (timer_data), new round should be started.\n");
                                                (
                                                    (processed_persistent_block_store_computer, processed_transaction_pool, processed_round_state, processed_round_manager),
                                                    Some ( InternalTimerDataEvent timer_data, True )
                                                )
                                            )
                                        | None =>
                                            if not (Validating.validate_vote msg_vote synced_persistent_block_store_computer (Some logger)) then
                                            (
                                                Logger.warn
                                                    logger
                                                    ("RoundManager.process_vote_msg: vote From=" ^ Hex.bytes_to_hex msg_vote_author ^
                                                    " for Round=" ^ Int.toString msg_vote_round ^ ". Validation failed.");
                                                (* The validation has failed. Return to the Runloop. No further action is required. *)
                                                ((PersistentBlockStoreComputer block_store storage state_computer, transaction_pool, round_state, round_manager), None)
                                            )
                                            else
                                                let
                                                    val _ = Logger.info
                                                            logger
                                                            ("RoundManager.process_vote_msg: timer_request is None.\n")
                                                
                                                    val n_validators = List.length (RoundManagerPrivate.get_validators processed_round_manager)

                                                    val (vote_processed_round_state, qc) = RoundState.process_vote processed_round_state n_validators msg_vote
                                                    
                                                    val vote_processed_persistent_block_store_computer = 
                                                        process_vote_result processed_persistent_block_store_computer qc

                                                    val _ = Logger.info
                                                                logger
                                                                ("RoundManager.process_vote_msg: vote from vote message applied")

                                                    val ((final_persistent_block_store_computer, final_transaction_pool, final_round_state, final_round_manager), final_timer_requiest) =
                                                        process_certificates (vote_processed_persistent_block_store_computer, processed_transaction_pool, vote_processed_round_state, processed_round_manager)
                                                in
                                                    case final_timer_requiest of
                                                        Some timer_data => (
                                                            Logger.info
                                                                logger
                                                                ("RoundManager.process_vote_msg: final_timer_request is Some (timer_data), new round should be started.\n");
                                                            (
                                                                (final_persistent_block_store_computer, final_transaction_pool, final_round_state, final_round_manager),
                                                                Some ( InternalTimerDataEvent timer_data, False )
                                                            )
                                                        )
                                                    | None => (
                                                        Logger.info
                                                            logger
                                                            ("RoundManager.process_vote_msg: final_timer_request is None, round timeout event.\n");
                                                        (
                                                            (final_persistent_block_store_computer, final_transaction_pool, final_round_state, final_round_manager),
                                                            None
                                                        )
                                                    )
                                                end
                                    end
                    end

            val storage = Storage.batch_write storage True
        in
            ((PersistentBlockStoreComputer block_store storage state_computer, final_transaction_pool, final_round_state, final_round_manager), request)
        end

    (**
     *  Process timeout event came from 'RoundState' module. 
     *  Starts next round
     *
     *  @param persistent_block_store_computer_round_state_manager: ```persistent_block_store_computer * round_state * round_manager```
     *      Triple of (blockstore, storage, state computer), round state and round manager
     *
     *  @returns ```persistent_block_store_computer * round_state * round_manager```
     *      Updataed triple of (blockstore, storage, state computer), round state and round manager
     *)
    fun process_local_timeout (pbsc, transaction_pool, round_state, round_manager) = 
        let
            fun generate_nil_proposal_vote pbsc (round : int) user_key =
                let
                    val (generated_pbsc, executed_nil_proposal) = 
                            BlockGenerator.generate_nil_proposal pbsc round
                in
                    Safety.vote 
                        generated_pbsc
                        (ExecutedBlock.get_block executed_nil_proposal) 
                        (ExecutedBlock.get_state_compute_result executed_nil_proposal)
                        user_key
                end

            fun create_vote_msg (PersistentBlockStoreComputer block_store _ _) vote =
                VoteMsg.create (vote, (BlockStore.get_sync_info block_store) )

            val PersistentBlockStoreComputer block_store storage state_computer = pbsc

            val storage = Storage.batch_prepare storage

            val user_key = 
                UserKey.init (RoundManagerPrivate.get_node_id round_manager) (RoundManagerPrivate.get_node_key round_manager)
            val current_round = RoundState.get_current_round round_state

            val (processed_pbsc, processed_vote_opt) = Safety.process_timeout pbsc current_round user_key
            val (final_pbsc, final_vote_opt) =
                case processed_vote_opt of
                    None => generate_nil_proposal_vote processed_pbsc current_round user_key
                  | Some vote => (processed_pbsc, Some vote)
            
            val vote_msg_opt = Option.map (create_vote_msg final_pbsc) final_vote_opt
                
            val (PersistentBlockStoreComputer final_block_store final_storage final_state_computer) = final_pbsc
            val written_storage = Storage.batch_write final_storage True
            
            val final_state = (PersistentBlockStoreComputer final_block_store written_storage final_state_computer, transaction_pool, round_state, round_manager)
        in
            case vote_msg_opt of
                None => (final_state, None)
              | Some vote_msg => 
                    (
                        final_state,
                        Some ( BroadcastEvent (ConsensusVote vote_msg) )
                    )
        end
end
exception MsgPrefixInvalidSerialization byte_array

exception MsgTypeInvalidSerialization byte_array

exception InvalidMessage byte_array

exception MessageInvalidLength byte_array int

exception WronPingPong byte_array

structure MsgPrefix =
struct

    fun serialize msg_prefix =
        case msg_prefix of
          DirectMsg       => Serialization.encode_int8 0
        | RpcRequest id   => ByteArray.from_list (
                                 ByteArray.to_list(Serialization.encode_int8 1)  @
                                 ByteArray.to_list(Serialization.encode_int_flex id)
                             )
    
    fun deserialize serial = 
        let
            val (prefix, prefix_len) = Serialization.decode_int8 serial
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) prefix_len)
        in
            case prefix of
              0 => (DirectMsg, prefix_len)
            | 1 => let
                       val (id, id_len) = Serialization.decode_int_flex upd_ser
                       val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) id_len)
                   in
                       (RpcRequest id, prefix_len + id_len)
                   end
            | _ => raise MsgPrefixInvalidSerialization serial
        end

end

structure MsgType =
struct

    fun serialize msg_type =
        case msg_type of
          Discovery _          => Serialization.encode_int8 0
        | ConnectionInit _     => Serialization.encode_int8 1
        | Connection _         => Serialization.encode_int8 2
        | ConsensusProposal _  => Serialization.encode_int8 3
        | ConsensusVote _      => Serialization.encode_int8 4
        | SyncRequestBlock _ _ => Serialization.encode_int8 5
        | SyncRequestTx _      => Serialization.encode_int8 6
        | SyncDataBlock _ _    => Serialization.encode_int8 7
        | SyncDataTx _ _      => Serialization.encode_int8 8
        | Ping                 => Serialization.encode_int8 9
        | Pong                 => Serialization.encode_int8 10

    fun deserialize serial =
        let
            val (m_type, m_type_len) = Serialization.decode_int8 serial
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) m_type_len)
        in
            case m_type of
               0 => (RecvDiscovery        , m_type_len)
            |  1 => (RecvConnectionInit   , m_type_len)
            |  2 => (RecvConnection       , m_type_len)
            |  3 => (RecvConsensusProposal, m_type_len)
            |  4 => (RecvConsensusVote    , m_type_len)
            |  5 => (RecvSyncRequestBlock , m_type_len)
            |  6 => (RecvSyncRequestTx    , m_type_len)
            |  7 => (RecvSyncDataBlock    , m_type_len)
            |  8 => (RecvSyncDataTx       , m_type_len)
            |  9 => (RecvPing             , m_type_len)
            | 10 => (RecvPong             , m_type_len)
            |  _ => raise MsgTypeInvalidSerialization serial
        end
end

structure MsgLen =
struct
    
    fun serialize msg_len = Serialization.encode_int32 msg_len

    fun deserialize serial = Serialization.decode_int32 serial

end

structure MessageParser =
struct

    fun serialize m_prefix m_type =
        let
            fun serialize_msg m_type = 
                let
                    val ser_type = MsgType.serialize m_type
                    val content = 
                        case m_type of
                          Discovery node_data_set => NodeDataSet.serialize node_data_set
                        | ConnectionInit msg => Serialization.encode_byte_array msg
                        | Connection msg => Serialization.encode_byte_array msg
                        | ConsensusProposal proposal_msg => ProposalMsg.serialize proposal_msg
                        | ConsensusVote vote_msg => VoteMsg.serialize vote_msg
                        | SyncRequestBlock h1 h2 => 
                              ByteArray.concat
                                  (Serialization.encode_option (Serialization.encode_byte_array) h1)
                                  (Serialization.encode_byte_array(h2))
                        | SyncRequestTx version => Serialization.encode_int_flex version
                        | SyncDataBlock blocks synchronize_info => 
                              ByteArray.concat
                                  (
                                  Serialization.encode_list (
                                      Serialization.encode_tuple2
                                      (Block.serialize)
                                      (Serialization.encode_option (QuorumCert.serialize))
                                      ) blocks
                                  )
                                  (SyncInfo.serialize synchronize_info)
                        | SyncDataTx sync_commits synchronize_info => 
                              ByteArray.from_list (
                                  ByteArray.to_list(Serialization.encode_list (SyncCommit.serialize) sync_commits) @
                                  ByteArray.to_list(SyncInfo.serialize synchronize_info)
                              )
                        | Ping => Word8Array.array 0 (Word8.fromInt 0)
                        | Pong => Word8Array.array 0 (Word8.fromInt 0)
                in
                    ByteArray.concat ser_type content
                end

            val msg_prefix = MsgPrefix.serialize m_prefix
            val msg_content = serialize_msg m_type
            val msg_len = MsgLen.serialize((Word8Array.length msg_prefix) + (Word8Array.length msg_content))             
        in
            ByteArray.from_list (
                ByteArray.to_list(msg_len)     @
                ByteArray.to_list(msg_prefix)  @
                ByteArray.to_list(msg_content)
            )
        end

    fun deserialize serial =
        let
            fun deserialize_msg upd_ser =
                let
                    val (m_type, m_type_len) = MsgType.deserialize upd_ser
                    val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) m_type_len)
                in 
                    case m_type of
                      RecvDiscovery => 
                          let
                              val (deserial, deserial_len) = NodeDataSet.deserialize upd_ser
                          in
                              (Discovery deserial, m_type_len + deserial_len)
                          end
                    | RecvConnectionInit => 
                          let
                              val (deserial, deserial_len) = 
                                  Serialization.decode_byte_array 1 upd_ser
                          in
                              (ConnectionInit deserial, m_type_len + deserial_len)
                          end
                    | RecvConnection => 
                          let
                              val (deserial, deserial_len) = 
                                  Serialization.decode_byte_array 1 upd_ser
                          in
                              (Connection deserial, m_type_len + deserial_len)
                          end
                    | RecvConsensusProposal =>
                          let
                              val (deserial, deserial_len) = ProposalMsg.deserialize upd_ser
                          in
                              (ConsensusProposal deserial, m_type_len + deserial_len)
                          end
                    | RecvConsensusVote =>
                          let
                              val (deserial, deserial_len) = VoteMsg.deserialize upd_ser
                          in
                              (ConsensusVote deserial, m_type_len + deserial_len)
                          end
                    | RecvSyncRequestBlock =>
                          let
                              val (h1, h1_len) = Serialization.decode_option (Serialization.decode_byte_array (HashFunction.size())) upd_ser
                              val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) h1_len)
                              val (h2, h2_len) = Serialization.decode_byte_array (HashFunction.size()) upd_ser
                          in
                              (SyncRequestBlock h1 h2, m_type_len + h1_len + h2_len)
                          end
                    | RecvSyncRequestTx =>
                          let
                              val (deserial, deserial_len) = Serialization.decode_int_flex upd_ser
                          in
                              (SyncRequestTx deserial, m_type_len + deserial_len)
                          end
                    | RecvSyncDataBlock =>
                          let
                              val (blocks, blocks_len) =
                                  Serialization.decode_list
                                      (Serialization.decode_tuple2
                                          (Block.deserialize) 
                                          (Serialization.decode_option (QuorumCert.deserialize))
                                      ) upd_ser
                              val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) blocks_len)
                              val (synchronize_info, synchronize_info_len) = SyncInfo.deserialize upd_ser
                          in
                              (SyncDataBlock blocks synchronize_info, m_type_len + blocks_len + synchronize_info_len)
                          end
                    | RecvSyncDataTx =>
                          let
                              val (sync_commits, sync_commits_len) =
                                  Serialization.decode_list (SyncCommit.deserialize) upd_ser
                              val upd_ser =
                                  ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) sync_commits_len)
                              val (synchronize_info, synchronize_info_len) = SyncInfo.deserialize upd_ser
                          in
                              (SyncDataTx sync_commits synchronize_info,
                               m_type_len + sync_commits_len + synchronize_info_len)
                          end
                    | RecvPing => (Ping, m_type_len)
                    | RecvPong => (Pong, m_type_len)
                    handle _ => raise InvalidMessage upd_ser
                end 

            fun check_len upd_ser m_len m_len_len data_len =
                if
                    m_len > data_len (* We don't have enough bytes for deserialization *)
                then
                    (None, 0)
                else (* We have enough bytes for deserialization *)
                    let
                        val (m_prefix, m_prefix_len) = MsgPrefix.deserialize upd_ser
                        val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) m_prefix_len)

                        val (m_content, m_content_len) = deserialize_msg upd_ser
                        val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) m_content_len)
                    in
                        if
                            (m_prefix_len + m_content_len) <> m_len (* We processed incorrect number of bytes for deserialization *)
                        then
                            raise MessageInvalidLength serial m_len
                        else
                            (Some (m_prefix, m_content), m_len_len + m_prefix_len + m_content_len)
                    end

            fun check_empty serial data_len =
                if (data_len < 4) then (None, 0)
                else
                    let
                        val (m_len, m_len_len) = MsgLen.deserialize serial
                        val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) m_len_len)
                        val rest_len = Word8Array.length upd_ser
                    in
                        check_len upd_ser m_len m_len_len rest_len
                    end
            val data_len = Word8Array.length serial
        in
            check_empty serial data_len
        end;

end;

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
		    MsgPrefixInvalidSerialization _ => "MsgPrefixInvalidSerialization"
          | MsgTypeInvalidSerialization _ => "MsgTypeInvalidSerialization"
          | InvalidMessage _ => "InvalidMessage"
          | MessageInvalidLength _ _ => "MessageInvalidLength"
          | WronPingPong _ => "WronPingPong"
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
		    MsgPrefixInvalidSerialization v1 => 
                "MsgPrefixInvalidSerialization" ^ " " ^ Hex.bytes_to_hex v1
          | MsgTypeInvalidSerialization v1 => 
                "MsgTypeInvalidSerialization" ^ " " ^ Hex.bytes_to_hex v1
          | InvalidMessage v1 => 
                "InvalidMessage" ^ " " ^ Hex.bytes_to_hex v1
          | MessageInvalidLength v1 v2 => 
                "MessageInvalidLength" ^ " " ^ Hex.bytes_to_hex v1 ^ " " ^ Int.toString v2
          | WronPingPong v1 => 
                "WronPingPong" ^ " " ^ Hex.bytes_to_hex v1
		  | _ => raise Exception.Unknown
	)
datatype connection_status = Connecting | Handshaking | Ready | Unknown

(**
 *  Exception raises when trying to handle the node which is not in the ConnectionNodeSet
 * 
 *  @param node_id: ```guid```
 *)
exception ConnectionManagerMissingConnection guid

(**
 *  Exception raises when trying to handle the node which is still connecting.
 *
 *  @param node_id: ```guid```
 *)
exception ConnectionManagerIsConnecting guid

structure ConnectionManager =
struct

    fun get_connection_status network_state node_id = 
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state
        in
            case ConnectedNodeSet.search connected_node_set node_id of
                None => Unknown
              | Some connected_node_info => (
                    case ConnectedNodeInfo.get_fd_opt connected_node_info of
                        None => Connecting
                      | Some fd => Ready
              )
        end

    fun process_connection (network_state : network_state) (known_node_info : known_node_info) (fd : int) =
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state

            val node_id = KnownNodeInfo.get_id known_node_info
            val connected_node_info = ConnectedNodeInfo.set_fd (ConnectedNodeInfo.init node_id) fd
        in
            NetworkState.set_connected_node_set network_state (ConnectedNodeSet.append connected_node_set connected_node_info)
        end

    fun on_connect (network_state : network_state) (connected_node_info : connected_node_info) (fd : int) =
        let
            fun update connected_node_set =
                ConnectedNodeSet.update connected_node_set (ConnectedNodeInfo.set_fd connected_node_info fd)
        in
            NetworkState.map_to_connected_node_set network_state update
        end

(* fun handshake_initiation network_state connect_info own_info = 
    (Word8Array.array 1 (Word8.fromInt 0), network_state) *)

(* fun process_handshake network_state known_node_info fd got_ciphertext =
    (Word8Array.array 1 (Word8.fromInt 0), network_state) *)

(* fun process_handshake_response network_state connect_info handshake_data got_ciphertext =
    (True, network_state) *)

    fun connection network_state known_node_info =
        let
            val node_id = KnownNodeInfo.get_id known_node_info
            val address = KnownNodeInfo.get_address known_node_info
            val port = KnownNodeInfo.get_port known_node_info
            
            val connected_node_info = ConnectedNodeInfo.init node_id

            val connected_node_set = NetworkState.get_connected_node_set network_state
            val new_connected_node_set = ConnectedNodeSet.append connected_node_set connected_node_info
        in
            (SockAddrIn address port, NetworkState.set_connected_node_set network_state new_connected_node_set)
        end

    fun remove (network_state : network_state) (node_id : guid) =
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state
        in
            NetworkState.set_connected_node_set network_state (ConnectedNodeSet.remove connected_node_set node_id)
        end

(* fun check_connection network_state = 
    let
        val conn_nodes_info = NetworkState.get_connected_node_set network_state
        val event_status = []
        fun walk conn_nodes_info event_status network_state =
            case list_info of
              [elem] => let
                            val conn_status = ConnectedNodeInfo.get_conn_status elem
                            val fd = ConnectedNodeInfo.get_fd elem
                        in
                            if conn_status = NoConnection orelse conn_status = Unknown then
                                if fd > 0 then
                                    (event_status @ [1], network_state)
                                else
                                    (event_status @ [0], network_state)
            | (h::t) => let
                            val conn_status = ConnectedNodeInfo.get_conn_status h
                            val fd = ConnectedNodeInfo.get_fd h
                        in
                            if conn_status = NoConnection orelse conn_status = Unknown then
                                if fd > 0 then
                                    walk t (event_status @ [1]) network_state
                                else
                                    walk t (event_status @ [0]) network_state
    in
        walk info [] network_state
    end; *)

(* fun encrypt network_state account_id msg =
    let
        val conn_info = NetworkState.get_connected_node_set network_state
        val node_info = ConnectedNodeSet.search conn_info account_id
        fun process network_state network_node account_id msg =
            case network_node of
              None => raise NoConnection account_id
            | Some info => let
                               val send_key = ConnectNodeInfo.get_send_key info
                           in
                               case send_key of
                                 None then raise NoNoiseConnection accound_id;
                               | Some key (Noise.encrypt key msg, network_state)
                           end
    in
        process network_node account_id msg
    end; *)

(* fun decrypt network_state account_id msg =
    let
        val conn_info = NetworkState.get_connected_node_set network_state
        val node_info = ConnectedNodeSet.search conn_info account_id
        fun check_info network_node account_id =
            case network_node of
              None => raise NoConnection account_id
            | Some info => info
        fun check_key network_node account_id =
            let 
                val recv_key = ConnectNodeInfo.get_recv_key network_node
            in
                case recv_key of
                  None => raise NoNoiseConnection account_id
                | Some(key) => key
            end
        fun process network_state network_node account_id msg = 
            let
                val node_info = check_info network_node account_id
                val recv_key = check_key node_info account_id
                val cur_num = IOBuffer.size msg
                val n = cur_num - cur_num mod Noise.ct_size()
                val blocks = IOBuffer.read msg n
                val iob = IOBuffer.init n n
            in
                (n, IOBuffer.write iob (Noise.decrypt recv_key blocks), network_state)
            end
    in
        process network_state account_id msg
    end; *)

    fun send (network_state : network_state) (node_id : guid) (msg : byte_array) =
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state
            val connected_node_info_opt = ConnectedNodeSet.search connected_node_set node_id
        in
            case connected_node_info_opt of
                None => raise ConnectionManagerMissingConnection node_id
              | Some connected_node_info => (
                let
                    val fd_opt = ConnectedNodeInfo.get_fd_opt connected_node_info
                in
                    case fd_opt of
                        None => raise ConnectionManagerIsConnecting node_id
                      | Some fd => (msg, fd, network_state)
                end
              )
        end

    fun recv (network_state : network_state) (node_id : guid) (msg_buff : io_buffer) =
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state
            val connected_node_info_opt = ConnectedNodeSet.search connected_node_set node_id
        in
            case connected_node_info_opt of
                None => raise ConnectionManagerMissingConnection node_id
              | Some connected_node_info => (
                let
                    val msg_size = IOBuffer.size msg_buff
                    val msg = IOBuffer.read msg_buff msg_size
                    
                    val internal_buff = ConnectedNodeInfo.get_io_buff connected_node_info
                in
                    IOBuffer.write internal_buff msg;
                    (msg_size, internal_buff, network_state)
                end
              )
        end

    fun broadcast network_state msg =
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state
            
            val filtered_connected_node_list = 
                List.filter 
                    (fn info => Option.isSome (ConnectedNodeInfo.get_fd_opt info))
                    (ConnectedNodeSet.to_list connected_node_set)

            (* val info = Set.to_list(ConnectNodeInfo.import())
            val cts = []
            fun walk list_info cts network_state =
                let
                    val account_id = ConnectNodeInfo.id elem
                    val (ct, n_state) = encrypt network_state account_id msg
                in
                    case list_info of
                      [elem] => let
                                    val account_id = ConnectNodeInfo.id elem
                                    val (ct, n_state) = encrypt network_state account_id msg
                                in
                                    (cts @ [(ct, account_id)], n_state)
                                end
                    | (h::t) => walk t (cts @ [(ct, account_id)]) n_state
                end *)
        in
            (*  As we filtered connected_node_info's without file descriptor specified, 
             *  it is safe to call `get_fd` function
             *
             *  TODO: encrypt the message send
             *)
            (List.map (fn info => (msg, ConnectedNodeInfo.get_fd info)) filtered_connected_node_list, network_state)
        end

    fun get_connected_node_ids network_state =
        let
            val connected_node_set = NetworkState.get_connected_node_set network_state
            
            val filtered_connected_node_list = 
                List.filter 
                    (fn info => Option.isSome (ConnectedNodeInfo.get_fd_opt info))
                    (ConnectedNodeSet.to_list connected_node_set)
        in
            List.map ConnectedNodeInfo.get_id filtered_connected_node_list
        end
end

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
		    ConnectionManagerMissingConnection _ => "ConnectionManagerMissingConnection"
          | ConnectionManagerIsConnecting _ => "ConnectionManagerIsConnecting"
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
		    ConnectionManagerMissingConnection v1 => 
                "ConnectionManagerMissingConnection" ^ " " ^ Hex.bytes_to_hex v1
          | ConnectionManagerIsConnecting v1 => 
                "ConnectionManagerIsConnecting" ^ " " ^ Hex.bytes_to_hex v1
		  | _ => raise Exception.Unknown
	)
(* Type represents a function in round manager that may be required to call back. *)
type callback_function = (round_manager_state -> (round_manager_state * event_request option))

(**
 *  @param node_id `guid`: the id of the current node.
 *  @param logger `logger`: a logger that should be used
 *      to journal occurring on runloop events.
 *  @param internal_pipe_read_fd `int`: a descriptor where 
 *      internal writings can be read from.
 *  @param internal_pipe_write_fd `int`: a descriptor where
 *      inernal writings can be written into.
 *  @param round_timer_fd_opt `int option`: a descriptor
 *      that refers to the round timer.
 *  @param fd_to_account_id `(int, guid) map`: a mapping from
 *      a file descriptor to the node id that the descriptor
 *      connects to.
 *  @param rpc_callbacks `((guid * int), callback_function) map`:
 *      a mapping from the node id and an rpc id to the
 *      function that should be called after the answer will be 
 *      processed.
 *  @param id_to_on_connect_queue `(guid, (out_event * callback_function option) list) map`:
 *      a mapping from the node id to the list of events that should be processed
 *      when the connection will be established.
 *  @param cur_iteration_internal_messages `byte_array list`:
 *      a list of messages that should be written into internal_pipe_write_fd after current
 *      poll iteration will be finished.
 *)
datatype runloop = 
    Runloop
        guid
        logger 
        int
        int
        (int option)
        ((int, guid) map)
        (((guid * int), callback_function) map)
        ((guid, (out_event * callback_function option) list) map)
        (byte_array list)

structure RunloopType =
struct
    fun init node_id logger internal_pipe_read_fd internal_pipe_write_fd = 
        Runloop 
            node_id 
            logger 
            internal_pipe_read_fd 
            internal_pipe_write_fd
            None
            (Map.empty Int.compare)
            (Map.empty (Pair.compare Guid.compare Int.compare))
            (Map.empty Guid.compare)
            []

    fun get_node_id (Runloop node_id _ _ _ _ _ _ _ _) = node_id
    fun get_logger (Runloop _ logger _ _ _ _ _ _ _) = logger
    fun get_internal_pipe_read_fd (Runloop _ _ internal_pipe_read_fd _ _ _ _ _ _) = 
        internal_pipe_read_fd
    fun get_internal_pipe_write_fd (Runloop _ _ _ internal_pipe_write_fd _ _ _ _ _) = 
        internal_pipe_write_fd
    fun get_round_timer_fd_opt (Runloop _ _ _ _ round_timer_fd_opt _ _ _ _) = 
        round_timer_fd_opt
    fun get_fd_to_node_id (Runloop _ _ _ _ _ fd_to_node_id _ _ _) = 
        fd_to_node_id
    fun get_rpc_callbacks (Runloop _ _ _ _ _ _ rpc_callbacks _ _) = 
        rpc_callbacks
    fun get_id_to_on_connect_queue (Runloop _ _ _ _ _ _ _ id_to_on_connect_queue _) = 
        id_to_on_connect_queue
    fun get_cur_iteration_internal_messages (Runloop _ _ _ _ _ _ _ _ cur_iteration_internal_messages) = 
        cur_iteration_internal_messages

    (***************************************************************************************)

    fun set_round_timer_fd (Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd _ fd_to_node_id rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages) round_timer_fd =
        Runloop node_id  logger internal_pipe_read_fd internal_pipe_write_fd (Some round_timer_fd) fd_to_node_id rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages
    fun set_fd_to_node_id (Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt _ rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages) fd_to_node_id =
        Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages
    fun set_rpc_callbacks (Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id _ id_to_on_connect_queue cur_iteration_internal_messages) rpc_callbacks =
        Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages
    fun set_id_to_on_connect_queue (Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id rpc_callbacks _ cur_iteration_internal_messages) id_to_on_connect_queue =
        Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages
    fun set_cur_iteration_internal_messages (Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id rpc_callbacks id_to_on_connect_queue _) cur_iteration_internal_messages =
        Runloop node_id logger internal_pipe_read_fd internal_pipe_write_fd round_timer_fd_opt fd_to_node_id rpc_callbacks id_to_on_connect_queue cur_iteration_internal_messages

    (***************************************************************************************)

    fun add_fd_to_node_id runloop fd node_id =
        set_fd_to_node_id runloop (Map.insert (get_fd_to_node_id runloop) fd node_id)
    fun remove_fd_to_node_id runloop fd =
        set_fd_to_node_id runloop (Map.delete (get_fd_to_node_id runloop) fd)
    fun get_fd_to_node_id_value_opt runloop fd =
        Map.lookup (get_fd_to_node_id runloop) fd

    (***************************************************************************************)

    fun get_free_rpc_id runloop node_id =
        let
            val max_rpc_number = 2147483647 (* 2^31 - 1 *)
            val node_rpc_callbacks = 
                List.filter (fn ((id, _), _) => Guid.compare id node_id = Equal) (Map.toAscList (get_rpc_callbacks runloop))
        in
            Int.mod (List.length node_rpc_callbacks) max_rpc_number
        end
    fun get_rpc_callback_opt runloop (node_id, rpc_id) =
        Map.lookup (get_rpc_callbacks runloop) (node_id, rpc_id)
    fun add_rpc_callback runloop (node_id, rpc_id) callback =
        set_rpc_callbacks runloop (Map.insert (get_rpc_callbacks runloop) (node_id, rpc_id) callback)
    fun remove_rpc_callback runloop (node_id, rpc_id) =
        set_rpc_callbacks runloop (Map.delete (get_rpc_callbacks runloop) (node_id, rpc_id))
    fun clear_rpc_callbacks runloop node_id =
        let
            val current_list = Map.toAscList (get_rpc_callbacks runloop)
            val filtered_list = List.filter (fn ((id, _), _) => Guid.compare id node_id = Equal) current_list
            val updated_rpc_callbacks = Map.fromList (Pair.compare Guid.compare Int.compare) filtered_list
        in
            set_rpc_callbacks runloop updated_rpc_callbacks 
        end


    (***************************************************************************************)

    fun append_to_on_connect_queue runloop (node_id : guid) on_connect =
        let
            val on_connect_queue = get_id_to_on_connect_queue runloop
            val node_on_connect_list = Option.getOpt (Map.lookup on_connect_queue node_id) []

            val updated_node_on_connect_list = (node_on_connect_list @ [on_connect])
            val updated_on_connect_queue = Map.insert on_connect_queue node_id updated_node_on_connect_list
        in
            set_id_to_on_connect_queue runloop updated_on_connect_queue
        end
    fun get_on_connect_queue runloop (node_id : guid) =
        Option.getOpt (Map.lookup (get_id_to_on_connect_queue runloop) node_id) []
    fun pop_from_on_connect_queue runloop (node_id : guid) =
        case get_on_connect_queue runloop node_id of
            [] => (None, runloop)
          | (x::xs) => (
                let
                    val on_connect_queue = get_id_to_on_connect_queue runloop 
                    val updated_on_connect_queue = Map.insert on_connect_queue node_id xs
                in
                    (Some x, set_id_to_on_connect_queue runloop updated_on_connect_queue)
                end
            )
    fun remove_from_on_connect_queue runloop (node_id : guid) =
        set_id_to_on_connect_queue runloop (Map.delete (get_id_to_on_connect_queue runloop) node_id)

    (***************************************************************************************)

    fun append_to_cur_iteration_internal_messages runloop (msg : byte_array) =
        set_cur_iteration_internal_messages runloop (
            msg :: get_cur_iteration_internal_messages runloop
        )

    fun pop_from_cur_iteration_internal_messages runloop =
        case get_cur_iteration_internal_messages runloop of
            [] => (None, runloop)
          | (x::xs) => (Some x, set_cur_iteration_internal_messages runloop xs)

end
(**
 *  Type keeps information about files opened to communicate with internal server
 *  
 *  @param logger `logger`: logger to journal runloop_api events
 *  @param in_path `string`: path to the readable end of the FIFO
 *  @param out_path `string`: path to the writable end of the FIFO
 *  @param broadcast_path `string`: path to the broadcast pipe
 *  @param in_fd `int`: file descriptor opened to read rpc calls from
 *  @param out_fd `int`: file descriptor opened to write rpc call responses to
 *  @param broadcast_fd `int`: file descriptor opened to write rpc call responses to
 *  @param dummy_in_fd `int`: dummy file descriptor opened for FIFO specific purposes
 *  @param dummy_out_fd `int`: dummy file descriptor opened for FIFO specific purposes
 *  @param broadcast_out_fd `int`: dummy file descriptor opened for FIFO specific purposes
 *)
datatype runloop_api = RunloopApi logger string string string int int int int int int

structure RunloopApiType =
struct
    fun create logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd

    fun get_logger (RunloopApi logger _ _ _ _ _ _ _ _ _) = logger
    fun get_in_path (RunloopApi _ in_path _ _ _ _ _ _ _ _) = in_path
    fun get_out_path (RunloopApi _ _ out_path _ _ _ _ _ _ _) = out_path
    fun get_broadcast_path (RunloopApi _ _ _ broadcast_path _ _ _ _ _ _) =  broadcast_path
    fun get_in_fd (RunloopApi _ _ _ _ in_fd _ _ _ _ _) = in_fd
    fun get_out_fd (RunloopApi _ _ _ _ _ out_fd _ _ _ _) = out_fd
    fun get_broadcast_fd (RunloopApi _ _ _ _ _ _ broadcast_fd _ _ _) = broadcast_fd
    fun get_dummy_in_fd (RunloopApi _ _ _ _ _ _ _ dummy_in_fd _ _) = dummy_in_fd
    fun get_dummy_out_fd (RunloopApi _ _ _ _ _ _ _ _ dummy_out_fd _) = dummy_out_fd
    fun get_dummy_broadcast_fd (RunloopApi _ _ _ _ _ _ _ _ _ dummy_broadcast_fd) = dummy_broadcast_fd

    fun set_logger (RunloopApi _ in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) logger = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_in_path (RunloopApi logger _ out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) in_path = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_out_path (RunloopApi logger in_path _ broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) out_path = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_broadcast_path (RunloopApi logger in_path out_path _ in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) broadcast_path = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_in_fd (RunloopApi logger in_path out_path broadcast_path _ out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) in_fd = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_out_fd (RunloopApi logger in_path out_path broadcast_path in_fd _ broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) out_fd =
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_broadcast_fd (RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd) broadcast_fd =
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_dummy_in_fd (RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd _ dummy_out_fd dummy_broadcast_fd) dummy_in_fd = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_dummy_out_fd (RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd _ dummy_broadcast_fd) dummy_out_fd = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
    fun set_dummy_out_fd (RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd _) dummy_broadcast_fd = 
        RunloopApi logger in_path out_path broadcast_path in_fd out_fd broadcast_fd dummy_in_fd dummy_out_fd dummy_broadcast_fd
end;
(**
 *  Type representing state of the consensus in the runtime.
 *
 *  @params runloop `runloop`: a state that corresponds to the runloop.
 *)
datatype runtime_state = 
    RuntimeState 
        config runloop round_manager round_state
        block_store storage state_computer
        transaction_pool network_state 
        (runloop_api option) synchronizer

structure RuntimeState =
struct
    fun create 
            config
            runloop
            round_manager
            round_state
            block_store
            storage
            state_computer
            transaction_pool
            network_state
            runloop_api_opt
            synchronizer
        = 
            RuntimeState 
                config
                runloop
                round_manager
                round_state
                block_store
                storage
                state_computer
                transaction_pool
                network_state
                runloop_api_opt
                synchronizer

    fun get_config (RuntimeState config _ _ _ _ _ _ _ _ _ _) =
        config
    fun get_runloop (RuntimeState _ runloop _ _ _ _ _ _ _ _ _) = 
        runloop
    fun get_round_manager (RuntimeState _ _ round_manager _ _ _ _ _ _ _ _) = 
        round_manager
    fun get_round_state (RuntimeState _ _ _ round_state _ _ _ _ _ _ _) = 
        round_state
    fun get_block_store (RuntimeState _ _ _ _ block_store _ _ _ _ _ _) = 
        block_store
    fun get_storage (RuntimeState _ _ _ _ _ storage _ _ _ _ _) = 
        storage
    fun get_state_computer (RuntimeState _ _ _ _ _ _ state_computer _ _ _ _) = 
        state_computer
    fun get_transaction_pool (RuntimeState _ _ _ _ _ _ _ transaction_pool _ _ _) = 
        transaction_pool
    fun get_network_state (RuntimeState _ _ _ _ _ _ _ _ network_state _ _) = 
        network_state
    fun get_runloop_api_opt (RuntimeState _ _ _ _ _ _ _ _ _ runloop_api_opt _) = 
        runloop_api_opt
    fun get_synchronizer (RuntimeState _ _ _ _ _ _ _ _ _ _ synchronizer) =
        synchronizer

    fun get_node_data_set runtime_state =
        NetworkState.get_node_data_set (get_network_state runtime_state)
    fun get_connected_node_set runtime_state =
        NetworkState.get_connected_node_set (get_network_state runtime_state)

    fun get_persistent_state_computer state =
        PersistentStateComputer (get_state_computer state) (get_storage state)
    fun get_persistent_block_store_computer state =
        PersistentBlockStoreComputer (get_block_store state) (get_storage state) (get_state_computer state)

    fun get_round_manager_state state =
        (get_persistent_block_store_computer state,
         get_transaction_pool state,
         get_round_state state,
         get_round_manager state)

    (********************************************************************************)

    fun set_config (RuntimeState _ runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer) config = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_runloop (RuntimeState config _ round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer) runloop = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_round_manager (RuntimeState config runloop _ round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer) round_manager = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_round_state (RuntimeState config runloop round_manager _ block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer) round_state = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_block_store (RuntimeState config runloop round_manager round_state _ storage state_computer transaction_pool network_state runloop_api_opt synchronizer) block_store = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_storage (RuntimeState config runloop round_manager round_state block_store _ state_computer transaction_pool network_state runloop_api_opt synchronizer) storage = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_state_computer (RuntimeState config runloop round_manager round_state block_store storage _ transaction_pool network_state runloop_api_opt synchronizer) state_computer = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_transaction_pool (RuntimeState config runloop round_manager round_state block_store storage state_computer _ network_state runloop_api_opt synchronizer) transaction_pool = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_network_state (RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool _ runloop_api_opt synchronizer) network_state = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_runloop_api_opt (RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state _ synchronizer) runloop_api_opt = 
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer
    fun set_synchronizer (RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt _) synchronizer =
        RuntimeState config runloop round_manager round_state block_store storage state_computer transaction_pool network_state runloop_api_opt synchronizer

    fun set_node_data_set runtime_state node_data_set =
        set_network_state runtime_state (NetworkState.set_node_data_set (get_network_state runtime_state) node_data_set)
    fun set_connected_node_set runtime_state connected_node_set =
        set_network_state runtime_state (NetworkState.set_connected_node_set (get_network_state runtime_state) connected_node_set)

    fun set_persistent_state_computer runtime_state (PersistentStateComputer state_computer storage) =
        set_state_computer (
            set_storage runtime_state storage
        ) state_computer
    fun set_persistent_block_store_computer runtime_state (PersistentBlockStoreComputer block_store storage state_computer) =
        set_state_computer (
            set_storage (
                set_block_store runtime_state block_store
            ) storage
        ) state_computer

    fun set_round_manager_state runtime_state (persistent_block_store_computer, transaction_pool, round_state, round_manager) =
        set_round_manager (
            set_round_state (
                set_transaction_pool (
                    set_persistent_block_store_computer runtime_state persistent_block_store_computer
                ) transaction_pool
            ) round_state
        ) round_manager

    (********************************************************************************)

    fun map_to_runloop runtime_state func =
        set_runloop runtime_state (func (get_runloop runtime_state))
    fun map_to_round_manager runtime_state func =
        set_round_manager runtime_state (func (get_round_manager runtime_state))
    fun map_to_round_state runtime_state func =
        set_round_state runtime_state (func (get_round_state runtime_state))
    fun map_to_block_store runtime_state func =
        set_block_store runtime_state (func (get_block_store runtime_state))
    fun map_to_storage runtime_state func =
        set_storage runtime_state (func (get_storage runtime_state))
    fun map_to_state_computer runtime_state func =
        set_state_computer runtime_state (func (get_state_computer runtime_state))
    fun map_to_transaction_pool runtime_state func =
        set_transaction_pool runtime_state (func (get_transaction_pool runtime_state))
    fun map_to_network_state runtime_state func =
        set_network_state runtime_state (func (get_network_state runtime_state))
    fun map_to_runloop_api_opt runtime_state func =
        set_runloop_api_opt runtime_state (func (get_runloop_api_opt runtime_state))
    
    fun map_to_node_data_set runtime_state func =
        set_node_data_set runtime_state (func (get_node_data_set runtime_state))
    fun map_to_connected_node_set runtime_state func =
        set_connected_node_set runtime_state (func (get_connected_node_set runtime_state))

    fun map_to_persistent_state_computer runtime_state func =
        set_persistent_state_computer runtime_state (func (get_persistent_state_computer runtime_state))
    fun map_to_persistent_block_store_computer runtime_state func =
        set_persistent_block_store_computer runtime_state (func (get_persistent_block_store_computer runtime_state))
        
    fun map_to_round_manager_state runtime_state func =
        set_round_manager_state runtime_state (func (get_round_manager_state runtime_state))
end
exception ApiInvalidType byte_array

exception ApiMessageInvalidLength byte_array int

datatype commit_info = CommitInfo int int

datatype api_msg = NewTransactionRequest int byte_array
                 | NewTransactionResponse int byte_array
                 | QueryContractRequest int guid byte_array
                 | QueryContractResponse int byte_array 
                 | SearchTxRequest int byte_array
                 | SearchTxResponse int (commit_info option) (byte_array option)
                 | AccountRequest int guid
                 | AccountResponse int (account option)
                 | ErrorMsg int int string

structure CommitInfo =
struct

    fun serialize (CommitInfo li version) =
        ByteArray.concat (Serialization.encode_int_flex li) (Serialization.encode_int_flex version)

    fun deserialize serial =
        let
            val (li, li_len) = Serialization.decode_int_flex serial
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) li_len)

            val (version, version_len) = Serialization.decode_int_flex upd_ser
            val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) version_len)
        in
            (CommitInfo li version, li_len + version_len)
        end

end

structure ApiMsgLen =
struct
    fun size () = 4

    fun serialize msg_len = Serialization.encode_int32 msg_len

    fun deserialize serial = Serialization.decode_int32 serial

end

structure ApiParser =
struct

    fun serialize msg =
        let
            fun serialize_msg content = 
                case content of
                  NewTransactionRequest id payload => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 0)
                           (Serialization.encode_byte_array_as_list payload)
                      )
                  )
                | NewTransactionResponse id hash => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat (Serialization.encode_int8 1) (Serialization.encode_byte_array hash))
                  )
                | QueryContractRequest id account_id params => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat 
                           (Serialization.encode_int8 2)
                           (ByteArray.concat
                                (Serialization.encode_byte_array account_id)
                                (Serialization.encode_byte_array_as_list params)
                           )
                      )
                  )
                | QueryContractResponse id result => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 3)
                           (Serialization.encode_byte_array_as_list result)
                      )
                  )
                | SearchTxRequest id hash => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 4)
                           (Serialization.encode_byte_array hash)
                      )
                  )
                | SearchTxResponse id info tx => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 5)
                           (ByteArray.concat
                                (Serialization.encode_option (CommitInfo.serialize) info)
                                (Serialization.encode_option (Serialization.encode_byte_array_as_list) tx)
                           )
                      )
                  )
                | AccountRequest id acc_id => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 7)
                           (Serialization.encode_byte_array acc_id)
                      )
                  )
                | AccountResponse id acc => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 8)
                           (Serialization.encode_option (Account.serialize) acc)
                      )
                  )
                | ErrorMsg id code err_msg => (
                      (Serialization.encode_int32 id),
                      (ByteArray.concat
                           (Serialization.encode_int8 6)
                           (ByteArray.concat
                                (Serialization.encode_int_flex code)
                                (Serialization.encode_string err_msg)
                           )
                      )
                  )
            val (id_ser, msg_ser) = serialize_msg msg
            val msg_len = ApiMsgLen.serialize (Word8Array.length msg_ser)
        in
            ByteArray.concat id_ser (ByteArray.concat msg_len msg_ser)
        end

    fun deserialize serial =
        let
            fun deserialize_msg upd_ser id =
                let
                    val (m_type, m_type_len) = Serialization.decode_int8 upd_ser
                    val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) m_type_len)
                in
                (
                    case m_type of
                      0 =>
                          let
                              val (payload, payload_len) = Serialization.decode_byte_array_as_list upd_ser
                          in
                              (NewTransactionRequest id payload, m_type_len + payload_len)
                          end
                    | 1 =>
                          let
                              val (hash, hash_len) = Serialization.decode_byte_array (HashFunction.size()) upd_ser
                          in
                              (NewTransactionResponse id hash, m_type_len + hash_len)
                          end
                    | 2 =>
                          let
                              val (account_id, account_id_len) = Serialization.decode_byte_array (Guid.size()) upd_ser
                              val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) account_id_len)

                              val (params, params_len) = Serialization.decode_byte_array_as_list upd_ser
                          in
                              (QueryContractRequest id account_id params,
                               m_type_len + account_id_len + params_len)
                          end
                    | 3 =>
                          let
                              val (result, result_len) = Serialization.decode_byte_array_as_list upd_ser
                          in
                              (QueryContractResponse id result, m_type_len + result_len)
                          end
                    | 4 =>
                          let
                              val (hash, hash_len) = Serialization.decode_byte_array (HashFunction.size()) upd_ser
                          in
                              (SearchTxRequest id hash, m_type_len + hash_len)
                          end
                    | 5 =>
                          let
                              val (info, info_len) = Serialization.decode_option (CommitInfo.deserialize) upd_ser
                              val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) info_len)

                              val (tx, tx_len) =
                                  Serialization.decode_option (Serialization.decode_byte_array_as_list) upd_ser
                          in
                              (SearchTxResponse id info tx, m_type_len + info_len + tx_len)
                          end
                    | 6 =>
                          let
                              val (code, code_len) = Serialization.decode_int_flex upd_ser
                              val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) code_len)

                              val (err_msg, err_msg_len) = Serialization.decode_string upd_ser
                          in
                              (ErrorMsg id code err_msg, m_type_len + code_len + err_msg_len)
                          end
                    | 7 =>
                          let
                              val (acc_id, acc_id_len) = Serialization.decode_byte_array (Guid.size()) upd_ser
                          in
                              (AccountRequest id acc_id, m_type_len + acc_id_len)
                          end
                    | 8 =>
                          let
                              val (acc, acc_len) = Serialization.decode_option (Account.deserialize) upd_ser
                          in
                              (AccountResponse id acc, m_type_len + acc_len)
                          end
                    | _ => raise ApiInvalidType serial

                )
                end

            fun check_len upd_ser msg_id msg_id_len data_len =
                if data_len < (ApiMsgLen.size()) then (None, 0)
                else
                    let
                        val (msg_len, msg_len_len) = ApiMsgLen.deserialize upd_ser
                        val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) msg_len_len)
                    in
                        if msg_len > (data_len - ApiMsgLen.size()) (* We don't have enough bytes for deserialization *)
                        then (None, 0)
                        else (* We have enough bytes for deserialization *)
                            let
                                val (msg_content, msg_content_len) = deserialize_msg upd_ser msg_id
                                val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list upd_ser) msg_content_len)
                            in
                                if msg_content_len <> msg_len (* We processed incorrect number of bytes for deserialization *)
                                then raise ApiMessageInvalidLength serial msg_len
                                else (Some (msg_content), msg_id_len + msg_len_len + msg_content_len)
                            end
                    end

            fun check_id serial data_len =
                if data_len < 4 then (None, 0)
                else
                    let
                        val (msg_id, msg_id_len) = Serialization.decode_int32 serial
                        val upd_ser = ByteArray.from_list(List.drop (ByteArray.to_list serial) msg_id_len)
                    in
                        check_len upd_ser msg_id msg_id_len (data_len - msg_id_len)
                    end
                        
            val data_len = Word8Array.length serial
        in
            check_id serial data_len
        end
end

val _ = 
    Exception.add_exn_name_printer 
        (fn e => 
            case e of 
                ApiInvalidType _ => "ApiInvalidType"
              | ApiMessageInvalidLength _ _ => "ApiMessageInvalidLength"
              | _ => raise Exception.Unknown
        )
val _ = 
    Exception.add_exn_message_printer
        (fn e =>
            case e of
                ApiInvalidType v1 => 
                    "ApiInvalidType" ^ " " ^ Hex.bytes_to_hex v1
              | ApiMessageInvalidLength v1 v2 => 
                    "ApiMessageInvalidLength" ^ " " ^ Hex.bytes_to_hex v1 ^ " " ^ Int.toString v2
              | _ => raise Exception.Unknown
        )exception RunloopApiInitializationFailed

structure RunloopApiPrivate =
struct
    local
        fun safe_fd_close fd = Fd.close fd handle FFIFailure => ()
    in
        fun init (logger : logger) (in_path : string) (out_path : string) (broadcast_path : string) =
            let
                fun init_fifo () = 
                    let
                        val inbuf = in_path
                        val outbuf = ByteArray.from_string out_path
                        val broadcast = ByteArray.from_string broadcast_path
                    in
                        #(runloop_api_init_fifo) inbuf outbuf;
                        #(runloop_api_init_fifo) inbuf broadcast;
                        if 
                            Word8.toInt (Word8Array.sub outbuf 0) > 0
                        then (
                            (* Error occured. Runloop API end cannot be started,
                             * thus, journal critical error. The exception will be
                             * handled by the primary RunloopApi initialization function. *)
                            Logger.critical 
                                logger 
                                ("RunloopApi.init: InPath=" ^ in_path ^ "OutPath=" ^ out_path ^
                                 "FIFO creation for API server communication failed" ^
                                 " with Error=" ^ Int.toString (Errno.errno ()) ^ ". " ^ 
                                 "API server has not been started.");
                            raise RunloopApiInitializationFailed
                        ) else ()
                    end
                
                fun open_fifo_ends () =
                    let
                        fun safe_open path flags (opened_fds : int list) =
                            File.fopen path flags
                            handle FFIFailure => (
                                Logger.critical
                                    logger
                                    ("RunloopApi.init: Path=" ^ path ^ ". Opening file failed" ^
                                     " with Error=" ^ Int.toString (Errno.errno ()) ^ ". " ^
                                     "API server has not been started.");
                                List.app safe_fd_close opened_fds;
                                raise RunloopApiInitializationFailed
                            )

                        val nonblock_cloexec_rdonly_flag = 
                            FOpenFlagsMask.from_list [FOpenNonblock, FOpenCloexec, FOpenRead]
                        val nonblock_cloexec_wronly_trunc_flag = 
                            FOpenFlagsMask.from_list [FOpenNonblock, FOpenCloexec, FOpenWrite, FOpenTrunc]
                        
                        (*  VERY IMPORTANT: FIFO should be opened for reading before opening for writing, 
                         *  as opening for writing when no one is reading will return an error *)
                        val in_fd_rd = safe_open in_path nonblock_cloexec_rdonly_flag []
                        (* dummy fd is required in order to not to return end-of-file if FIFO is not open for writing *)
                        val dummy_in_fd_wr = 
                            safe_open in_path nonblock_cloexec_wronly_trunc_flag [in_fd_rd]

                        (* dummy fd is required as it is not possible to open FIFO for writing while no one is reading from it *)
                        val dummy_out_fd_rd = 
                            safe_open out_path nonblock_cloexec_rdonly_flag [in_fd_rd, dummy_in_fd_wr]
                        val out_fd_wr = 
                            safe_open out_path nonblock_cloexec_wronly_trunc_flag [in_fd_rd, dummy_in_fd_wr, dummy_out_fd_rd]

                        (* dummy fd is required as it is not possible to open FIFO for writing while no one is reading from it *)
                        val dummy_broadcast_fd_rd = 
                            safe_open broadcast_path nonblock_cloexec_rdonly_flag [in_fd_rd, dummy_in_fd_wr]
                        val broadcast_fd_wr = 
                            safe_open broadcast_path nonblock_cloexec_wronly_trunc_flag [in_fd_rd, dummy_in_fd_wr, dummy_out_fd_rd]
                    in
                        (in_fd_rd, out_fd_wr, broadcast_fd_wr, dummy_in_fd_wr, dummy_out_fd_rd, dummy_broadcast_fd_rd)
                    end
                
                fun create_runloop_api (in_fd_rd, out_fd_wr, broadcast_fd_wr, dummy_in_fd_wr, dummy_out_fd_rd, dummy_broadcast_fd_rd) =
                    RunloopApiType.create logger in_path out_path broadcast_path in_fd_rd out_fd_wr broadcast_fd_wr dummy_in_fd_wr dummy_out_fd_rd dummy_broadcast_fd_rd
            in
                init_fifo ();
                create_runloop_api (open_fifo_ends ())
            end

        fun clean_up runloop_api =
            let
                fun close_fifo () = 
                    let
                        val inbuf = RunloopApiType.get_in_path runloop_api
                        val outbuf = ByteArray.from_string (RunloopApiType.get_out_path runloop_api)
                        val broadcast = ByteArray.from_string (RunloopApiType.get_broadcast_path runloop_api)
                    in
                        (
                            #(runloop_api_close_fifo) inbuf outbuf;
                            #(runloop_api_close_fifo) inbuf broadcast
                        )
                    end
                
                fun close_fds () = (
                    safe_fd_close (RunloopApiType.get_dummy_in_fd runloop_api);
                    safe_fd_close (RunloopApiType.get_in_fd runloop_api);
                    safe_fd_close (RunloopApiType.get_dummy_broadcast_fd runloop_api);
                    safe_fd_close (RunloopApiType.get_broadcast_fd runloop_api);
                    safe_fd_close (RunloopApiType.get_out_fd runloop_api);
                    safe_fd_close (RunloopApiType.get_dummy_out_fd runloop_api)
                )
            in
                (* Unlinking FIFO does not affect opened desrciptors, 
                 * thus we can safely unlink FIFO before closing descriptors *)
                close_fifo ();
                close_fds ()
            end
    end

    fun create_error_response request code message =
        let
            fun get_api_msg_id api_msg =
                case api_msg of
                    NewTransactionRequest id _ => id
                  | NewTransactionResponse id _ => id
                  | QueryContractRequest id _ _ => id
                  | QueryContractResponse id _ => id
                  | SearchTxRequest id _ => id
                  | SearchTxResponse id _ _ => id
                  | AccountRequest id _ => id
                  | AccountResponse id _ => id
                  | ErrorMsg id _ _ => id
        in
            ErrorMsg (get_api_msg_id request) code message
        end

    fun process_api_request logger state request =
        let
            fun process_new_transaction_request state request = 
                let
                    val (NewTransactionRequest id payload) = request
                    val des_payload_opt = Some (SignedTransaction.deserialize payload)
                    handle _ => (
                        Logger.debug
                            logger
                            ("RunloopApi.process_new_transaction_request: Error during NewTransactionRequest's payload deserialization. " ^
                             "Data=" ^ Hex.bytes_to_hex payload ^ ".");
                        None
                    )
                in
                    case des_payload_opt of
                        None => (state, create_error_response request 2 "Payload cannot be deserialized into signed transaction")
                      | Some (signed_tx, len) => (
                            if
                                len <> Word8Array.length payload
                            then (
                                Logger.debug
                                    logger
                                    ("RunloopApi.process_new_transaction_request: Only " ^ Int.toString len ^ " out of " 
                                     ^ Int.toString (Word8Array.length payload) ^ " were used in payload deserialization.");
                                (state, create_error_response request 2 "The whole payload should correspond to a signed transaction")
                            ) else
                                let
                                    val pbsc = RuntimeState.get_persistent_block_store_computer state
                                    val transaction_pool = RuntimeState.get_transaction_pool state

                                    val new_transaction_pool = TransactionPool.add pbsc transaction_pool [signed_tx]
                                    val new_state = RuntimeState.set_transaction_pool state new_transaction_pool

                                    val response = (NewTransactionResponse id (Hashing.from_tx signed_tx))
                                in
                                    (new_state, response)
                                end
                      )
                end

            fun process_query_contract_request state request =
                let
                    val (QueryContractRequest id account_id params) = request

                    val psc = RuntimeState.get_persistent_state_computer state

                    val result_opt = 
                        Some (PersistentStateComputer.query_contract psc account_id None params)
                        handle _ => None
                in
                    case result_opt of
                        None => create_error_response request 3 "Error while querying the contract"
                      | Some result => QueryContractResponse id result
                end

            fun process_search_tx_request state request =
                let
                    val (SearchTxRequest id tx_hash) = request

                    val transaction_pool = RuntimeState.get_transaction_pool state
                    val transactions = TransactionPool.get_transaction_list transaction_pool
                in
                    case List.find (fn tx => ByteArray.compare (Hashing.from_tx tx) tx_hash = Equal) transactions of
                        Some signed_tx => ( SearchTxResponse id None (Some (SignedTransaction.serialize signed_tx)) )
                      | None => 
                        let
                            val storage = RuntimeState.get_storage state
                            val commited_transaction_opt = TransactionReader.get_commited_transaction storage tx_hash
                        in
                            case commited_transaction_opt of
                                Some (CommitedTransaction li_index version tx) => 
                                    SearchTxResponse id (Some (CommitInfo li_index version)) (Some (SignedTransaction.serialize tx))
                              | None => SearchTxResponse id None None
                        end
                end

            fun process_account_request state request =
                let
                    val (AccountRequest id account_id) = request

                    val psc = RuntimeState.get_persistent_state_computer state
                    val account_opt = PersistentStateComputer.get_account psc account_id
                in
                    AccountResponse id account_opt
                end
        in
            (case request of
                NewTransactionRequest _ _ => process_new_transaction_request state request
              | QueryContractRequest _ _ _ => (state, process_query_contract_request state request)
              | SearchTxRequest _ _ => (state, process_search_tx_request state request)
              | AccountRequest _ _ => (state, process_account_request state request)
              | _ => (state, create_error_response request 1 "Message is not a request")
            ) handle _ => (
                Logger.debug
                    logger
                    "RunloopApi.process_api_request: Unexpected error occured during request processing.";
                (state, create_error_response request 10 "Error during request processing")
            )
        end

    fun on_runloop_api_file_error state (fd : int) (errno : int) = 
        case RuntimeState.get_runloop_api_opt state of
            None => (
                (*  Should never be the case, as if the error callback is called, runloop api must be set. 
                 *  It would be nice to log the error, but logger is kept in runloop_api as well, thus, it is not possible.
                 *
                 *  One way to handle the situation is to raise RunloopApiInternalError, but that will stop the whole node.
                 *  Thus, we just remove the erroneous descriptor from the reactor and hope that all other runloop api 
                 *  descriptors will be deleted further. *)
                (state, Some (Remove fd (fn s => (s, None))))
            )
          | Some runloop_api => 
                let 
                    val in_fd = RunloopApiType.get_in_fd runloop_api
                    val out_fd = RunloopApiType.get_out_fd runloop_api

                    fun clean_up_callback state = (
                        clean_up runloop_api;
                        (RuntimeState.set_runloop_api_opt state None, None)
                    )

                    val out_fd_remove_request = Remove out_fd clean_up_callback
                    val in_fd_remove_request = Remove in_fd (fn s => (s, Some out_fd_remove_request))
                in
                    (state, Some in_fd_remove_request)
                end

    fun on_runloop_api_file_read state (fd : int) (buff : io_buffer) = 
        let
            fun process_events runloop_api in_buff state = 
                let
                    val logger = RunloopApiType.get_logger runloop_api

                    val buff_size = IOBuffer.size in_buff
                    val buff_data = IOBuffer.read in_buff buff_size
                    val (msg_opt, msg_size) = ApiParser.deserialize buff_data
                        handle _ => (
                            (*  If any error happened during deserialization, discard the whole buffer.
                             *  Any deserialization error means that there is something unpredictable occured on the API-server side.
                             *  We just hope that it could recover from the error and start to write valid messages. *)
                            Logger.error
                                logger
                                ("RunloopApi.on_read: Error during deserialization. Data=" ^
                                 Hex.bytes_to_hex buff_data ^ ".");
                            (None, buff_size)
                        )
                in
                    IOBuffer.consume_and_crunch in_buff msg_size;
                    case msg_opt of
                        None => (state, None)
                      | Some req => 
                            let
                                val (new_state, response) = process_api_request logger state req
                                
                                (* TODO: make sure that no exceptions can be raised during serialization *)
                                val data = ApiParser.serialize response

                                fun error_callback state errno = (
                                    Logger.critical
                                        logger
                                        ("RunloopApi.on_read: Writing response failed with Error=" ^
                                         Int.toString errno ^ ". API server is terminating...");
                                    on_runloop_api_file_error state fd errno
                                )

                                val out_fd = RunloopApiType.get_out_fd runloop_api
                                val write_request = 
                                    Write out_fd data (process_events runloop_api in_buff) error_callback
                            in
                               (new_state, Some write_request)
                            end
                end
            
            val runloop_api_opt = RuntimeState.get_runloop_api_opt state
        in
            case runloop_api_opt of
                None => 
                    (*  Should never be the case, as if the error callback is called, runloop api must be set. 
                     *  It would be nice to log the error, but logger is kept in runloop_api as well, thus, it is not possible.
                     *
                     *  One way to handle the situation is to raise RunloopApiInternalError, but that will stop the whole node.
                     *  Thus, we just remove the erroneous descriptor from the reactor and hope that all other runloop api 
                     *  descriptors will be deleted further. *)
                    (state, 0, Some (Remove fd (fn s => (s, None))))
              | Some runloop_api =>
                    let
                        val (new_state, request_opt) = process_events runloop_api buff state
                    in
                        (* Zero bytes are returned as used, as all buffer updates
                         * are made by the `process_events` function explicitly. *)
                        (new_state, 0, request_opt)
                    end
        end
end

structure RunloopApi =
struct
    fun init on_complete_callback_opt (logger : logger) (in_path : string) (out_path : string) (broadcast_path : string) state =
        let
            fun on_complete state =
                case on_complete_callback_opt of
                    None => (state, None)
                  | Some on_complete_callback => on_complete_callback state

            val runloop_api_opt = 
                Some (RunloopApiPrivate.init logger in_path out_path broadcast_path )
                handle RunloopApiInitializationFailed => None
        in
            case runloop_api_opt of
                None => on_complete state (* Initialization of api failed. *) 
              | Some runloop_api =>
                let
                    val config = RuntimeState.get_config state

                    val in_fd = RunloopApiType.get_in_fd runloop_api
                    val out_fd = RunloopApiType.get_out_fd runloop_api
                    val broadcast_fd = RunloopApiType.get_broadcast_fd runloop_api

                    fun add_in_fd_request_callback state = 
                    (* TODO: Maybe wrong function *)
                        let
                            fun add_out_fd_request_error_callback state errno = (
                                Logger.critical
                                    logger
                                    ("RunloopApi.init: Adding output descriptor to the reactor" ^
                                    " failed with Error=" ^ Int.toString errno ^ ". " ^
                                    "API server has not been started.");
                                    RunloopApiPrivate.clean_up runloop_api;
                                    (* As we have already added input descriptor, it should be removed *)
                                    (state, Some (Remove in_fd on_complete))
                            )
                            fun add_broadcast_fd_request_callback state =
                                let

                                    fun add_out_fd_request_callback state =
                                        (* As the whole initialization successfully ended, 
                                        * we can save runloop_api into the state. *)
                                        on_complete (RuntimeState.set_runloop_api_opt state (Some runloop_api))

                                    val add_broadcast_fd_request =
                                        AddWriteFile "broadcast"
                                        broadcast_fd
                                        (ErrHandler RunloopApiPrivate.on_runloop_api_file_error)
                                        (Config.get_write_buffer_size config) (Config.get_write_buffer_lwm config)
                                        add_out_fd_request_callback add_out_fd_request_error_callback
                                in
                                    (state, Some add_broadcast_fd_request)
                                end
                                (* (* As the whole initialization successfully ended, 
                                 * we can save runloop_api into the state. *)
                                on_complete (RuntimeState.set_runloop_api_opt state (Some runloop_api)) *)
                            val add_out_fd_request = 
                                AddWriteFile "api_out"
                                    out_fd
                                    (ErrHandler RunloopApiPrivate.on_runloop_api_file_error)
                                    (Config.get_write_buffer_size config) (Config.get_write_buffer_lwm config)
                                    add_broadcast_fd_request_callback add_out_fd_request_error_callback
                            
                        in
                            (state, Some add_out_fd_request)
                        end

                    fun add_in_fd_request_error_callback state errno = (
                        Logger.critical
                            logger
                            ("RunloopApi.init: Adding input descriptor to the reactor" ^
                             " failed with Error=" ^ Int.toString errno ^ ". " ^
                             "API server has not been started.");
                            RunloopApiPrivate.clean_up runloop_api;
                            on_complete state
                    )

                    val add_in_fd_request = 
                        AddReadFile "api_in"
                            in_fd
                            (ReadHandler RunloopApiPrivate.on_runloop_api_file_read)
                            (ErrHandler RunloopApiPrivate.on_runloop_api_file_error)
                            (Config.get_read_buffer_size config) (Config.get_read_buffer_lwm config)
                            add_in_fd_request_callback add_in_fd_request_error_callback
                in
                    (state, Some add_in_fd_request)
                end
        end

    fun clean_up runloop_api = 
        RunloopApiPrivate.clean_up runloop_api
    
    fun write_to_broadcast logger state data on_complete_callback = 
        let
            fun write_to_broadcast_request_error_callback state errno = (
                        Logger.critical
                            logger
                            ("RunloopApi.write_to_broadcast: Writing to the broadcast pipe" ^
                             " failed with Error=" ^ Int.toString errno ^ ". " ^
                             "Data wasn't written.");
                            on_complete_callback state
                    )
            val runloop_api_opt = RuntimeState.get_runloop_api_opt state
        in
            case runloop_api_opt of
                None => on_complete_callback state (* Write in api failed. *) 
              | Some runloop_api =>
                let 
                    val broadcast_fd = RunloopApiType.get_broadcast_fd runloop_api
                    val write_broadcast_request = 
                        Write broadcast_fd data
                            on_complete_callback write_to_broadcast_request_error_callback
                in
                    (state, Some write_broadcast_request)
                end
        end
end

local
    fun exn_printer e =
        case e of
            RunloopApiInitializationFailed => "RunloopApiInitializationFailed"
          | _ => raise Exception.Unknown
in
    val _ = Exception.add_exn_name_printer exn_printer
    val _ = Exception.add_exn_message_printer exn_printer
end
structure ConcreteEventHandlerHelpers =
struct
    (* Helper function that is used as a callback function for
     * the requests which do not require any processing further. *)
    fun id_callback state = (state, None)

    (* Helper function that may be used to quickly get the
     * runloop logger from the runtime state. *)
    fun get_logger state = 
        (RunloopType.get_logger o RuntimeState.get_runloop) state
    
    fun on_complete on_complete_callback_opt state = 
        case on_complete_callback_opt of
            None => id_callback state
          | Some on_complete_callback => on_complete_callback state

    fun remove_fd on_complete_callback_opt state fd =
        let
            val remove_request = Remove fd (on_complete on_complete_callback_opt)

            fun update_state state fd =
                case RunloopType.get_fd_to_node_id_value_opt (RuntimeState.get_runloop state) fd of
                    None => state
                  | Some node_id => (
                        RuntimeState.map_to_runloop (
                            RuntimeState.map_to_network_state 
                                state (fn ns => ConnectionManager.remove ns node_id)
                        ) (fn r => RunloopType.remove_fd_to_node_id (RunloopType.clear_rpc_callbacks r node_id) fd)
                    )
        in
            (update_state state fd, Some remove_request)    
        end

    fun critical_error_callback (a_where : string) state (errno : int) = (
        Logger.critical
            (get_logger state) 
            ("Runloop." ^ a_where ^ ": critical error occurred. " ^
             "Errno=" ^ Int.toString errno ^ ".");
        (state, Some ExitRun)
    )

    fun error_callback (fd : int) on_complete_callback_opt state (errno : int) =
        remove_fd on_complete_callback_opt state fd

    fun process_event_request f_connect process_round_manager_callback on_complete_callback_opt state event callback_opt = 
        let 
            fun process_msg_event (a_where : string) on_ready state receiver_id network_data =
                let
                    fun append_to_on_connect_queue state =
                        RuntimeState.map_to_runloop 
                            state (fn r => 
                                RunloopType.append_to_on_connect_queue r receiver_id (event, callback_opt)
                            )

                    val network_state = RuntimeState.get_network_state state

                    val this_node_id = (RunloopType.get_node_id o RuntimeState.get_runloop) state
                in
                    if 
                        Guid.compare receiver_id this_node_id = Equal
                    then
                        (* The message receiver is the node itself. Write the message
                         * into the internal pipe. *)
                        let
                            val msg = MessageParser.serialize DirectMsg network_data
                        in
                            on_complete on_complete_callback_opt (
                                RuntimeState.map_to_runloop state (
                                    fn runloop => RunloopType.append_to_cur_iteration_internal_messages runloop msg
                                )
                            )
                        end
                    else
                        case ConnectionManager.get_connection_status network_state receiver_id of
                            Connecting => (
                                (*  The connection is already establishing. Just save the
                                 *  processing function into the queue, it will be processed 
                                 *  when connection will be established.
                                 *)
                                on_complete on_complete_callback_opt (append_to_on_connect_queue state)
                            )
                          | Handshaking => (
                                (*  The connection has been established and handshaking is now going on. 
                                 *  The same as for the Connecting: just save the processing function into the queue.
                                 *)
                                on_complete on_complete_callback_opt (append_to_on_connect_queue state)
                            )
                          | Ready =>
                                (*  The connection is ready so we can send the message to the
                                 *  receiver and call the callback function if any is specified.
                                 *
                                 *  The processing depends on whether direct message or rpc request is sent,
                                 *  thus, we use the processing function that was specified.
                                 *)
                                on_ready state receiver_id network_data
                          | Unknown => (
                                (*  The connection with a node has not been initialized yet. We should connect
                                 *  to it before sending any messages. Save the request for further processing
                                 *)
                                let
                                    val node_data_set = NetworkState.get_node_data_set network_state
                                    val known_node_info_opt = NodeDataSet.search node_data_set receiver_id
                                in
                                    case known_node_info_opt of
                                        None => (
                                            (*  Something strange happened, as we should have the node information
                                            *  in the set of known nodes, to get a request to send a message to it.
                                            *  For now, just ignore the error and do not proceed the request further.
                                            *)
                                            on_complete on_complete_callback_opt state
                                        )
                                        | Some known_node_info => (
                                            (*  Add the request to the queue of pending requests for the node,
                                            *   and try to connect to the node.
                                            *)
                                            f_connect on_complete_callback_opt (append_to_on_connect_queue state) known_node_info
                                        )
                                end
                            )
                end

            fun process_direct_msg_event state receiver_id network_data =
                let
                    fun on_ready state receiver_id network_data =
                        (*  The connection should be ready before calling the function,
                         *  so we can send the message to the receiver and call the 
                         *  callback function if any specified.
                         *)
                        let
                            val network_state = RuntimeState.get_network_state state
                            val msg = MessageParser.serialize DirectMsg network_data
                            val (enc_msg, fd, sent_network_state) = ConnectionManager.send network_state receiver_id msg
                            val sent_state = RuntimeState.set_network_state state sent_network_state

                            fun write_callback state = 
                                (*  The request has been sent. As it is a direct msg we do not wait for any response,
                                 *  and call a callback function if any has been specified. *)
                                case callback_opt of
                                    None => on_complete on_complete_callback_opt state
                                  | Some callback =>
                                        let
                                            val round_manager_state = RuntimeState.get_round_manager_state state
                                            val (callback_round_manager_state, in_event_request_opt) = callback round_manager_state
                                            val callback_state = RuntimeState.set_round_manager_state state callback_round_manager_state
                                        in
                                            case in_event_request_opt of
                                                None => on_complete on_complete_callback_opt callback_state
                                              | Some (in_out_event, in_should_callback) =>
                                                    let
                                                        val in_callback_opt = if in_should_callback then callback_opt else None
                                                    in
                                                        process_event_request f_connect process_round_manager_callback on_complete_callback_opt callback_state in_out_event in_callback_opt
                                                    end
                                        end

                            val write_request = Write fd msg write_callback (error_callback fd on_complete_callback_opt)
                        in
                            (sent_state, Some write_request)
                        end
                in
                    process_msg_event "process_direct_msg_event" on_ready state receiver_id network_data
                end

            fun process_rpc_request_event state receiver_id network_data rpc_id_opt =
                let
                    fun on_ready state receiver_id network_data = 
                        (*  The connection should be ready before calling the function. Otherwise,
                         *  an exceptions would raise when `ConnectionManager.send` is called. 
                         *)
                        let
                            val network_state = RuntimeState.get_network_state state
                            val runloop = RuntimeState.get_runloop state
                            val rpc_id = 
                                case rpc_id_opt of
                                    None => RunloopType.get_free_rpc_id runloop receiver_id
                                  | Some rpc_id => rpc_id

                            val msg = MessageParser.serialize (RpcRequest rpc_id) network_data
                            val (enc_msg, fd, sent_network_state) = ConnectionManager.send network_state receiver_id msg
                            val sent_state = RuntimeState.set_network_state state sent_network_state

                            fun write_callback state = 
                                (*  The request has been sent. As it is a rpc request, a callback function 
                                 *  if specified should be called only after getting the response. To do that,
                                 *  we add the callback to rpc_requests list.
                                 *  
                                 *  In the future, we can the check that the message has actually been sent,
                                 *  and only in that case add the callback function to the rpc_requests list. *)
                                case callback_opt of
                                    None => 
                                        (* In general, a callback function should be specified 
                                         * for rpc requests, but it may be not in case if the 
                                         * rpc request with specified id already existed. . *)
                                        on_complete on_complete_callback_opt state
                                  | Some callback =>
                                        let
                                            val updated_state = 
                                                RuntimeState.map_to_runloop state 
                                                    (fn r => RunloopType.add_rpc_callback r (receiver_id, rpc_id) callback)
                                        in
                                            on_complete on_complete_callback_opt updated_state
                                        end
                            val write_request = Write fd msg write_callback (error_callback fd on_complete_callback_opt)
                        in
                            (sent_state, Some write_request)
                        end
                in
                    process_msg_event "process_rpc_request_event" on_ready state receiver_id network_data
                end

            fun process_broadcast_event state network_data =
                let 
                    val msg = MessageParser.serialize DirectMsg network_data
                    
                    fun error_callback prev_state broadcast_to _ errno =
                        (* Some error occurred while sending the message to the peer.
                         * We assume that the message has not been delivered. Thus, we
                         * return the previous state with old information about the peer's
                         * current noise status. 
                         *
                         * We are not going to repeat the message sending to the peer, as it 
                         * would likely to fail again. Instead we just continue to send 
                         * the message to other peers. *)
                        write_callback broadcast_to prev_state

                    and write_callback broadcast_to state =
                        let
                            val network_state = RuntimeState.get_network_state state
                        in
                            case broadcast_to of
                                [] => (
                                    case callback_opt of
                                        None => on_complete on_complete_callback_opt state
                                      | Some callback => process_round_manager_callback on_complete_callback_opt state callback
                                )
                              | (node_id :: others) => (
                                    let
                                        val (msg_to_send, fd, new_network_state) = ConnectionManager.send network_state node_id msg
                                        val new_state = RuntimeState.set_network_state state new_network_state

                                        val request = Write fd msg_to_send (write_callback others) (error_callback state others)
                                    in
                                        (new_state, Some request)
                                    end
                                )
                        end

                    val broadcast_node_ids = ConnectionManager.get_connected_node_ids (RuntimeState.get_network_state state)
                in
                    write_callback broadcast_node_ids (
                        RuntimeState.map_to_runloop state (
                            fn runloop => RunloopType.append_to_cur_iteration_internal_messages runloop msg
                        )
                    )
                end

            fun process_internal_timer_data_event state timer_data =
                let
                    val (SetRoundTimer duration) = timer_data

                    val runloop = RuntimeState.get_runloop state
                    val round_timer_fd_opt = RunloopType.get_round_timer_fd_opt runloop
                in
                    case round_timer_fd_opt of
                        None => (
                            (* Something strange occurred here, as it should
                             * be an unreachable state. If the execution came here
                             * some critical error in the node implementation exists.
                             * Log the error, and stop the reactor. *)
                            Logger.critical
                                (get_logger state)
                                ("Runloop.process_internal_timer_data_event: " ^
                                 "file descriptor for the round timer is absent.");
                            (state, Some ExitRun)
                        )
                      | Some round_timer_fd =>
                            let
                                fun set_timer_callback state =
                                    let
                                        val round_manager_state = RuntimeState.get_round_manager_state state

                                        (* As we got timer request, new round should be started *)
                                        val (started_round_manager_state, event_request_opt) = 
                                            RoundManager.start_new_round round_manager_state
                                        
                                        val started_state = RuntimeState.set_round_manager_state state started_round_manager_state
                                    in
                                        case event_request_opt of
                                            None => (
                                                case callback_opt of
                                                    None => on_complete on_complete_callback_opt started_state
                                                  | Some callback => process_round_manager_callback on_complete_callback_opt started_state callback
                                            )
                                          | Some event_request =>
                                                process_event_request f_connect process_round_manager_callback on_complete_callback_opt started_state event_request callback_opt
                                    end

                                val request = SetTimer round_timer_fd duration duration
                                    set_timer_callback
                                    (critical_error_callback "process_internal_timer_data_event")
                            in
                                (state, Some request)
                            end
                end
        in
            case event of
                BroadcastEvent network_data => 
                    process_broadcast_event state network_data
              | DirectMsgEvent receiver_id network_data => 
                    process_direct_msg_event state receiver_id network_data
              | RpcRequestEvent receiver_id network_data rpc_id_opt => 
                    process_rpc_request_event state receiver_id network_data rpc_id_opt
              | InternalTimerDataEvent timer_data => 
                    process_internal_timer_data_event state timer_data
        end

    fun connect data_stream_read_handler data_stream_connect_handler_opt data_stream_error_handler on_complete_callback_opt state known_node_info =
        let
            val config = RuntimeState.get_config state

            val network_state = RuntimeState.get_network_state state
            val (node_addr, new_network_state) = ConnectionManager.connection network_state known_node_info
            val new_state = RuntimeState.set_network_state state new_network_state
            
            val node_id = KnownNodeInfo.get_id known_node_info

            (* Wrapped error_callback which additionally handles the situation
             * when the error occurred on the descriptor creation and only 
             * connected_node_set information should be updated. *)
            fun in_error_callback fd_opt state errno =
                let
                    val new_state = 
                        RuntimeState.map_to_network_state state 
                            (fn network_state => ConnectionManager.remove network_state node_id)
                in
                    case fd_opt of
                        None => on_complete on_complete_callback_opt new_state
                      | Some fd => error_callback fd on_complete_callback_opt new_state errno
                end
            fun add_read_write_data_stream_callback state fd =
                let
                    val connect_request = 
                        Connect fd node_addr (on_complete on_complete_callback_opt) (in_error_callback (Some fd))
                in
                    (
                        RuntimeState.map_to_runloop 
                            state 
                            (fn r => RunloopType.add_fd_to_node_id r fd node_id),
                        Some connect_request
                    )
                end
            val add_read_write_data_stream_request = 
                AddReadWriteDataStream (Hex.bytes_to_hex node_id) 
                    data_stream_read_handler data_stream_connect_handler_opt data_stream_error_handler
                    (Config.get_read_buffer_size config) (Config.get_read_buffer_lwm config)
                    (Config.get_write_buffer_size config) (Config.get_write_buffer_lwm config) 
                    None
                    add_read_write_data_stream_callback (in_error_callback None)
        in
            (new_state, Some add_read_write_data_stream_request)
        end

    (**
     *  Should be called when the connection with a peer is
     *  established and all queued events should be processed.
     *)
    fun process_on_connect_queue process_event_request fd node_id state = 
        let
            val runloop = RuntimeState.get_runloop state
        in
            case RunloopType.get_fd_to_node_id_value_opt runloop fd of
                None => 
                    (* The connection has been removed during event processing. *)
                    (state, None)
              | Some t_node_id =>
                    if 
                        Guid.compare node_id t_node_id <> Equal
                    then
                        (* The connection has been removed during event processing,
                         * and new connection has been opened. *)
                        (state, None) 
                    else
                        case RunloopType.pop_from_on_connect_queue runloop node_id of
                            (None, _) => (* No more events to be processed. *) 
                                (state, None)
                          | (Some (out_event, callback_opt), updated_runloop) => 
                                process_event_request 
                                    (Some (process_on_connect_queue process_event_request fd node_id))
                                    (RuntimeState.set_runloop state updated_runloop) 
                                    out_event 
                                    callback_opt
        end

        fun update_transaction_pool (prev_state : runtime_state) (a_where : string) (state : runtime_state) = 
            let
                fun get_current_version state =
                    StateComputer.commit_block_version (RuntimeState.get_state_computer state)

                (* The function returns all transactions which have been committed between
                 * \a from_v and \a to_v (including) versions. Should be called specifying 
                 * \a from_v argument to be greater by one than last saved version. *)
                fun get_all_txs (storage : storage) (from_v : int) (to_v : int) =
                    let
                        fun get_all_txs_opt (v : int) (result : signed_transaction option list) =
                            case Int.compare v to_v of
                                Greater => result
                              | _ => get_all_txs_opt (v + 1) (Option.map fst (TransactionReader.read_tx storage v) :: result)
                    in
                        (* We filter the resultant list, so that all elements will have some transaction.
                         * However, it seems that if the node's version has been updated, all versions prior
                         * to the current one, should have corresponding transactions saved. So, absense
                         * of transaction may mean some error occurred during the run. Maybe it would be
                         * better to detect such conditions and raise an exception? *)
                        List.map Option.valOf (List.filter Option.isSome (get_all_txs_opt from_v []))
                    end

                val saved_version = get_current_version prev_state
                val current_version = get_current_version state
            in
                case Int.compare saved_version current_version of
                    (* No transactions have been commited. So nothing to update
                     * in transaction pool. *)
                    Equal => state
                    (* Some transaction have been commited. Remove them from transaction pool. *)
                  | Less =>
                        let
                            val storage = RuntimeState.get_storage state
                            val transaction_pool = RuntimeState.get_transaction_pool state
                            val pbsc = RuntimeState.get_persistent_block_store_computer state
                            
                            val commited_tx_hashes = Set.from_list ByteArray.compare (
                                List.map Hashing.from_tx (get_all_txs storage (saved_version + 1) current_version)
                            )
                            val (updated_transaction_pool, _) = TransactionPool.remove pbsc transaction_pool commited_tx_hashes
                        in
                            RuntimeState.set_transaction_pool state updated_transaction_pool
                        end
                  | Greater => (
                        (* Something wrong occurred, as it should be an unreachable state.
                         * Coming to that branch means that there was some error in our
                         * node implementation. We consider the error as a critical in order
                         * for it to be detected and fixed. So, log the error and raise an exception.
                         *
                         * TODO: consider creating a more meaningful exception to be raised here. *)
                        Logger.critical
                            (get_logger state)
                            ("Runloop." ^ a_where ^ ": assertion failed when updating the transaction pool." ^ 
                             " Saved version=" ^ Int.toString saved_version ^ ", Current version=" ^ 
                             Int.toString current_version ^ ".");
                        raise Bind
                    )
            end

    local
        fun process_round_manager_function a_where process_event_request update_transaction_pool on_complete_callback_opt state round_manager_function =
            let
                val round_manager_state = RuntimeState.get_round_manager_state state
                
                val (processed_round_manager_state, event_request_opt) = 
                    round_manager_function round_manager_state
                val processed_state = 
                    RuntimeState.set_round_manager_state state processed_round_manager_state

                val transaction_pool_removed_state = 
                    update_transaction_pool state a_where processed_state
            in
                case event_request_opt of
                    None => on_complete on_complete_callback_opt transaction_pool_removed_state
                  | Some (out_event, should_callback) =>
                        let
                            val callback_function_opt = if should_callback then Some round_manager_function else None
                        in
                            process_event_request on_complete_callback_opt transaction_pool_removed_state out_event callback_function_opt
                        end
            end

        fun process_sync_data_event a_where process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix synchronizer_processing =
            let
                val network_state = RuntimeState.get_network_state state
            in
                case ConnectionManager.get_connection_status network_state node_id of
                    Ready => (
                        let
                            val connected_node_set = NetworkState.get_connected_node_set network_state
                            val connected_node_info = Option.valOf (ConnectedNodeSet.search connected_node_set node_id)
                            val fd = Option.valOf (ConnectedNodeInfo.get_fd_opt connected_node_info)

                            val pbsc = RuntimeState.get_persistent_block_store_computer state
                            val synchronizer = RuntimeState.get_synchronizer state
                            val (processed_pbsc, network_data_opt) = synchronizer_processing (pbsc, synchronizer)

                            val processed_state = 
                                RuntimeState.set_persistent_block_store_computer state processed_pbsc

                            val transaction_pool_removed_state = 
                                update_transaction_pool state a_where processed_state
                        in
                            case network_data_opt of
                                None => (
                                    (* No more requests were got from the synchronizer.
                                     * Callback function should be called if any exists. *)
                                    case msg_prefix of
                                        RpcRequest rpc_id =>
                                            let
                                                val runloop = RuntimeState.get_runloop transaction_pool_removed_state
                                                val callback_function_opt = RunloopType.get_rpc_callback_opt runloop (node_id, rpc_id)
                                                
                                                val rpc_callback_removed_runloop = 
                                                    RunloopType.remove_rpc_callback runloop (node_id, rpc_id)
                                                val rpc_callback_removed_state = 
                                                    RuntimeState.set_runloop transaction_pool_removed_state rpc_callback_removed_runloop
                                            in
                                                case callback_function_opt of
                                                    (* No callback functions are associated with rpc_id. Actually,
                                                     * it a strange behaviour, but for now we just ignore it. *)
                                                    None => on_complete on_complete_callback_opt rpc_callback_removed_state
                                                    (* There is a callback function associated with rpc_id. *)
                                                  | Some callback_function =>
                                                        process_round_manager_function 
                                                            a_where
                                                            process_event_request
                                                            update_transaction_pool 
                                                            on_complete_callback_opt 
                                                            rpc_callback_removed_state
                                                            callback_function                                                    
                                            end
                                      | DirectMsg =>
                                            on_complete on_complete_callback_opt transaction_pool_removed_state
                                )
                              | Some network_data =>
                                    let
                                        val request =
                                            case msg_prefix of
                                                DirectMsg => DirectMsgEvent node_id network_data
                                              | RpcRequest rpc_id => RpcRequestEvent node_id network_data (Some rpc_id)
                                    in
                                        process_event_request on_complete_callback_opt transaction_pool_removed_state request None
                                    end
                        end
                    )
                  | _ => (
                      (* The node is not fully connected. Something went wrong,
                       * as in general it should be an unreachable state. *)
                        Logger.warn
                            (get_logger state)
                            ("Runloop." ^ a_where ^ ": node is not connected." ^
                             "NodeId=" ^ Hex.bytes_to_hex node_id ^ ".");
                        on_complete on_complete_callback_opt state
                  )
            end
    in
        fun process_consensus_proposal_event process_event_request update_transaction_pool on_complete_callback_opt state proposal_msg =
            process_round_manager_function 
                "process_consensus_proposal_event" 
                process_event_request 
                update_transaction_pool 
                on_complete_callback_opt 
                state 
                (RoundManager.process_proposal_msg proposal_msg (RuntimeState.get_synchronizer state))

        fun process_consensus_vote_event process_event_request update_transaction_pool on_complete_callback_opt state vote_msg =
            process_round_manager_function 
                "process_consensus_vote_event" 
                process_event_request 
                update_transaction_pool 
                on_complete_callback_opt 
                state 
                (RoundManager.process_vote_msg vote_msg (RuntimeState.get_synchronizer state))

        fun process_sync_data_block_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix blocks sync_info =
            process_sync_data_event 
                "process_sync_data_block_event" 
                process_event_request 
                update_transaction_pool 
                on_complete_callback_opt 
                state node_id msg_prefix 
                (fn (pbsc, synchronizer) => Synchronizer.process_block_retrieval_response pbsc blocks sync_info synchronizer)

        fun process_sync_data_tx_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix sync_commits sync_info =
            process_sync_data_event 
                "process_sync_data_tx_event" 
                process_event_request 
                update_transaction_pool 
                on_complete_callback_opt 
                state node_id msg_prefix 
                (fn (pbsc, synchronizer) => Synchronizer.process_transactions_retrieval_response pbsc sync_commits sync_info synchronizer)

        fun process_round_manager_callback f_connect update_transaction_pool on_complete_callback_opt state callback_function =
            process_round_manager_function 
                "process_round_manager_callback" 
                (process_event_request f_connect (process_round_manager_callback f_connect update_transaction_pool))
                update_transaction_pool 
                on_complete_callback_opt 
                state 
                callback_function

    end

    local
        fun process_sync_request_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix synchronizer_processing =
            let
                val pbsc = RuntimeState.get_persistent_block_store_computer state 
                val synchronizer = RuntimeState.get_synchronizer state
                
                val response = synchronizer_processing (pbsc, synchronizer)
                
                val out_event =
                    case msg_prefix of
                        DirectMsg => DirectMsgEvent node_id response
                      | RpcRequest rpc_id => RpcRequestEvent node_id response (Some rpc_id)
            in
                process_event_request on_complete_callback_opt state out_event None
            end
    in
        fun process_sync_request_block_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix parent waypoint =
            process_sync_request_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix
                (fn (pbsc, synchronizer) => Synchronizer.process_block_retrieval_request pbsc parent waypoint synchronizer)

        fun process_sync_request_tx_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix version =
            process_sync_request_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix
                (fn (pbsc, synchronizer) => Synchronizer.process_transactions_retrieval_request pbsc version synchronizer)
    end

        fun process_socket_event process_event_request update_transaction_pool on_complete_callback_opt state (node_id : guid) (msg_prefix : msg_prefix) (msg_content : msg_type) =
            case msg_content of
                Discovery _ => on_complete on_complete_callback_opt state
              | ConnectionInit _ => on_complete on_complete_callback_opt state
              | Connection _ => on_complete on_complete_callback_opt state
              | ConsensusProposal proposal_msg => 
                    process_consensus_proposal_event process_event_request update_transaction_pool on_complete_callback_opt state proposal_msg
              | ConsensusVote vote_msg => 
                    process_consensus_vote_event process_event_request update_transaction_pool on_complete_callback_opt state vote_msg
              | SyncRequestBlock parent waypoint => 
                    process_sync_request_block_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix parent waypoint
              | SyncRequestTx version => 
                    process_sync_request_tx_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix version
              | SyncDataBlock blocks sync_info => 
                    process_sync_data_block_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix blocks sync_info
              | SyncDataTx sync_commits sync_info =>
                    process_sync_data_tx_event process_event_request update_transaction_pool on_complete_callback_opt state node_id msg_prefix sync_commits sync_info
              | Ping => on_complete on_complete_callback_opt state
              | Pong => on_complete on_complete_callback_opt state
end
structure ConcreteEventHandlers =
struct
    fun on_poll state = 
        let
            fun process_internal_messages state = 
                let
                    val runloop = RuntimeState.get_runloop state
                    val (msg_opt, updated_runloop) = 
                        RunloopType.pop_from_cur_iteration_internal_messages runloop

                    val request_opt = Option.map (
                        fn msg => 
                            let
                                val internal_pipe_write_fd = 
                                    RunloopType.get_internal_pipe_write_fd (RuntimeState.get_runloop state)

                                val internal_write_request = 
                                    Write internal_pipe_write_fd msg on_poll (ConcreteEventHandlerHelpers.critical_error_callback "on_poll")
                            in
                                internal_write_request
                            end
                    ) msg_opt
                in
                    (RuntimeState.set_runloop state updated_runloop, request_opt)
                end
        in
            process_internal_messages state
        end

    fun data_stream_on_error state fd errno = 
        ConcreteEventHandlerHelpers.error_callback fd None state errno

    fun l_connect on_complete_callback_opt state known_node_info = 
        ConcreteEventHandlerHelpers.connect 
            (ReadHandler data_stream_on_read) 
            (Some (ConnectHandler data_stream_on_connect)) 
            (ErrHandler data_stream_on_error) 
            on_complete_callback_opt state known_node_info

    and l_process_event_request on_complete_callback_opt state event callback_opt = 
        ConcreteEventHandlerHelpers.process_event_request 
            l_connect 
            (ConcreteEventHandlerHelpers.process_round_manager_callback l_connect ConcreteEventHandlerHelpers.update_transaction_pool)
            on_complete_callback_opt state event callback_opt
    
    and data_stream_on_read state fd buff =
        case RunloopType.get_fd_to_node_id_value_opt (RuntimeState.get_runloop state) fd of
            None => (
                (* The descriptor does not correspond to any node.
                 * It is an unexpected behaviour, so we remove the descriptor
                 * from the reactor and log a warning. *)
                Logger.warn
                    (ConcreteEventHandlerHelpers.get_logger state)
                    ("Runloop.data_stream_on_read: FD=" ^ Int.toString fd ^
                     ". Did not find corresponding node id.");
                (state, 0, Some (Remove fd ConcreteEventHandlerHelpers.id_callback))
            )
          | Some node_id =>
                let
                    fun process_events state =
                        let
                            val runloop = RuntimeState.get_runloop state
                            val connected_node_set = RuntimeState.get_connected_node_set state
                        in
                            case RunloopType.get_fd_to_node_id_value_opt runloop fd of
                                None => 
                                    (* The connection has been removed during event processing. *)
                                    (state, None)
                              | Some t_node_id =>
                                    if 
                                        Guid.compare node_id t_node_id <> Equal
                                    then
                                        (* The connection has been removed during event processing,
                                         * and new connection has been opened to another node. *)
                                        (state, None) 
                                    else
                                        case ConnectedNodeSet.search connected_node_set node_id of
                                            None => (
                                                (* It is an unexpected behaviour, as the node
                                                 * should exist in the connected_node_set.  *)
                                                Logger.warn
                                                    (ConcreteEventHandlerHelpers.get_logger state)
                                                    ("Runloop.data_stream_on_read: FD=" ^ Int.toString fd ^
                                                     ", NodeId=" ^ Hex.bytes_to_hex node_id ^
                                                     ". The node does not present in the connected_node_set.");
                                                (state, None)
                                            )
                                          | Some connected_node_info =>
                                                let
                                                    val in_buff = ConnectedNodeInfo.get_io_buff connected_node_info
                                                    val msg_ser = IOBuffer.read in_buff (IOBuffer.size in_buff)
                                                    val (msg_opt, msg_size) = 
                                                        MessageParser.deserialize msg_ser
                                                in
                                                    IOBuffer.consume_and_crunch in_buff msg_size;
                                                    case msg_opt of
                                                        None => (state, None)
                                                      | Some (msg_prefix, msg_content) => 
                                                            let
                                                                fun write_callback state = RunloopApi.write_to_broadcast (ConcreteEventHandlerHelpers.get_logger state) state msg_ser process_events
                                                            in
                                                                ConcreteEventHandlerHelpers.process_socket_event l_process_event_request
                                                                    ConcreteEventHandlerHelpers.update_transaction_pool
                                                                    (Some write_callback) state node_id msg_prefix msg_content
                                                            end
                                                end
                        end

                    (* If we are here, the node should present in the ConnectedNodeSet. *)
                    val network_state = RuntimeState.get_network_state state                                            
                    val (n_recieved, in_buff, updated_network_state) = 
                        ConnectionManager.recv network_state node_id buff
                    val updated_state = RuntimeState.set_network_state state updated_network_state

                    val (final_state, request_opt) = process_events updated_state
                in
                    (* (state, 0, None) *)
                    (final_state, n_recieved, request_opt)
                end

    and data_stream_on_connect state fd = 
        case RunloopType.get_fd_to_node_id_value_opt (RuntimeState.get_runloop state) fd of
            None => (
                (* The descriptor is not present in the mapping to node id. 
                 * It is a strange behavour, but for now we ignor the error and
                 * just remove the data stream from the runloop and the reactor *)
                Logger.warn 
                    (ConcreteEventHandlerHelpers.get_logger state)
                    ("Runloop.data_stream_on_connect: FD=" ^ Int.toString fd ^
                     ". Fd does not correspond to any node id.");
                ( state, Some (Remove fd ConcreteEventHandlerHelpers.id_callback) )
            )
          | Some node_id =>
                let
                    val connected_node_set = RuntimeState.get_connected_node_set state
                    val connected_node_info_opt = ConnectedNodeSet.search connected_node_set node_id
                in
                    case connected_node_info_opt of 
                        None => (
                            (* The connection has been deleted from the connected_node_set.
                             * It is a strange behaviour, but for now we ignore the error and
                             * just remove the data stream from the runloop and the reactor *)
                            Logger.warn 
                                (ConcreteEventHandlerHelpers.get_logger state)
                                ("Runloop.data_stream_on_connect: FD=" ^ Int.toString fd ^
                                 ", NodeID=" ^ Hex.bytes_to_hex node_id ^ "." ^
                                 " Node is not present in the ConnectedNodeSet.");
                            ConcreteEventHandlerHelpers.remove_fd None state fd
                        )
                      | Some connected_node_info =>
                            let
                                val new_state = 
                                    RuntimeState.map_to_network_state state
                                        (fn network_state => ConnectionManager.on_connect network_state connected_node_info fd)
                            in
                                ConcreteEventHandlerHelpers.process_on_connect_queue l_process_event_request fd node_id new_state
                            end
                end

    fun acceptor_on_accept state (acceptor_fd : int) (client_fd : int) (SockAddrIn client_addr client_port) =
        let
            fun close_fd fd = Fd.close fd handle _ => ()

            val network_state = RuntimeState.get_network_state state
            val node_data_set = NetworkState.get_node_data_set network_state
            val known_node_info_opt = NodeDataSet.search_by_address node_data_set client_addr
        in
            case known_node_info_opt of
                None => ( 
                    (* The address peer connected from is unknown. 
                     * Close the connection. *)
                    Logger.warn
                        (ConcreteEventHandlerHelpers.get_logger state)
                        ("Runloop.acceptor_on_accept: AcceptorFd=" ^ Int.toString acceptor_fd ^
                         ", ClientFd=" ^ Int.toString client_fd ^ 
                         ", ClientAddr=" ^ InAddr.to_string client_addr ^
                         ", ClientPort=" ^ Int.toString client_port ^
                         ". No such address is in NodeDataSet.");
                    close_fd client_fd;
                    (state, None)
                )
              | Some known_node_info =>
                    let
                        val node_id = KnownNodeInfo.get_id known_node_info

                        fun process state =
                            let
                                val config = RuntimeState.get_config state

                                val new_state =
                                    RuntimeState.map_to_runloop (
                                        (RuntimeState.map_to_network_state state
                                            (fn network_state => ConnectionManager.process_connection network_state known_node_info client_fd))
                                    ) (fn runloop => RunloopType.add_fd_to_node_id runloop client_fd node_id)

                                fun error_callback initial_state state errno = (
                                    close_fd client_fd;
                                    (initial_state, None)
                                )
                                val add_existing_data_stream_request =
                                    AddExistingReadWriteDataStream (Hex.bytes_to_hex node_id) client_fd
                                    (ReadHandler data_stream_on_read) (ErrHandler data_stream_on_error)
                                    (Config.get_read_buffer_size config) (Config.get_read_buffer_lwm config)
                                    (Config.get_write_buffer_size config) (Config.get_write_buffer_lwm config)
                                    (ConcreteEventHandlerHelpers.process_on_connect_queue l_process_event_request client_fd node_id) (error_callback state)
                            in
                                (new_state, Some add_existing_data_stream_request)
                            end
                    in
                        case ConnectionManager.get_connection_status network_state node_id of
                            Unknown => process state    
                          | _ => 
                                (* The connection with the peer has already been established,
                                 * or is establishing right now. Accepting a connection request
                                 * from the peer means that both nodes has initiated the connection
                                 * at the same time. In that case, the node with lower id is the main
                                 * connection initiator. If the connected node has lower id we
                                 * accept the connection, and start on_connect_queue processing.
                                 * Otherwise, we just close the connection *)
                                let
                                    val this_node_id = (RunloopType.get_node_id o RuntimeState.get_runloop) state
                                in
                                    case Guid.compare node_id this_node_id of
                                        Less =>
                                            let
                                                val connected_node_set = NetworkState.get_connected_node_set network_state
                                                val fd_opt = 
                                                    Option.mapPartial
                                                        ConnectedNodeInfo.get_fd_opt
                                                        (ConnectedNodeSet.search connected_node_set node_id)
                                                        
                                                val new_state =
                                                    RuntimeState.map_to_runloop (
                                                        (RuntimeState.map_to_network_state state
                                                            (fn network_state => ConnectionManager.remove network_state node_id))
                                                    ) (fn runloop => 
                                                            case fd_opt of 
                                                                None => runloop
                                                              | Some fd => (RunloopType.remove_fd_to_node_id runloop fd)
                                                    )
                                            in
                                                (* In general, as the connection has already been established on some
                                                 * descriptor, we should remove the desrciptor from the reactor.
                                                 * However, if the connection is still in progress, currently,
                                                 * the file descriptor is not kept in connected_node_info, and
                                                 * is only kept in RunloopType.fd_to_node_id structure. Probably,
                                                 * we should locate the descriptor in this map. But for now it is not
                                                 * done. TODO: consider the problem. *)
                                                process new_state
                                            end
                                      | _ => ( close_fd client_fd; (state, None) )
                                end
                    end
        end

    (*  Error on acceptor is cosidered to be critical,
     *  and should terminate the whole node. *)
    fun acceptor_on_error state (fd : int) (errno : int) = 
        ConcreteEventHandlerHelpers.critical_error_callback "acceptor_on_error" state errno

    fun round_timer_on_timer state (fd : int) (n_exp : int) =
        let
            val round_manager_state = RuntimeState.get_round_manager_state state
            val (new_round_manager_state, event_request_opt) = RoundManager.process_local_timeout round_manager_state
            
            val new_state = RuntimeState.set_round_manager_state state new_round_manager_state
        in
            case event_request_opt of
                None => (new_state, None)
              | Some request => l_process_event_request None new_state request None
        end

    (*  Error on round timer is cosidered to be critical,
     *  and should terminate the whole node. *)
    fun round_timer_on_error state (fd : int) (errno : int) = 
        ConcreteEventHandlerHelpers.critical_error_callback "round_timer_on_error" state errno

    fun new_connection_timer_on_timer state (fd : int) (n_exp : int) = 
        let
            fun connect_to_unconnected_nodes state =    
                let
                    val network_state = RuntimeState.get_network_state state
                    val this_node_id = (RunloopType.get_node_id o RuntimeState.get_runloop) state
                in
                    case NetworkState.new_node_connection network_state this_node_id of
                        None => (state, None)
                      | Some known_node_info => 
                            l_connect (Some connect_to_unconnected_nodes) state known_node_info
                end
        in
            connect_to_unconnected_nodes state
        end

    (*  Error on new connection timer is cosidered to be critical,
     *  and should terminate the whole node. *)
    fun new_connection_timer_on_error state (fd : int) (errno : int) = 
        ConcreteEventHandlerHelpers.critical_error_callback "new_connection_timer_on_error" state errno

    fun transaction_broadcast_timer_on_timer state (fd : int) (n_exp : int) = (state, None)

    (*  Error on transaction broadcast timer is cosidered to be critical,
     *  and should terminate the whole node. *)
    fun transaction_broadcast_timer_on_error state (fd : int) (errno : int) = 
        ConcreteEventHandlerHelpers.critical_error_callback "transaction_broadcast_timer_on_error" state errno

    fun internal_pipe_read_fd_on_read state (fd : int) (buff : io_buffer) =
        let
            fun process_events state =
                let
                    val this_node_id = (RunloopType.get_node_id o RuntimeState.get_runloop) state
                    val (msg_opt, msg_size) = 
                        MessageParser.deserialize (IOBuffer.read buff (IOBuffer.size buff))
                in
                    IOBuffer.consume_and_crunch buff msg_size;
                    case msg_opt of
                        None => (state, None)
                      | Some (msg_prefix, msg_content) => 
                            ConcreteEventHandlerHelpers.process_socket_event l_process_event_request
                                ConcreteEventHandlerHelpers.update_transaction_pool
                                (Some process_events) state this_node_id msg_prefix msg_content
                end

            val (final_state, request_opt) = process_events state
        in
            (final_state, 0, request_opt)
        end

    (*  Error on internal pipe read fd is cosidered to be critical,
     *  and should terminate the whole node. *)
    fun internal_pipe_read_fd_on_error state (fd : int) (errno : int) = 
        ConcreteEventHandlerHelpers.critical_error_callback "internal_pipe_read_fd_on_error" state errno

    (*  Error on internal pipe write fd is cosidered to be critical,
     *  and should terminate the whole node. *)
    fun internal_pipe_write_fd_on_error state (fd : int) (errno : int) = 
        ConcreteEventHandlerHelpers.critical_error_callback "internal_pipe_write_fd_on_error" state errno

        (* TODO: add function to add Write  *)
end
structure Runloop =
struct
    fun create_and_run
            config
            block_store
            storage
            state_computer
            transaction_pool
            round_state
            round_manager
            node_data_set
            runloop_logger
            reactor_logger
            api_params_opt
            synchronizer =
        let
            val outbuf = ByteArray.empty 9
            val _ = #(runloop_init_pipe) "" outbuf
            val _ = FFIHelper.validate_status outbuf
            handle FFIFailure => (
                Logger.critical
                    runloop_logger
                    ("Runloop.create_and_run: creation of a mean for " ^
                     "internal communication failed with Error=" ^ 
                     Int.toString (Errno.errno ()) ^ ".");
                Runtime.exit 1
            )
            val internal_pipe_read_fd = MarshallingHelp.w42n outbuf 1
            val internal_pipe_write_fd = MarshallingHelp.w42n outbuf 5

            val this_node_id = RoundManager.get_node_id round_manager

            val runloop = RunloopType.init this_node_id runloop_logger internal_pipe_read_fd internal_pipe_write_fd
            val network_state = NetworkState.init node_data_set
            
            val state = RuntimeState.create 
                config runloop round_manager round_state 
                block_store storage state_computer transaction_pool 
                network_state None synchronizer

            (*  Setup request that initializes the reactor. Initialization process
             *  includes 6 steps:
             *      1) Adding read and write ends of the pipe which will be used
             *          for internal communication.
             *      2) Adding acceptor, that waits for new connections from other peers.
             *      3) Adding round timer, that indicates when timeout occurs for the round;
             *          initially is set to zero, and should be updated with correct value 
             *          before starting the reactor.
             *      4) Adding new connection timer, that indicates the time when
             *          the node should try to connect to a new unconnected peer.
             *      5) Adding transaction broadcast timer, that indicates the time
             *          when the node should broadcast to random peers transaction
             *          the node knows about.
             *      6) In case if runloop api parameters are provided, api is 
             *          initialized.
             *      
             *  When all steps are finished, a new round is started.
             *)
            fun error_callback a_where state errno = (
                Logger.critical
                    runloop_logger
                    ("Runloop.create: " ^ a_where ^ " initialization failed with Error=" ^
                     Int.toString errno ^ ".");
                (state, Some ExitRun)
            )

            fun start_round state =
                let
                    val round_manager_state = RuntimeState.get_round_manager_state state
                    val (processed_round_manager_state, timer_request_opt) = 
                        RoundManager.process_certificates round_manager_state

                    val processed_state = 
                        RuntimeState.set_round_manager_state state processed_round_manager_state
                in
                    case timer_request_opt of
                        None => (processed_state, None)
                      | Some timer_data =>
                            ConcreteEventHandlers.l_process_event_request None processed_state (InternalTimerDataEvent timer_data) None
                end

            fun add_transaction_broadcast_timer_callback state fd = 
                case api_params_opt of
                    None => start_round state
                  | Some (api_logger, api_in_path, api_out_path, broadcast_path) =>
                        RunloopApi.init (Some start_round) api_logger api_in_path api_out_path broadcast_path state
            fun add_new_connection_timer_callback state fd =
                let
                    val transaction_broadcast_timeout = Config.get_transaction_broadcast_timeout config
                    val request = AddTimer "TransactionBroadcastTimer"
                            transaction_broadcast_timeout transaction_broadcast_timeout
                            (TimerHandler ConcreteEventHandlers.transaction_broadcast_timer_on_timer)
                            (ErrHandler ConcreteEventHandlers.transaction_broadcast_timer_on_error)
                            add_transaction_broadcast_timer_callback (error_callback "TransactionBroadcastTimer")
                in
                    (state, Some request)
                end
            fun add_round_timer_callback state fd = 
                let
                    val runloop = RuntimeState.get_runloop state
                    val new_runloop = RunloopType.set_round_timer_fd runloop fd
                    val new_state = RuntimeState.set_runloop state new_runloop

                    val new_connection_timeout = Config.get_new_connection_timeout config
                    val request = AddTimer "NewConnectionTimer"
                            new_connection_timeout new_connection_timeout
                            (TimerHandler ConcreteEventHandlers.new_connection_timer_on_timer)
                            (ErrHandler ConcreteEventHandlers.new_connection_timer_on_error)
                            add_new_connection_timer_callback (error_callback "NewConnectionTimer")
                in
                    (new_state, Some request)
                end
            fun add_acceptor_callback state fd =
                let
                    val request = AddTimer "RoundTimer" 0 0
                            (TimerHandler ConcreteEventHandlers.round_timer_on_timer)
                            (ErrHandler ConcreteEventHandlers.round_timer_on_error)
                            add_round_timer_callback (error_callback "RoundTimer")
                in
                    (state, Some request)
                end
            fun add_internal_pipe_write_fd_callback state =
                let
                    val request = AddAcceptor "Acceptor" 
                            (AcceptHandler ConcreteEventHandlers.acceptor_on_accept) 
                            (ErrHandler ConcreteEventHandlers.acceptor_on_error)
                            (Config.get_acceptor_address config) (Config.get_backlog_size config)
                            add_acceptor_callback (error_callback "Acceptor")
                in
                    (state, Some request)
                end
            fun add_internal_pipe_read_fd_callback state =
                let
                    val request = AddWriteFile "InternalPipeWriteFd"
                            internal_pipe_write_fd
                            (ErrHandler ConcreteEventHandlers.internal_pipe_write_fd_on_error)
                            (Config.get_write_buffer_size config) (Config.get_write_buffer_lwm config)
                            add_internal_pipe_write_fd_callback (error_callback "InternalPipeWriteFd")
                in
                    (state, Some request)
                end

            val setup_request = AddReadFile "InternalPipeReadFd"
                    internal_pipe_read_fd
                    (ReadHandler ConcreteEventHandlers.internal_pipe_read_fd_on_read)
                    (ErrHandler ConcreteEventHandlers.internal_pipe_read_fd_on_error)
                    (Config.get_read_buffer_size config) (Config.get_read_buffer_lwm config)
                    add_internal_pipe_read_fd_callback (error_callback "InternalPipeReadFd")
                    

            val reactor_opt = Reactor.init state reactor_logger setup_request 
                (PollHandler ConcreteEventHandlers.on_poll)
        in
            case reactor_opt of 
                None => (
                    Logger.critical
                        runloop_logger
                        "Runloop.create: initialization failed.";
                    (* Initialization failed. Clean the descriptors that refer to
                     * the internal communication pipe. Ignore any errors here. *)
                    Fd.close internal_pipe_read_fd
                    handle _ => ();
                    Fd.close internal_pipe_write_fd
                    handle _ => ();
                    Runtime.exit 1
                )
              | Some reactor => (
                    Reactor.run reactor;
                    (* Node is terminating. Clean the descriptors that refer to
                     * the internal communication pipe. Ignore any errors here. *)
                    Fd.close internal_pipe_read_fd
                    handle _ => ();
                    Fd.close internal_pipe_write_fd
                    handle _ => ();
                    (* If runloop api has been setup, it should be cleaned up. *)
                    case (RuntimeState.get_runloop_api_opt o Reactor.get_state) reactor of
                        None => ()
                      | Some runloop_api => RunloopApi.clean_up runloop_api;
                    Runtime.exit 0
              )

        end
end

(* val _ = print "\n\n===HELLO====\n\n"

val acceptor_address = SockAddrIn (InAddr.from_string "127.0.0.1") 12345
val backlog_size = 100
val new_connection_timeout = 5000000
val transaction_broadcast_timeout = 5000000
val read_buffer_size = 64000
val read_buffer_lwm = 32000
val write_buffer_size = 64000
val write_buffer_lwm = 32000
val _ = print "\n\n===HELLO_0====\n\n"
val config = Config.create acceptor_address backlog_size new_connection_timeout transaction_broadcast_timeout
                read_buffer_size read_buffer_lwm write_buffer_size write_buffer_lwm

val _ = print "\n\n===HELLO_1====\n\n"

val runloop_logger = StdOutLogger.init LoggerLevel.Info
val reactor_logger = StdOutLogger.init LoggerLevel.Info
val runloop_logger = StdOutLogger.init LoggerLevel.Info

val genesis_block = Block.init ()
val keypair = Keypair.generate ()
val node_id = Guid.zero ()

val _ = print "\n\n===HELLO_2====\n\n"

val storage = Storage.db_open (Storage.db_destroy (Storage.create()))
val _ = print "\n\n===HELLO_3====\n\n"
val persistent_computer = PersistentStateComputer.create storage genesis_block
val _ = print "\n\n===HELLO_4====\n\n"
val (PersistentBlockStoreComputer block_store storage state_computer) = 
    PersistentBlockStoreComputer.create persistent_computer genesis_block
val _ = print "\n\n===HELLO_5====\n\n"
val transaction_pool = TransactionPool []
val round_state = RoundState 0 (PendingVotes.init())
val _ = print "\n\n===HELLO_6====\n\n"
val round_manager = RoundManager runloop_logger node_id keypair [node_id]
val node_data_set = NodeDataSet.init []

val _ = print "\n\n===HELLO_7====\n\n"

val _ = Runloop.create_and_run 
    config block_store storage state_computer
    transaction_pool round_state round_manager
    node_data_set runloop_logger reactor_logger *)
(* 
 * Type that is used in parser state. All params are necessary for initialization.
 * Otherwise ```InitializeLackOfArguments``` raised.
*)
datatype init_state = Initialize (keypair option) 
                                 (block option) (* genesis block *)
                                 ((known_node_info list) option) 
                                 (string option) (* api in path *)
                                 (string option) (* api out path *)
                                 (string option) (* broadcast pipe path *)
                                 (int option) (* max block size *)
                                 (string option) (* init_delay, double as string *)
                                 (string option) (* base_exp, double as string *)
                                 (LoggerLevel.level option) (* logger level*)
                                 (bool) (* log into stdout flag, default false *)
                                 (int option) (* commits count limit in synchronization *)
                                 (int option) (* blocks count limit in synchronization *);

(**
 *  Exception that is raised when no account found by keypair
 *)
exception InitializeInconsistentKeyString string;
(**
 *  Exception that is raised when keypair string is invalid
 *)
exception InitializeInconsistentKeypair keypair;
(**
 *  Exception that is raised when no or more then one account found by guid
 *)
exception InitializeInconsistentNodesInfo (known_node_info list);
(**
 *  Exception that is raised when there are no validators in genesis block
 *)
exception InitializeInconsistentGenesis block;
(**
 *  Exception that is raised when not enough information was provided in cl arguments
 *)
exception InitializeLackOfArguments;

structure InitializePrivate = 
struct
    fun set_key_pair (Initialize _ gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_key_pair =
        Initialize new_key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_genesis (Initialize key_pair _ known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_genesis =
        Initialize key_pair new_genesis known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_known_node_info_list (Initialize key_pair gen_block _ apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_node_info_list =
        Initialize key_pair gen_block new_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_apiin (Initialize key_pair gen_block known_node_info_list _ apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_apiin =
        Initialize key_pair gen_block known_node_info_list new_apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_apiout (Initialize key_pair gen_block known_node_info_list apiin _ broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_apiout =
        Initialize key_pair gen_block known_node_info_list apiin new_apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_broadcast (Initialize key_pair gen_block known_node_info_list apiin apiout _ max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_broadcast =
        Initialize key_pair gen_block known_node_info_list apiin apiout new_broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_max_block_size (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast _ init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_max_block_size =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast new_max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_init_delay (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size _ base_exp logger_level stdout_log sync_commits_size sync_blocks_size) new_init_delay =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size new_init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_base_exp (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay _ logger_level stdout_log sync_commits_size sync_blocks_size) new_base_exp =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay new_base_exp logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_logger_level (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp _ stdout_log sync_commits_size sync_blocks_size) new_logger_level =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp new_logger_level stdout_log sync_commits_size sync_blocks_size

    fun set_stdout_log (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level _ sync_commits_size sync_blocks_size) new_stdout_log =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level new_stdout_log sync_commits_size sync_blocks_size

    fun set_sync_commits_size (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log _ sync_blocks_size) new_sync_commits_size =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log new_sync_commits_size sync_blocks_size

    fun set_sync_blocks_size (Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size _) new_sync_blocks_size =
        Initialize key_pair gen_block known_node_info_list apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size new_sync_blocks_size

    fun read_func filename =
        TextIO.inputAll (TextIO.openIn filename)

    fun process_key_string key_string = 
        let
            val _ = if (String.size key_string) <> 2 * (Keypair.priv_size() + Keypair.pub_size() + 2)
                    then raise InitializeInconsistentKeyString key_string
                    else ()
            val private_str = String.substring key_string 0 (2 * Keypair.priv_size() + 2)
            val public_str = String.substring key_string (2 * Keypair.priv_size() + 2) (2 * Keypair.pub_size() + 2)
            val private_key = Hex.hex_to_bytes private_str
            val public_key = Hex.hex_to_bytes public_str
        in
            Keypair private_key public_key
        end

    fun deserialize_hex_str deser_fun str_obj =
        let 
            val byte_obj = Hex.hex_to_bytes str_obj
            val (obj, _) = deser_fun byte_obj
        in 
            obj
        end

    fun matched_keypair_and_account (Keypair private_key public_key) account =
        let
            val account_public_keys = Account.get_public_keys account
        in
            Set.member account_public_keys public_key
        end

    fun get_guid_by_keypair keypair account_list =
        let
            val filtered = List.filter (matched_keypair_and_account keypair) account_list
            val _ = if (List.length filtered) <> 1
                    then raise InitializeInconsistentKeypair keypair
                    else ()
        in
            Account.get_account_id (List.hd filtered)
        end

    fun get_address_from_node_info node_guid nodes_info =
        let
            fun filter_f node_info =
                (ByteArray.compare node_guid (KnownNodeInfo.get_id node_info)) = Equal

            val filtered_info = List.filter (filter_f) nodes_info
        in
            case List.length filtered_info of
              1 => (KnownNodeInfo.get_address (List.hd filtered_info), KnownNodeInfo.get_port (List.hd filtered_info))
            | _ => raise InitializeInconsistentNodesInfo nodes_info
        end

    fun ensure_required_params (Initialize keypair_opt genesis_opt nodes_info_opt apiin_opt apiout_opt broadcast_opt max_block_size_opt init_delay_opt base_exp_opt logger_level_opt stdout_log sync_commits_size_opt sync_blocks_size_opt) =
        let
            val _ = if Option.isNone keypair_opt orelse
                       Option.isNone genesis_opt orelse
                       Option.isNone nodes_info_opt orelse
                       Option.isNone apiin_opt orelse
                       Option.isNone apiout_opt orelse
                       Option.isNone broadcast_opt
                    then raise InitializeLackOfArguments
                    else ()
            val keypair = Option.valOf keypair_opt
            val genesis = Option.valOf genesis_opt
            val nodes_info = Option.valOf nodes_info_opt
            val apiin = Option.valOf apiin_opt
            val apiout = Option.valOf apiout_opt
            val broadcast = Option.valOf broadcast_opt
            val max_block_size = Option.getOpt max_block_size_opt (*default value=*)10
            val init_delay = Double.fromString (Option.getOpt init_delay_opt (*default value=*) "1")
            val base_exp = Double.fromString (Option.getOpt base_exp_opt (*default value=*) "1.2")
            val logger_level = Option.getOpt logger_level_opt (LoggerLevel.Info)
            val sync_commits_size = Option.getOpt sync_commits_size_opt (*default value=*)100
            val sync_blocks_size = Option.getOpt sync_blocks_size_opt (*default value=*)100
        in
            (keypair, genesis, nodes_info, apiin, apiout, broadcast, max_block_size, init_delay, base_exp, logger_level, stdout_log, sync_commits_size, sync_blocks_size)
        end
end

structure Initialize = 
struct
    fun get_default_state () =
        Initialize None None None None None None None None None None False None None

    (**
     *  Update state using argument from command line.
     *
     *  @param state: ```init_state``` 
     *  Contains current information about read arguments.
     *
     *  @param (arg, value): ```string * (string option)```
     *  Argument and its value, passed through command line.
     *
     *  @return ```init_state``` updated.
     *)

    fun process_argument logger state (arg, value) =
        let
            (* read from file option *)
            val (arg, value) = if String.isPrefix "f" arg
                               then (String.extract arg 1 None, Option.map (InitializePrivate.read_func) value)
                               else (arg, value)

            val _ = Logger.info logger ("Parsing arg: " ^ arg)
            val _ = Logger.info logger ("Parsing value: " ^ (Option.getOpt value ""))

            (* NOTE: Unsafe section - no checks for exceptions *)
            val state = (if arg = "k"
                           orelse arg = "keypair"
                        then InitializePrivate.set_key_pair state (Option.map (InitializePrivate.process_key_string) value)
                        else state)
                        handle _ => (Logger.critical logger "Can't decode keypair"; state)

            val state = (if arg = "g"
                           orelse arg = "genesis"
                        then InitializePrivate.set_genesis state (Option.map (InitializePrivate.deserialize_hex_str (Block.deserialize)) value)
                        else state)
                        handle _ => (Logger.critical logger "Can't decode genesis"; state)

            val state = (if arg = "n"
                           orelse arg = "nodesinfo"
                        then InitializePrivate.set_known_node_info_list state (Option.map 
                                                                (InitializePrivate.deserialize_hex_str 
                                                                    (Serialization.decode_list KnownNodeInfo.deserialize)) 
                                                                value)
                        else state)
                        handle _ => (Logger.critical logger "Can't decode nodes info"; state)

            val state = if arg = "i"
                           orelse arg = "apiin"
                        then InitializePrivate.set_apiin state value
                        else state

            val state = if arg = "o"
                           orelse arg = "apiout"
                        then InitializePrivate.set_apiout state value
                        else state

            val state = if arg = "b"
                           orelse arg = "broadcast"
                        then InitializePrivate.set_broadcast state value
                        else state

            val state = if arg = "m"
                           orelse arg = "max-block-size"
                        then InitializePrivate.set_max_block_size state (Option.join (Option.map (Int.fromNatString) value))
                        else state

            val state = if arg = "d"
                           orelse arg = "init-delay"
                        then InitializePrivate.set_init_delay state value
                        else state

            val state = if arg = "e"
                           orelse arg = "base-exp"
                        then InitializePrivate.set_base_exp state value
                        else state

            val state = if arg = "l"
                           orelse arg = "logger-level"
                        then InitializePrivate.set_logger_level state  (Option.join (Option.map (LoggerLevel.from_string) value))
                        else state

            val state = if arg = "s"
                           orelse arg = "stdout-log"
                        then InitializePrivate.set_stdout_log state True
                        else state

            val state = if arg = "c"
                           orelse arg = "sync-commits-size"
                        then InitializePrivate.set_sync_commits_size state (Option.join (Option.map (Int.fromNatString) value))
                        else state

            val state = if arg = "h"
                           orelse arg = "sync-blocks-size"
                        then InitializePrivate.set_sync_blocks_size state (Option.join (Option.map (Int.fromNatString) value))
                        else state
        in
            state
        end

    (**
     *  Apply ```Initialize``` parser to ```Argp``` module.
     *
     *  @return ```init_state``` filled.
     *)
    fun read_args logger =
        Argp.parse (Argp (process_argument logger)) (get_default_state())

    (**
     *  Create runloop using general parameters.
     *
     *  @param keypair: ```keypair``` 
     *  Contains keypair of users node.
     *
     *  @param genesis_block: ```block```
     *  Genesis block. Contains information about validators.
     *
     *  @param known_node_info: ```known_node_info list```
     *  List of information about known node
     *
     *  @return ```runloop``` created
     *)
    fun create_runloop_from_args keypair genesis_block known_node_info_list logger apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size =
        let
            val logger = if stdout_log then StdOutLogger.init logger_level else Logger.set_level logger logger_level
            val _ = Logger.info logger "Initializing database...\n"

            val storage = Storage.db_open (Storage.create())

            val _ = Logger.info logger "Resolving genesis acccounts..."

            val genesis_accs_opt = Block.get_accounts genesis_block
            val _ = if Option.isNone genesis_accs_opt
                    then raise InitializeInconsistentGenesis genesis_block
                    else ()
            val genesis_accs = Set.to_list (Option.valOf (Block.get_accounts genesis_block))

            val _ = Logger.info logger ("Genesis accounts count: " ^ (Int.toString (List.length genesis_accs)))
            val _ = Logger.info logger ("Genesis accounts:")
            val _ = List.map (fn account => Logger.info logger (Account.to_string "" account)) genesis_accs

            val _ = Logger.info logger "Validating known nodes info..."

            val guid_filter_list = List.map (KnownNodeInfo.get_id) known_node_info_list
            (* Checks, that all ids are unique *)
            (* TODO: make this check faster *)
            val _ = if List.exists (fn x => (List.length(List.filter (ByteArray.equal x) guid_filter_list)) <> 1) 
                                   guid_filter_list
                    then raise InitializeInconsistentNodesInfo known_node_info_list
                    else ()

            val _ = Logger.info logger "Resolving validators..."

            (* If validator id in known_nodes_info ids *)
            val validators = List.filter (fn x => List.exists (ByteArray.equal (Account.get_account_id x))
                                                              guid_filter_list)
                                          genesis_accs

            val _ = Logger.info logger ("Validators count: " ^ (Int.toString (List.length validators)))

            val _ = Logger.info logger "Resolving current node..."
            val _ = Logger.info logger ("Node pubkey: " ^ (Hex.bytes_to_hex (Keypair.get_pub_key keypair)))

            val node_guid = InitializePrivate.get_guid_by_keypair keypair validators
            val validators_guid = List.map (Account.get_account_id) validators

            val _ = Logger.info logger ("Node guid: " ^ (Hex.bytes_to_hex node_guid))

            val _ = Logger.info logger ("Max block size: " ^ (Int.toString max_block_size))

            val round_manager = RoundManager logger node_guid keypair validators_guid max_block_size

            val _ = Logger.info logger "Initialize modules..."

            val round_state = RoundState logger init_delay base_exp 0 (PendingVotes.init())
            val _ = Logger.info logger "Initialize modules_1..."
            val node_data_set = NodeDataSet.init known_node_info_list
            val _ = Logger.info logger "Initialize modules_2..."
            val transaction_pool = TransactionPool []
            val _ = Logger.info logger "Initialize modules_3..."
            val persistent_computer = PersistentStateComputer.create storage genesis_block
            val _ = Logger.info logger "Initialize modules_4..."
            val (PersistentBlockStoreComputer block_store storage state_computer) = 
                PersistentBlockStoreComputer.create persistent_computer genesis_block

            val _ = Logger.info logger "Resolving node address..."

            val (address, port) = InitializePrivate.get_address_from_node_info node_guid known_node_info_list

            val _ = Logger.info logger ("Node address: " ^ (InAddr.to_string address) ^ ":" ^ (Int.toString port))

            val _ = Logger.info logger ("Api in path: " ^ apiin ^ "\n")
            val _ = Logger.info logger ("Api out path: " ^ apiout ^ "\n")
            val api_params_opt = Some (logger, apiin, apiout, broadcast)

            val synchronizer = Synchronizer logger validators_guid sync_commits_size sync_blocks_size

            val backlog_size = 100
            val new_connection_timeout = 50000000
            val transaction_broadcast_timeout = 50000000
            val read_buffer_size = 64000 
            val read_buffer_lwm = 32000 
            val write_buffer_size = 64000 
            val write_buffer_lwm = 32000
            val config = Config.create (SockAddrIn address port) backlog_size new_connection_timeout transaction_broadcast_timeout
                read_buffer_size read_buffer_lwm write_buffer_size write_buffer_lwm

            (* val reactor = 
                Runloop.create
                    block_store 
                    storage 
                    state_computer 
                    transaction_pool 
                    round_state 
                    round_manager 
                    node_data_set 
                    logger 
                    (SockAddrIn address port)
                    None
                    api_params *)
        in
            Runloop.create_and_run
                config block_store storage state_computer
                transaction_pool round_state round_manager
                node_data_set logger logger api_params_opt
                synchronizer
        end

    (**
     *  Create runloop using comand line parameters.
     *  Call Initialize.create_runloop_from_args
     *
     *  @param logger Logger to use in the modules
     *
     *  @return ```runloop``` created
     *)
    fun create_from_args logger =
        let
            val _ = Logger.info logger "Parsing parameters...\n"
            val (keypair, genesis, nodes_info, apiin, apiout, broadcast, max_block_size, init_delay, base_exp, logger_level, stdout_log, sync_commits_size, sync_blocks_size) = InitializePrivate.ensure_required_params (read_args logger)
        in
            create_runloop_from_args keypair genesis nodes_info logger apiin apiout broadcast max_block_size init_delay base_exp logger_level stdout_log sync_commits_size sync_blocks_size
        end
end;

val _ = Exception.add_exn_name_printer 
	(fn e => 
		case e of 
            InitializeInconsistentKeyString _ => "InitializeInconsistentKeyString"
		  | InitializeInconsistentKeypair _ => "InitializeInconsistentKeypair"
          | InitializeInconsistentNodesInfo _ => "InitializeInconsistentNodesInfo"
          | InitializeInconsistentGenesis _ => "InitializeInconsistentGenesis"
          | InitializeLackOfArguments => "InitializeLackOfArguments"
		  | _ => raise Exception.Unknown
	)
val _ = Exception.add_exn_message_printer
	(fn e =>
		case e of
		    InitializeInconsistentKeyString v1 => 
                "InitializeInconsistentKeyString" ^ " " ^ v1
		  | InitializeInconsistentKeypair (Keypair v1 v2) => 
                "InitializeInconsistentKeypair" ^ " " ^ "(Keypair" ^ " " ^ Hex.bytes_to_hex v1 ^ " " ^ Hex.bytes_to_hex v2 ^ ")"
          | InitializeInconsistentNodesInfo v1 => 
                "InitializeInconsistentNodesInfo" ^ " " ^ "(Some known_node_info list)"
          | InitializeInconsistentGenesis v1 => 
                "InitializeInconsistentGenesis" ^ "\n" ^ Block.to_string "  " v1
          | InitializeLackOfArguments => 
                "InitializeLackOfArguments"
		  | _ => raise Exception.Unknown
	)
fun main logger =
	let
		val reactor = Initialize.create_from_args logger
	in
		()
	end;

val logger = FileLogger.init "node.log" LoggerLevel.Info;
main logger
handle exp => Logger.critical logger ("Unhandled exception: " ^ (Exception.exnName exp));